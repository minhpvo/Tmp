#include "Geometry1.h"
#include "Geometry2.h"
#include "../ThirdParty/rP6P/r6p.h"
#include "../ThirdParty/Theia/perspective_three_point.h"
#include "../ThirdParty/Theia/four_point_focal_length.h"
#include "../ThirdParty/Theia/epnp.h"
#include "../ThirdParty/Theia/dls_pnp.h"
//#include "../ThirdParty/Theia/util.h"

using ceres::AutoDiffCostFunction;
using ceres::CostFunction;
using ceres::CauchyLoss;
using ceres::SoftLOneLoss;
using ceres::HuberLoss;
using ceres::Problem;
using ceres::Solver;

using namespace std;
using namespace cv;
using namespace Eigen;

void NormalizePointsForDLT(vector<Point2d> &pts, double *H)
{
	int npts = (int)pts.size();
	double centerX = 0, centerY = 0, scale = 0;

	for (int ii = 0; ii < npts; ii++)
		centerX += pts[ii].x, centerY += pts[ii].y;
	centerX /= npts, centerY /= npts;

	for (int ii = 0; ii < npts; ii++)
		pts[ii].x -= centerX, pts[ii].y -= centerY;

	for (int ii = 0; ii < npts; ii++)
		scale += sqrt(pts[ii].x*pts[ii].x + pts[ii].y*pts[ii].y);
	scale /= npts;
	scale = scale / sqrt(2.0);

	for (int ii = 0; ii < npts; ii++)
		pts[ii].x /= scale, pts[ii].y /= scale;

	H[0] = 1.0 / scale, H[1] = 0, H[2] = -centerX / scale;
	H[3] = 0, H[4] = 1.0 / scale, H[5] = -centerY / scale;
	H[6] = 0, H[7] = 0, H[8] = 1.0;

	return;
}
int computeFmat8Point(vector<Point2d> &pts1, vector<Point2d> &pts2, double *Fmat)
{
	int ii;
	double u_a = 0.0, v_a = 0.0, u_b = 0.0, v_b = 0.0, dist, scale;
	int npts = (int)pts1.size();

	//1. Normalize
	Point2d *sa = new Point2d[npts];
	Point2d *sb = new Point2d[npts];
	Matrix < double, 3, 3, RowMajor > Ta, Tb;

	for (ii = 0; ii < npts; ii++)
	{
		u_a += pts1[ii].x, v_a += pts1[ii].y;
		u_b += pts2[ii].x, v_b += pts2[ii].y;
	}
	u_a = u_a / npts, v_a = v_a / npts;
	u_b = u_b / npts, v_b = v_b / npts;

	//a. Normalize image a
	dist = 0.0;
	for (ii = 0; ii < npts; ii++)
		dist += sqrt(pow(pts1[ii].x - u_a, 2) + pow(pts1[ii].y - v_a, 2));
	scale = dist / npts / sqrt(2.0);

	Ta(0, 0) = 1.0 / scale, Ta(0, 1) = 0.0, Ta(0, 2) = -u_a / scale;
	Ta(1, 0) = 0.0, Ta(1, 1) = 1.0 / scale, Ta(1, 2) = -v_a / scale;
	Ta(2, 0) = 0.0, Ta(2, 1) = 0.0, Ta(2, 2) = 1.0;

	for (ii = 0; ii < npts; ii++)
	{
		sa[ii].x = Ta(0, 0) * pts1[ii].x + Ta(0, 2);
		sa[ii].y = Ta(1, 1) * pts1[ii].y + Ta(1, 2);
	}

	//b. Normalize image b
	dist = 0.0;
	for (ii = 0; ii < npts; ii++)
		dist += sqrt(pow(pts2[ii].x - u_b, 2) + pow(pts2[ii].y - v_b, 2));
	scale = dist / npts / sqrt(2.0);

	Tb(0, 0) = 1.0 / scale, Tb(0, 1) = 0.0, Tb(0, 2) = -u_b / scale;
	Tb(1, 0) = 0.0, Tb(1, 1) = 1.0 / scale, Tb(1, 2) = -v_b / scale;
	Tb(2, 0) = 0.0, Tb(2, 1) = 0.0, Tb(2, 2) = 1.0;

	for (ii = 0; ii < npts; ii++)
	{
		sb[ii].x = Tb(0, 0) * pts2[ii].x + Tb(0, 2);
		sb[ii].y = Tb(1, 1) * pts2[ii].y + Tb(1, 2);
	}


	//2. Solving for F
	double x1, x2, y1, y2;
	MatrixXd A;
	A.setZero(npts, 9);
	for (int ii = 0; ii < npts; ii++)
	{
		x1 = sa[ii].x, y1 = sa[ii].y;
		x2 = sb[ii].x, y2 = sb[ii].y;
		A(ii, 0) = x2 * x1;
		A(ii, 1) = x2 * y1;
		A(ii, 2) = x2;
		A(ii, 3) = y2 * x1;
		A(ii, 4) = y2 * y1;
		A(ii, 5) = y2;
		A(ii, 6) = x1;
		A(ii, 7) = y1;
		A(ii, 8) = 1.0;
	}

	JacobiSVD<MatrixXd> svd(A, ComputeThinV);
	VectorXd sv = svd.singularValues();
	Map<VectorXd> eFvec(Fmat, 9);
	eFvec = svd.matrixV().col(8);

	//Rank 2 aproximation of F
	Map < Matrix < double, 3, 3, RowMajor > > eFmat(Fmat, 3, 3);
	JacobiSVD<MatrixXd> svd2(eFmat, ComputeFullU | ComputeFullV);
	VectorXd sv2 = svd2.singularValues(); sv2(2) = 0.0;
	eFmat = svd2.matrixU() *sv2.asDiagonal()*svd2.matrixV().transpose();

	//Denormalization:
	eFmat = Tb.transpose()*eFmat*Ta;

	//Normalize Fmat
	double L2 = L2norm(Fmat, 9);
	for (int ii = 0; ii < 9; ii++)
		Fmat[ii] /= L2;

	delete[]sa, delete[]sb;

	return 0;

}
int EvaluateFmat(vector<Point2d> &pts1, vector<Point2d> &pts2, double *Fmat, vector<int>  &vinliers, double &meanErr, double thresh)
{
	int ninliers = 0;
	double error; meanErr = 0.0;
	for (int ii = 0; ii < (int)pts1.size(); ii++)
	{
		error = FmatPointError(Fmat, pts1[ii], pts2[ii]);
		if (error > thresh)
			vinliers.push_back(0);
		else
		{
			vinliers.push_back(1);
			ninliers++;
			meanErr += error;
		}
	}
	meanErr /= (1e-9 + ninliers);

	return ninliers;
}

/// Homography estimation: start
void NormalizePointsForDLT(std::vector<Point2d>& pts, Eigen::Matrix<double, 3, 3, Eigen::RowMajor>& H)
{
	int npts = (int)pts.size();
	double centerX = 0, centerY = 0, scaleX = 0, scaleY = 0;

	for (int ii = 0; ii < npts; ii++)
		centerX += pts[ii].x, centerY += pts[ii].y;
	centerX /= npts, centerY /= npts;

	for (int ii = 0; ii < npts; ii++)
		scaleX += std::abs(pts[ii].x - centerX), scaleY += std::abs(pts[ii].y - centerY);
	scaleX /= npts, scaleY /= npts;

	for (int ii = 0; ii < npts; ii++)
		pts[ii].x = (pts[ii].x - centerX) / scaleX, pts[ii].y = (pts[ii].y - centerY) / scaleY;

	H(0) = 1.0 / scaleX, H(1) = 0, H(2) = -centerX / scaleX;
	H(3) = 0, H(4) = 1.0 / scaleY, H(5) = -centerY / scaleY;
	H(6) = 0, H(7) = 0, H(8) = 1.0;

	return;
}
Eigen::Matrix<double, 3, 3, Eigen::RowMajor> computeHomography4Point(std::vector<Point2d> pts1, std::vector<Point2d> pts2)
{
	// pts1 = H * pts2
	int npts = (int)pts1.size();

	// 1. Normalize points
	Eigen::Matrix<double, 3, 3, Eigen::RowMajor> T1, T2;
	NormalizePointsForDLT(pts1, T1);
	NormalizePointsForDLT(pts2, T2);

	// 2. Solving for H via DLT method
	double x2, y2, x1, y1;
	Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> A;
	A.setZero(2 * npts, 9);

	for (int i = 0; i < npts; i++)
	{
		x1 = pts1[i].x, y1 = pts1[i].y;
		x2 = pts2[i].x, y2 = pts2[i].y;

		A(2 * i, 0) = x2, A(2 * i, 1) = y2, A(2 * i, 2) = 1, A(2 * i, 3) = 0, A(2 * i, 4) = 0, A(2 * i, 5) = 0, A(2 * i, 6) = -x1 * x2, A(2 * i, 7) = -x1 * y2, A(2 * i, 8) = -x1;
		A(2 * i + 1, 0) = 0, A(2 * i + 1, 1) = 0, A(2 * i + 1, 2) = 0, A(2 * i + 1, 3) = x2, A(2 * i + 1, 4) = y2, A(2 * i + 1, 5) = 1.0, A(2 * i + 1, 6) = -y1 * x2, A(2 * i + 1, 7) = -y1 * y2, A(2 * i + 1, 8) = -y1;
	}


	Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeFullV);
	Eigen::VectorXd sv = svd.singularValues();
	Eigen::VectorXd eHvec = svd.matrixV().col(8);

	// Denormalization:
	Eigen::Matrix<double, 3, 3, Eigen::RowMajor> eH;
	eH(0) = eHvec(0), eH(1) = eHvec(1), eH(2) = eHvec(2), eH(3) = eHvec(3), eH(4) = eHvec(4), eH(5) = eHvec(5), eH(6) = eHvec(6), eH(7) = eHvec(7), eH(8) = eHvec(8);

	eH = T1.inverse() * eH * T2;

	// Normalize Hmat
	eH = eH / eH(2, 2);

	return eH;
}
/// Homography estimation: end
/*
class CvEMEstimator : public CvModelEstimator2
{
public:
	CvEMEstimator() : CvModelEstimator2(5, cvSize(3, 3), 10)
	{
	}
	virtual int runKernel(InputArray m1, InputArray m2, OutputArray model)
	{
		return run5Point(m1, m2, model);
	};
	virtual int run5Point(InputArray _m1, InputArray _m2, OutputArray _model)
	{
		// Notice to keep compatibility with opencv ransac, q1 and q2 have to be of 1 row x n col x 2 channel.
		//Mat Q1 = cvarrToMat(q1).reshape(1, q1->cols);
		//Mat Q2 = cvarrToMat(q2).reshape(1, q2->cols);
		Mat q1 = _m1.getMat(), q2 = _m2.getMat();
		Mat Q1 = q1.reshape(1, (int)q1.total());
		Mat Q2 = q2.reshape(1, (int)q2.total());

		int n = Q1.rows;
		Mat Q(n, 9, CV_64F);
		Q.col(0) = Q1.col(0).mul(Q2.col(0));
		Q.col(1) = Q1.col(1).mul(Q2.col(0));
		Q.col(2) = Q2.col(0) * 1.0;
		Q.col(3) = Q1.col(0).mul(Q2.col(1));
		Q.col(4) = Q1.col(1).mul(Q2.col(1));
		Q.col(5) = Q2.col(1) * 1.0;
		Q.col(6) = Q1.col(0) * 1.0;
		Q.col(7) = Q1.col(1) * 1.0;
		Q.col(8) = 1.0;

		Mat U, W, Vt;
		SVD::compute(Q, W, U, Vt, SVD::MODIFY_A | SVD::FULL_UV);

		Mat EE = Mat(Vt.t()).colRange(5, 9) * 1.0;
		Mat A(10, 20, CV_64F);
		EE = EE.t();
		getCoeffMat((double*)EE.data, (double*)A.data);
		EE = EE.t();

		A = A.colRange(0, 10).inv() * A.colRange(10, 20);

		double b[3 * 13];
		Mat B(3, 13, CV_64F, b);
		for (int i = 0; i < 3; i++)
		{
			Mat arow1 = A.row(i * 2 + 4) * 1.0;
			Mat arow2 = A.row(i * 2 + 5) * 1.0;
			Mat row1(1, 13, CV_64F, Scalar(0.0));
			Mat row2(1, 13, CV_64F, Scalar(0.0));

			row1.colRange(1, 4) = arow1.colRange(0, 3) * 1.0;
			row1.colRange(5, 8) = arow1.colRange(3, 6) * 1.0;
			row1.colRange(9, 13) = arow1.colRange(6, 10) * 1.0;

			row2.colRange(0, 3) = arow2.colRange(0, 3) * 1.0;
			row2.colRange(4, 7) = arow2.colRange(3, 6) * 1.0;
			row2.colRange(8, 12) = arow2.colRange(6, 10) * 1.0;

			B.row(i) = row1 - row2;
		}

		double c[11];
		Mat coeffs(1, 11, CV_64F, c);
		c[10] = (b[0] * b[17] * b[34] + b[26] * b[4] * b[21] - b[26] * b[17] * b[8] - b[13] * b[4] * b[34] - b[0] * b[21] * b[30] + b[13] * b[30] * b[8]);
		c[9] = (b[26] * b[4] * b[22] + b[14] * b[30] * b[8] + b[13] * b[31] * b[8] + b[1] * b[17] * b[34] - b[13] * b[5] * b[34] + b[26] * b[5] * b[21] - b[0] * b[21] * b[31] - b[26] * b[17] * b[9] - b[1] * b[21] * b[30] + b[27] * b[4] * b[21] + b[0] * b[17] * b[35] - b[0] * b[22] * b[30] + b[13] * b[30] * b[9] + b[0] * b[18] * b[34] - b[27] * b[17] * b[8] - b[14] * b[4] * b[34] - b[13] * b[4] * b[35] - b[26] * b[18] * b[8]);
		c[8] = (b[14] * b[30] * b[9] + b[14] * b[31] * b[8] + b[13] * b[31] * b[9] - b[13] * b[4] * b[36] - b[13] * b[5] * b[35] + b[15] * b[30] * b[8] - b[13] * b[6] * b[34] + b[13] * b[30] * b[10] + b[13] * b[32] * b[8] - b[14] * b[4] * b[35] - b[14] * b[5] * b[34] + b[26] * b[4] * b[23] + b[26] * b[5] * b[22] + b[26] * b[6] * b[21] - b[26] * b[17] * b[10] - b[15] * b[4] * b[34] - b[26] * b[18] * b[9] - b[26] * b[19] * b[8] + b[27] * b[4] * b[22] + b[27] * b[5] * b[21] - b[27] * b[17] * b[9] - b[27] * b[18] * b[8] - b[1] * b[21] * b[31] - b[0] * b[23] * b[30] - b[0] * b[21] * b[32] + b[28] * b[4] * b[21] - b[28] * b[17] * b[8] + b[2] * b[17] * b[34] + b[0] * b[18] * b[35] - b[0] * b[22] * b[31] + b[0] * b[17] * b[36] + b[0] * b[19] * b[34] - b[1] * b[22] * b[30] + b[1] * b[18] * b[34] + b[1] * b[17] * b[35] - b[2] * b[21] * b[30]);
		c[7] = (b[14] * b[30] * b[10] + b[14] * b[32] * b[8] - b[3] * b[21] * b[30] + b[3] * b[17] * b[34] + b[13] * b[32] * b[9] + b[13] * b[33] * b[8] - b[13] * b[4] * b[37] - b[13] * b[5] * b[36] + b[15] * b[30] * b[9] + b[15] * b[31] * b[8] - b[16] * b[4] * b[34] - b[13] * b[6] * b[35] - b[13] * b[7] * b[34] + b[13] * b[30] * b[11] + b[13] * b[31] * b[10] + b[14] * b[31] * b[9] - b[14] * b[4] * b[36] - b[14] * b[5] * b[35] - b[14] * b[6] * b[34] + b[16] * b[30] * b[8] - b[26] * b[20] * b[8] + b[26] * b[4] * b[24] + b[26] * b[5] * b[23] + b[26] * b[6] * b[22] + b[26] * b[7] * b[21] - b[26] * b[17] * b[11] - b[15] * b[4] * b[35] - b[15] * b[5] * b[34] - b[26] * b[18] * b[10] - b[26] * b[19] * b[9] + b[27] * b[4] * b[23] + b[27] * b[5] * b[22] + b[27] * b[6] * b[21] - b[27] * b[17] * b[10] - b[27] * b[18] * b[9] - b[27] * b[19] * b[8] + b[0] * b[17] * b[37] - b[0] * b[23] * b[31] - b[0] * b[24] * b[30] - b[0] * b[21] * b[33] - b[29] * b[17] * b[8] + b[28] * b[4] * b[22] + b[28] * b[5] * b[21] - b[28] * b[17] * b[9] - b[28] * b[18] * b[8] + b[29] * b[4] * b[21] + b[1] * b[19] * b[34] - b[2] * b[21] * b[31] + b[0] * b[20] * b[34] + b[0] * b[19] * b[35] + b[0] * b[18] * b[36] - b[0] * b[22] * b[32] - b[1] * b[23] * b[30] - b[1] * b[21] * b[32] + b[1] * b[18] * b[35] - b[1] * b[22] * b[31] - b[2] * b[22] * b[30] + b[2] * b[17] * b[35] + b[1] * b[17] * b[36] + b[2] * b[18] * b[34]);
		c[6] = (-b[14] * b[6] * b[35] - b[14] * b[7] * b[34] - b[3] * b[22] * b[30] - b[3] * b[21] * b[31] + b[3] * b[17] * b[35] + b[3] * b[18] * b[34] + b[13] * b[32] * b[10] + b[13] * b[33] * b[9] - b[13] * b[4] * b[38] - b[13] * b[5] * b[37] - b[15] * b[6] * b[34] + b[15] * b[30] * b[10] + b[15] * b[32] * b[8] - b[16] * b[4] * b[35] - b[13] * b[6] * b[36] - b[13] * b[7] * b[35] + b[13] * b[31] * b[11] + b[13] * b[30] * b[12] + b[14] * b[32] * b[9] + b[14] * b[33] * b[8] - b[14] * b[4] * b[37] - b[14] * b[5] * b[36] + b[16] * b[30] * b[9] + b[16] * b[31] * b[8] - b[26] * b[20] * b[9] + b[26] * b[4] * b[25] + b[26] * b[5] * b[24] + b[26] * b[6] * b[23] + b[26] * b[7] * b[22] - b[26] * b[17] * b[12] + b[14] * b[30] * b[11] + b[14] * b[31] * b[10] + b[15] * b[31] * b[9] - b[15] * b[4] * b[36] - b[15] * b[5] * b[35] - b[26] * b[18] * b[11] - b[26] * b[19] * b[10] - b[27] * b[20] * b[8] + b[27] * b[4] * b[24] + b[27] * b[5] * b[23] + b[27] * b[6] * b[22] + b[27] * b[7] * b[21] - b[27] * b[17] * b[11] - b[27] * b[18] * b[10] - b[27] * b[19] * b[9] - b[16] * b[5] * b[34] - b[29] * b[17] * b[9] - b[29] * b[18] * b[8] + b[28] * b[4] * b[23] + b[28] * b[5] * b[22] + b[28] * b[6] * b[21] - b[28] * b[17] * b[10] - b[28] * b[18] * b[9] - b[28] * b[19] * b[8] + b[29] * b[4] * b[22] + b[29] * b[5] * b[21] - b[2] * b[23] * b[30] + b[2] * b[18] * b[35] - b[1] * b[22] * b[32] - b[2] * b[21] * b[32] + b[2] * b[19] * b[34] + b[0] * b[19] * b[36] - b[0] * b[22] * b[33] + b[0] * b[20] * b[35] - b[0] * b[23] * b[32] - b[0] * b[25] * b[30] + b[0] * b[17] * b[38] + b[0] * b[18] * b[37] - b[0] * b[24] * b[31] + b[1] * b[17] * b[37] - b[1] * b[23] * b[31] - b[1] * b[24] * b[30] - b[1] * b[21] * b[33] + b[1] * b[20] * b[34] + b[1] * b[19] * b[35] + b[1] * b[18] * b[36] + b[2] * b[17] * b[36] - b[2] * b[22] * b[31]);
		c[5] = (-b[14] * b[6] * b[36] - b[14] * b[7] * b[35] + b[14] * b[31] * b[11] - b[3] * b[23] * b[30] - b[3] * b[21] * b[32] + b[3] * b[18] * b[35] - b[3] * b[22] * b[31] + b[3] * b[17] * b[36] + b[3] * b[19] * b[34] + b[13] * b[32] * b[11] + b[13] * b[33] * b[10] - b[13] * b[5] * b[38] - b[15] * b[6] * b[35] - b[15] * b[7] * b[34] + b[15] * b[30] * b[11] + b[15] * b[31] * b[10] + b[16] * b[31] * b[9] - b[13] * b[6] * b[37] - b[13] * b[7] * b[36] + b[13] * b[31] * b[12] + b[14] * b[32] * b[10] + b[14] * b[33] * b[9] - b[14] * b[4] * b[38] - b[14] * b[5] * b[37] - b[16] * b[6] * b[34] + b[16] * b[30] * b[10] + b[16] * b[32] * b[8] - b[26] * b[20] * b[10] + b[26] * b[5] * b[25] + b[26] * b[6] * b[24] + b[26] * b[7] * b[23] + b[14] * b[30] * b[12] + b[15] * b[32] * b[9] + b[15] * b[33] * b[8] - b[15] * b[4] * b[37] - b[15] * b[5] * b[36] + b[29] * b[5] * b[22] + b[29] * b[6] * b[21] - b[26] * b[18] * b[12] - b[26] * b[19] * b[11] - b[27] * b[20] * b[9] + b[27] * b[4] * b[25] + b[27] * b[5] * b[24] + b[27] * b[6] * b[23] + b[27] * b[7] * b[22] - b[27] * b[17] * b[12] - b[27] * b[18] * b[11] - b[27] * b[19] * b[10] - b[28] * b[20] * b[8] - b[16] * b[4] * b[36] - b[16] * b[5] * b[35] - b[29] * b[17] * b[10] - b[29] * b[18] * b[9] - b[29] * b[19] * b[8] + b[28] * b[4] * b[24] + b[28] * b[5] * b[23] + b[28] * b[6] * b[22] + b[28] * b[7] * b[21] - b[28] * b[17] * b[11] - b[28] * b[18] * b[10] - b[28] * b[19] * b[9] + b[29] * b[4] * b[23] - b[2] * b[22] * b[32] - b[2] * b[21] * b[33] - b[1] * b[24] * b[31] + b[0] * b[18] * b[38] - b[0] * b[24] * b[32] + b[0] * b[19] * b[37] + b[0] * b[20] * b[36] - b[0] * b[25] * b[31] - b[0] * b[23] * b[33] + b[1] * b[19] * b[36] - b[1] * b[22] * b[33] + b[1] * b[20] * b[35] + b[2] * b[19] * b[35] - b[2] * b[24] * b[30] - b[2] * b[23] * b[31] + b[2] * b[20] * b[34] + b[2] * b[17] * b[37] - b[1] * b[25] * b[30] + b[1] * b[18] * b[37] + b[1] * b[17] * b[38] - b[1] * b[23] * b[32] + b[2] * b[18] * b[36]);
		c[4] = (-b[14] * b[6] * b[37] - b[14] * b[7] * b[36] + b[14] * b[31] * b[12] + b[3] * b[17] * b[37] - b[3] * b[23] * b[31] - b[3] * b[24] * b[30] - b[3] * b[21] * b[33] + b[3] * b[20] * b[34] + b[3] * b[19] * b[35] + b[3] * b[18] * b[36] - b[3] * b[22] * b[32] + b[13] * b[32] * b[12] + b[13] * b[33] * b[11] - b[15] * b[6] * b[36] - b[15] * b[7] * b[35] + b[15] * b[31] * b[11] + b[15] * b[30] * b[12] + b[16] * b[32] * b[9] + b[16] * b[33] * b[8] - b[13] * b[6] * b[38] - b[13] * b[7] * b[37] + b[14] * b[32] * b[11] + b[14] * b[33] * b[10] - b[14] * b[5] * b[38] - b[16] * b[6] * b[35] - b[16] * b[7] * b[34] + b[16] * b[30] * b[11] + b[16] * b[31] * b[10] - b[26] * b[19] * b[12] - b[26] * b[20] * b[11] + b[26] * b[6] * b[25] + b[26] * b[7] * b[24] + b[15] * b[32] * b[10] + b[15] * b[33] * b[9] - b[15] * b[4] * b[38] - b[15] * b[5] * b[37] + b[29] * b[5] * b[23] + b[29] * b[6] * b[22] + b[29] * b[7] * b[21] - b[27] * b[20] * b[10] + b[27] * b[5] * b[25] + b[27] * b[6] * b[24] + b[27] * b[7] * b[23] - b[27] * b[18] * b[12] - b[27] * b[19] * b[11] - b[28] * b[20] * b[9] - b[16] * b[4] * b[37] - b[16] * b[5] * b[36] + b[0] * b[19] * b[38] - b[0] * b[24] * b[33] + b[0] * b[20] * b[37] - b[29] * b[17] * b[11] - b[29] * b[18] * b[10] - b[29] * b[19] * b[9] + b[28] * b[4] * b[25] + b[28] * b[5] * b[24] + b[28] * b[6] * b[23] + b[28] * b[7] * b[22] - b[28] * b[17] * b[12] - b[28] * b[18] * b[11] - b[28] * b[19] * b[10] - b[29] * b[20] * b[8] + b[29] * b[4] * b[24] + b[2] * b[18] * b[37] - b[0] * b[25] * b[32] + b[1] * b[18] * b[38] - b[1] * b[24] * b[32] + b[1] * b[19] * b[37] + b[1] * b[20] * b[36] - b[1] * b[25] * b[31] + b[2] * b[17] * b[38] + b[2] * b[19] * b[36] - b[2] * b[24] * b[31] - b[2] * b[22] * b[33] - b[2] * b[23] * b[32] + b[2] * b[20] * b[35] - b[1] * b[23] * b[33] - b[2] * b[25] * b[30]);
		c[3] = (-b[14] * b[6] * b[38] - b[14] * b[7] * b[37] + b[3] * b[19] * b[36] - b[3] * b[22] * b[33] + b[3] * b[20] * b[35] - b[3] * b[23] * b[32] - b[3] * b[25] * b[30] + b[3] * b[17] * b[38] + b[3] * b[18] * b[37] - b[3] * b[24] * b[31] - b[15] * b[6] * b[37] - b[15] * b[7] * b[36] + b[15] * b[31] * b[12] + b[16] * b[32] * b[10] + b[16] * b[33] * b[9] + b[13] * b[33] * b[12] - b[13] * b[7] * b[38] + b[14] * b[32] * b[12] + b[14] * b[33] * b[11] - b[16] * b[6] * b[36] - b[16] * b[7] * b[35] + b[16] * b[31] * b[11] + b[16] * b[30] * b[12] + b[15] * b[32] * b[11] + b[15] * b[33] * b[10] - b[15] * b[5] * b[38] + b[29] * b[5] * b[24] + b[29] * b[6] * b[23] - b[26] * b[20] * b[12] + b[26] * b[7] * b[25] - b[27] * b[19] * b[12] - b[27] * b[20] * b[11] + b[27] * b[6] * b[25] + b[27] * b[7] * b[24] - b[28] * b[20] * b[10] - b[16] * b[4] * b[38] - b[16] * b[5] * b[37] + b[29] * b[7] * b[22] - b[29] * b[17] * b[12] - b[29] * b[18] * b[11] - b[29] * b[19] * b[10] + b[28] * b[5] * b[25] + b[28] * b[6] * b[24] + b[28] * b[7] * b[23] - b[28] * b[18] * b[12] - b[28] * b[19] * b[11] - b[29] * b[20] * b[9] + b[29] * b[4] * b[25] - b[2] * b[24] * b[32] + b[0] * b[20] * b[38] - b[0] * b[25] * b[33] + b[1] * b[19] * b[38] - b[1] * b[24] * b[33] + b[1] * b[20] * b[37] - b[2] * b[25] * b[31] + b[2] * b[20] * b[36] - b[1] * b[25] * b[32] + b[2] * b[19] * b[37] + b[2] * b[18] * b[38] - b[2] * b[23] * b[33]);
		c[2] = (b[3] * b[18] * b[38] - b[3] * b[24] * b[32] + b[3] * b[19] * b[37] + b[3] * b[20] * b[36] - b[3] * b[25] * b[31] - b[3] * b[23] * b[33] - b[15] * b[6] * b[38] - b[15] * b[7] * b[37] + b[16] * b[32] * b[11] + b[16] * b[33] * b[10] - b[16] * b[5] * b[38] - b[16] * b[6] * b[37] - b[16] * b[7] * b[36] + b[16] * b[31] * b[12] + b[14] * b[33] * b[12] - b[14] * b[7] * b[38] + b[15] * b[32] * b[12] + b[15] * b[33] * b[11] + b[29] * b[5] * b[25] + b[29] * b[6] * b[24] - b[27] * b[20] * b[12] + b[27] * b[7] * b[25] - b[28] * b[19] * b[12] - b[28] * b[20] * b[11] + b[29] * b[7] * b[23] - b[29] * b[18] * b[12] - b[29] * b[19] * b[11] + b[28] * b[6] * b[25] + b[28] * b[7] * b[24] - b[29] * b[20] * b[10] + b[2] * b[19] * b[38] - b[1] * b[25] * b[33] + b[2] * b[20] * b[37] - b[2] * b[24] * b[33] - b[2] * b[25] * b[32] + b[1] * b[20] * b[38]);
		c[1] = (b[29] * b[7] * b[24] - b[29] * b[20] * b[11] + b[2] * b[20] * b[38] - b[2] * b[25] * b[33] - b[28] * b[20] * b[12] + b[28] * b[7] * b[25] - b[29] * b[19] * b[12] - b[3] * b[24] * b[33] + b[15] * b[33] * b[12] + b[3] * b[19] * b[38] - b[16] * b[6] * b[38] + b[3] * b[20] * b[37] + b[16] * b[32] * b[12] + b[29] * b[6] * b[25] - b[16] * b[7] * b[37] - b[3] * b[25] * b[32] - b[15] * b[7] * b[38] + b[16] * b[33] * b[11]);
		c[0] = -b[29] * b[20] * b[12] + b[29] * b[7] * b[25] + b[16] * b[33] * b[12] - b[16] * b[7] * b[38] + b[3] * b[20] * b[38] - b[3] * b[25] * b[33];

		std::vector<std::complex<double> > roots;
		solvePoly(coeffs, roots);

		std::vector<double> xs, ys, zs;
		int count = 0;

		Mat ematrix(10 * 3, 3, CV_64F);
		double* e = ematrix.ptr<double>();
		for (int i = 0; i < roots.size(); i++)
		{
			if (fabs(roots[i].imag()) > 1e-10) continue;
			double z1 = roots[i].real();
			double z2 = z1 * z1;
			double z3 = z2 * z1;
			double z4 = z3 * z1;

			double bz[3][3];
			for (int j = 0; j < 3; j++)
			{
				const double * br = b + j * 13;
				bz[j][0] = br[0] * z3 + br[1] * z2 + br[2] * z1 + br[3];
				bz[j][1] = br[4] * z3 + br[5] * z2 + br[6] * z1 + br[7];
				bz[j][2] = br[8] * z4 + br[9] * z3 + br[10] * z2 + br[11] * z1 + br[12];
			}

			Mat Bz(3, 3, CV_64F, bz);
			cv::Mat xy1;
			SVD::solveZ(Bz, xy1);

			if (fabs(xy1.at<double>(2)) < 1e-10) continue;
			xs.push_back(xy1.at<double>(0) / xy1.at<double>(2));
			ys.push_back(xy1.at<double>(1) / xy1.at<double>(2));
			zs.push_back(z1);

			cv::Mat Evec = EE.col(0) * xs.back() + EE.col(1) * ys.back() + EE.col(2) * zs.back() + EE.col(3);
			Evec /= norm(Evec);

			memcpy(e + count * 9, Evec.data, 9 * sizeof(double));
			count++;
		}

		ematrix.rowRange(0, count * 3).copyTo(_model);
		return count;
	}

protected:
	virtual void getCoeffMat(double *e, double* A)
	{
		double ep2[36], ep3[36];
		for (int i = 0; i < 36; i++)
		{
			ep2[i] = e[i] * e[i];
			ep3[i] = ep2[i] * e[i];
		}

		A[0] = e[33] * e[28] * e[32] - e[33] * e[31] * e[29] + e[30] * e[34] * e[29] - e[30] * e[28] * e[35] - e[27] * e[32] * e[34] + e[27] * e[31] * e[35];
		A[146] = .5000000000*e[6] * ep2[8] - .5000000000*e[6] * ep2[5] + .5000000000*ep3[6] + .5000000000*e[6] * ep2[7] - .5000000000*e[6] * ep2[4] + e[0] * e[2] * e[8] + e[3] * e[4] * e[7] + e[3] * e[5] * e[8] + e[0] * e[1] * e[7] - .5000000000*e[6] * ep2[1] - .5000000000*e[6] * ep2[2] + .5000000000*ep2[0] * e[6] + .5000000000*ep2[3] * e[6];
		A[1] = e[30] * e[34] * e[2] + e[33] * e[1] * e[32] - e[3] * e[28] * e[35] + e[0] * e[31] * e[35] + e[3] * e[34] * e[29] - e[30] * e[1] * e[35] + e[27] * e[31] * e[8] - e[27] * e[32] * e[7] - e[30] * e[28] * e[8] - e[33] * e[31] * e[2] - e[0] * e[32] * e[34] + e[6] * e[28] * e[32] - e[33] * e[4] * e[29] + e[33] * e[28] * e[5] + e[30] * e[7] * e[29] + e[27] * e[4] * e[35] - e[27] * e[5] * e[34] - e[6] * e[31] * e[29];
		A[147] = e[9] * e[27] * e[15] + e[9] * e[29] * e[17] + e[9] * e[11] * e[35] + e[9] * e[28] * e[16] + e[9] * e[10] * e[34] + e[27] * e[11] * e[17] + e[27] * e[10] * e[16] + e[12] * e[30] * e[15] + e[12] * e[32] * e[17] + e[12] * e[14] * e[35] + e[12] * e[31] * e[16] + e[12] * e[13] * e[34] + e[30] * e[14] * e[17] + e[30] * e[13] * e[16] + e[15] * e[35] * e[17] + e[15] * e[34] * e[16] - 1.*e[15] * e[28] * e[10] - 1.*e[15] * e[31] * e[13] - 1.*e[15] * e[32] * e[14] - 1.*e[15] * e[29] * e[11] + .5000000000*ep2[9] * e[33] + .5000000000*e[33] * ep2[16] - .5000000000*e[33] * ep2[11] + .5000000000*e[33] * ep2[12] + 1.500000000*e[33] * ep2[15] + .5000000000*e[33] * ep2[17] - .5000000000*e[33] * ep2[10] - .5000000000*e[33] * ep2[14] - .5000000000*e[33] * ep2[13];
		A[2] = -e[33] * e[22] * e[29] - e[33] * e[31] * e[20] - e[27] * e[32] * e[25] + e[27] * e[22] * e[35] - e[27] * e[23] * e[34] + e[27] * e[31] * e[26] + e[33] * e[28] * e[23] - e[21] * e[28] * e[35] + e[30] * e[25] * e[29] + e[24] * e[28] * e[32] - e[24] * e[31] * e[29] + e[18] * e[31] * e[35] - e[30] * e[28] * e[26] - e[30] * e[19] * e[35] + e[21] * e[34] * e[29] + e[33] * e[19] * e[32] - e[18] * e[32] * e[34] + e[30] * e[34] * e[20];
		A[144] = e[18] * e[2] * e[17] + e[3] * e[21] * e[15] + e[3] * e[12] * e[24] + e[3] * e[23] * e[17] + e[3] * e[14] * e[26] + e[3] * e[22] * e[16] + e[3] * e[13] * e[25] + 3.*e[6] * e[24] * e[15] + e[6] * e[26] * e[17] + e[6] * e[25] * e[16] + e[0] * e[20] * e[17] + e[0] * e[11] * e[26] + e[0] * e[19] * e[16] + e[0] * e[10] * e[25] + e[15] * e[26] * e[8] - 1.*e[15] * e[20] * e[2] - 1.*e[15] * e[19] * e[1] - 1.*e[15] * e[22] * e[4] + e[15] * e[25] * e[7] - 1.*e[15] * e[23] * e[5] + e[12] * e[21] * e[6] + e[12] * e[22] * e[7] + e[12] * e[4] * e[25] + e[12] * e[23] * e[8] + e[12] * e[5] * e[26] - 1.*e[24] * e[11] * e[2] - 1.*e[24] * e[10] * e[1] - 1.*e[24] * e[13] * e[4] + e[24] * e[16] * e[7] - 1.*e[24] * e[14] * e[5] + e[24] * e[17] * e[8] + e[21] * e[13] * e[7] + e[21] * e[4] * e[16] + e[21] * e[14] * e[8] + e[21] * e[5] * e[17] - 1.*e[6] * e[23] * e[14] - 1.*e[6] * e[20] * e[11] - 1.*e[6] * e[19] * e[10] - 1.*e[6] * e[22] * e[13] + e[9] * e[18] * e[6] + e[9] * e[0] * e[24] + e[9] * e[19] * e[7] + e[9] * e[1] * e[25] + e[9] * e[20] * e[8] + e[9] * e[2] * e[26] + e[18] * e[0] * e[15] + e[18] * e[10] * e[7] + e[18] * e[1] * e[16] + e[18] * e[11] * e[8];
		A[3] = e[33] * e[10] * e[32] + e[33] * e[28] * e[14] - e[33] * e[13] * e[29] - e[33] * e[31] * e[11] + e[9] * e[31] * e[35] - e[9] * e[32] * e[34] + e[27] * e[13] * e[35] - e[27] * e[32] * e[16] + e[27] * e[31] * e[17] - e[27] * e[14] * e[34] + e[12] * e[34] * e[29] - e[12] * e[28] * e[35] + e[30] * e[34] * e[11] + e[30] * e[16] * e[29] - e[30] * e[10] * e[35] - e[30] * e[28] * e[17] + e[15] * e[28] * e[32] - e[15] * e[31] * e[29];
		A[145] = e[0] * e[27] * e[6] + e[0] * e[28] * e[7] + e[0] * e[1] * e[34] + e[0] * e[29] * e[8] + e[0] * e[2] * e[35] + e[6] * e[34] * e[7] - 1.*e[6] * e[32] * e[5] + e[6] * e[30] * e[3] + e[6] * e[35] * e[8] - 1.*e[6] * e[29] * e[2] - 1.*e[6] * e[28] * e[1] - 1.*e[6] * e[31] * e[4] + e[27] * e[1] * e[7] + e[27] * e[2] * e[8] + e[3] * e[31] * e[7] + e[3] * e[4] * e[34] + e[3] * e[32] * e[8] + e[3] * e[5] * e[35] + e[30] * e[4] * e[7] + e[30] * e[5] * e[8] + .5000000000*ep2[0] * e[33] + 1.500000000*e[33] * ep2[6] - .5000000000*e[33] * ep2[4] - .5000000000*e[33] * ep2[5] - .5000000000*e[33] * ep2[1] + .5000000000*e[33] * ep2[7] + .5000000000*e[33] * ep2[3] - .5000000000*e[33] * ep2[2] + .5000000000*e[33] * ep2[8];
		A[4] = -e[0] * e[23] * e[16] + e[9] * e[4] * e[26] + e[9] * e[22] * e[8] - e[9] * e[5] * e[25] - e[9] * e[23] * e[7] + e[18] * e[4] * e[17] + e[18] * e[13] * e[8] - e[18] * e[5] * e[16] - e[18] * e[14] * e[7] + e[3] * e[16] * e[20] + e[3] * e[25] * e[11] - e[3] * e[10] * e[26] - e[3] * e[19] * e[17] + e[12] * e[7] * e[20] + e[12] * e[25] * e[2] - e[12] * e[1] * e[26] - e[12] * e[19] * e[8] + e[21] * e[7] * e[11] + e[21] * e[16] * e[2] - e[21] * e[1] * e[17] - e[21] * e[10] * e[8] + e[6] * e[10] * e[23] + e[6] * e[19] * e[14] - e[6] * e[13] * e[20] - e[6] * e[22] * e[11] + e[15] * e[1] * e[23] + e[15] * e[19] * e[5] - e[15] * e[4] * e[20] - e[15] * e[22] * e[2] + e[24] * e[1] * e[14] + e[24] * e[10] * e[5] - e[24] * e[4] * e[11] - e[24] * e[13] * e[2] + e[0] * e[13] * e[26] + e[0] * e[22] * e[17] - e[0] * e[14] * e[25];
		A[150] = e[18] * e[19] * e[25] + .5000000000*ep3[24] - .5000000000*e[24] * ep2[23] + e[18] * e[20] * e[26] + e[21] * e[22] * e[25] + e[21] * e[23] * e[26] - .5000000000*e[24] * ep2[19] + .5000000000*ep2[21] * e[24] + .5000000000*e[24] * ep2[26] - .5000000000*e[24] * ep2[20] + .5000000000*ep2[18] * e[24] - .5000000000*e[24] * ep2[22] + .5000000000*e[24] * ep2[25];
		A[5] = -e[3] * e[1] * e[35] - e[0] * e[32] * e[7] + e[27] * e[4] * e[8] + e[33] * e[1] * e[5] - e[33] * e[4] * e[2] + e[0] * e[4] * e[35] + e[3] * e[34] * e[2] - e[30] * e[1] * e[8] + e[30] * e[7] * e[2] - e[6] * e[4] * e[29] + e[3] * e[7] * e[29] + e[6] * e[1] * e[32] - e[0] * e[5] * e[34] - e[3] * e[28] * e[8] + e[0] * e[31] * e[8] + e[6] * e[28] * e[5] - e[6] * e[31] * e[2] - e[27] * e[5] * e[7];
		A[151] = e[33] * e[16] * e[7] - 1.*e[33] * e[14] * e[5] + e[33] * e[17] * e[8] + e[30] * e[13] * e[7] + e[30] * e[4] * e[16] + e[30] * e[14] * e[8] + e[30] * e[5] * e[17] + e[6] * e[27] * e[9] - 1.*e[6] * e[28] * e[10] - 1.*e[6] * e[31] * e[13] - 1.*e[6] * e[32] * e[14] - 1.*e[6] * e[29] * e[11] + e[9] * e[28] * e[7] + e[9] * e[1] * e[34] + e[9] * e[29] * e[8] + e[9] * e[2] * e[35] + e[27] * e[10] * e[7] + e[27] * e[1] * e[16] + e[27] * e[11] * e[8] + e[27] * e[2] * e[17] + e[3] * e[30] * e[15] + e[3] * e[12] * e[33] + e[3] * e[32] * e[17] + e[3] * e[14] * e[35] + e[3] * e[31] * e[16] + e[3] * e[13] * e[34] + 3.*e[6] * e[33] * e[15] + e[6] * e[35] * e[17] + e[6] * e[34] * e[16] + e[0] * e[27] * e[15] + e[0] * e[9] * e[33] + e[0] * e[29] * e[17] + e[0] * e[11] * e[35] + e[0] * e[28] * e[16] + e[0] * e[10] * e[34] + e[15] * e[34] * e[7] - 1.*e[15] * e[32] * e[5] + e[15] * e[35] * e[8] - 1.*e[15] * e[29] * e[2] - 1.*e[15] * e[28] * e[1] - 1.*e[15] * e[31] * e[4] + e[12] * e[30] * e[6] + e[12] * e[31] * e[7] + e[12] * e[4] * e[34] + e[12] * e[32] * e[8] + e[12] * e[5] * e[35] - 1.*e[33] * e[11] * e[2] - 1.*e[33] * e[10] * e[1] - 1.*e[33] * e[13] * e[4];
		A[6] = e[6] * e[1] * e[5] - e[6] * e[4] * e[2] + e[3] * e[7] * e[2] + e[0] * e[4] * e[8] - e[0] * e[5] * e[7] - e[3] * e[1] * e[8];
		A[148] = .5000000000*ep3[15] + e[9] * e[10] * e[16] - .5000000000*e[15] * ep2[11] + e[9] * e[11] * e[17] + .5000000000*ep2[12] * e[15] + .5000000000*e[15] * ep2[16] + .5000000000*e[15] * ep2[17] - .5000000000*e[15] * ep2[13] + .5000000000*ep2[9] * e[15] + e[12] * e[14] * e[17] - .5000000000*e[15] * ep2[10] - .5000000000*e[15] * ep2[14] + e[12] * e[13] * e[16];
		A[7] = e[15] * e[28] * e[14] - e[15] * e[13] * e[29] - e[15] * e[31] * e[11] + e[33] * e[10] * e[14] - e[33] * e[13] * e[11] + e[9] * e[13] * e[35] - e[9] * e[32] * e[16] + e[9] * e[31] * e[17] - e[9] * e[14] * e[34] + e[27] * e[13] * e[17] - e[27] * e[14] * e[16] + e[12] * e[34] * e[11] + e[12] * e[16] * e[29] - e[12] * e[10] * e[35] - e[12] * e[28] * e[17] + e[30] * e[16] * e[11] - e[30] * e[10] * e[17] + e[15] * e[10] * e[32];
		A[149] = e[18] * e[27] * e[24] + e[18] * e[28] * e[25] + e[18] * e[19] * e[34] + e[18] * e[29] * e[26] + e[18] * e[20] * e[35] + e[27] * e[19] * e[25] + e[27] * e[20] * e[26] + e[21] * e[30] * e[24] + e[21] * e[31] * e[25] + e[21] * e[22] * e[34] + e[21] * e[32] * e[26] + e[21] * e[23] * e[35] + e[30] * e[22] * e[25] + e[30] * e[23] * e[26] + e[24] * e[34] * e[25] + e[24] * e[35] * e[26] - 1.*e[24] * e[29] * e[20] - 1.*e[24] * e[31] * e[22] - 1.*e[24] * e[32] * e[23] - 1.*e[24] * e[28] * e[19] + 1.500000000*e[33] * ep2[24] + .5000000000*e[33] * ep2[25] + .5000000000*e[33] * ep2[26] - .5000000000*e[33] * ep2[23] - .5000000000*e[33] * ep2[19] - .5000000000*e[33] * ep2[20] - .5000000000*e[33] * ep2[22] + .5000000000*ep2[18] * e[33] + .5000000000*ep2[21] * e[33];
		A[9] = e[21] * e[25] * e[29] - e[27] * e[23] * e[25] + e[24] * e[19] * e[32] - e[21] * e[28] * e[26] - e[21] * e[19] * e[35] + e[18] * e[31] * e[26] - e[30] * e[19] * e[26] - e[24] * e[31] * e[20] + e[24] * e[28] * e[23] + e[27] * e[22] * e[26] + e[30] * e[25] * e[20] - e[33] * e[22] * e[20] + e[33] * e[19] * e[23] + e[21] * e[34] * e[20] - e[18] * e[23] * e[34] - e[24] * e[22] * e[29] - e[18] * e[32] * e[25] + e[18] * e[22] * e[35];
		A[155] = e[12] * e[14] * e[8] + e[12] * e[5] * e[17] + e[15] * e[16] * e[7] + e[15] * e[17] * e[8] + e[0] * e[11] * e[17] + e[0] * e[9] * e[15] + e[0] * e[10] * e[16] + e[3] * e[14] * e[17] + e[3] * e[13] * e[16] + e[9] * e[10] * e[7] + e[9] * e[1] * e[16] + e[9] * e[11] * e[8] + e[9] * e[2] * e[17] - 1.*e[15] * e[11] * e[2] - 1.*e[15] * e[10] * e[1] - 1.*e[15] * e[13] * e[4] - 1.*e[15] * e[14] * e[5] + e[12] * e[3] * e[15] + e[12] * e[13] * e[7] + e[12] * e[4] * e[16] + .5000000000*ep2[12] * e[6] + 1.500000000*ep2[15] * e[6] + .5000000000*e[6] * ep2[17] + .5000000000*e[6] * ep2[16] + .5000000000*e[6] * ep2[9] - .5000000000*e[6] * ep2[11] - .5000000000*e[6] * ep2[10] - .5000000000*e[6] * ep2[14] - .5000000000*e[6] * ep2[13];
		A[8] = -e[9] * e[14] * e[16] - e[12] * e[10] * e[17] + e[9] * e[13] * e[17] - e[15] * e[13] * e[11] + e[15] * e[10] * e[14] + e[12] * e[16] * e[11];
		A[154] = e[21] * e[14] * e[17] + e[21] * e[13] * e[16] + e[15] * e[26] * e[17] + e[15] * e[25] * e[16] - 1.*e[15] * e[23] * e[14] - 1.*e[15] * e[20] * e[11] - 1.*e[15] * e[19] * e[10] - 1.*e[15] * e[22] * e[13] + e[9] * e[20] * e[17] + e[9] * e[11] * e[26] + e[9] * e[19] * e[16] + e[9] * e[10] * e[25] + .5000000000*ep2[12] * e[24] + 1.500000000*e[24] * ep2[15] + .5000000000*e[24] * ep2[17] + .5000000000*e[24] * ep2[16] + .5000000000*ep2[9] * e[24] - .5000000000*e[24] * ep2[11] - .5000000000*e[24] * ep2[10] - .5000000000*e[24] * ep2[14] - .5000000000*e[24] * ep2[13] + e[18] * e[11] * e[17] + e[18] * e[9] * e[15] + e[18] * e[10] * e[16] + e[12] * e[21] * e[15] + e[12] * e[23] * e[17] + e[12] * e[14] * e[26] + e[12] * e[22] * e[16] + e[12] * e[13] * e[25];
		A[11] = -e[9] * e[5] * e[34] + e[9] * e[31] * e[8] - e[9] * e[32] * e[7] + e[27] * e[4] * e[17] + e[27] * e[13] * e[8] - e[27] * e[5] * e[16] - e[27] * e[14] * e[7] + e[0] * e[13] * e[35] - e[0] * e[32] * e[16] + e[0] * e[31] * e[17] - e[0] * e[14] * e[34] + e[9] * e[4] * e[35] + e[6] * e[10] * e[32] + e[6] * e[28] * e[14] - e[6] * e[13] * e[29] - e[6] * e[31] * e[11] + e[15] * e[1] * e[32] + e[3] * e[34] * e[11] + e[3] * e[16] * e[29] - e[3] * e[10] * e[35] - e[3] * e[28] * e[17] - e[12] * e[1] * e[35] + e[12] * e[7] * e[29] + e[12] * e[34] * e[2] - e[12] * e[28] * e[8] + e[15] * e[28] * e[5] - e[15] * e[4] * e[29] - e[15] * e[31] * e[2] + e[33] * e[1] * e[14] + e[33] * e[10] * e[5] - e[33] * e[4] * e[11] - e[33] * e[13] * e[2] + e[30] * e[7] * e[11] + e[30] * e[16] * e[2] - e[30] * e[1] * e[17] - e[30] * e[10] * e[8];
		A[153] = e[21] * e[31] * e[7] + e[21] * e[4] * e[34] + e[21] * e[32] * e[8] + e[21] * e[5] * e[35] + e[30] * e[22] * e[7] + e[30] * e[4] * e[25] + e[30] * e[23] * e[8] + e[30] * e[5] * e[26] + 3.*e[24] * e[33] * e[6] + e[24] * e[34] * e[7] + e[24] * e[35] * e[8] + e[33] * e[25] * e[7] + e[33] * e[26] * e[8] + e[0] * e[27] * e[24] + e[0] * e[18] * e[33] + e[0] * e[28] * e[25] + e[0] * e[19] * e[34] + e[0] * e[29] * e[26] + e[0] * e[20] * e[35] + e[18] * e[27] * e[6] + e[18] * e[28] * e[7] + e[18] * e[1] * e[34] + e[18] * e[29] * e[8] + e[18] * e[2] * e[35] + e[27] * e[19] * e[7] + e[27] * e[1] * e[25] + e[27] * e[20] * e[8] + e[27] * e[2] * e[26] + e[3] * e[30] * e[24] + e[3] * e[21] * e[33] + e[3] * e[31] * e[25] + e[3] * e[22] * e[34] + e[3] * e[32] * e[26] + e[3] * e[23] * e[35] + e[6] * e[30] * e[21] - 1.*e[6] * e[29] * e[20] + e[6] * e[35] * e[26] - 1.*e[6] * e[31] * e[22] - 1.*e[6] * e[32] * e[23] - 1.*e[6] * e[28] * e[19] + e[6] * e[34] * e[25] - 1.*e[24] * e[32] * e[5] - 1.*e[24] * e[29] * e[2] - 1.*e[24] * e[28] * e[1] - 1.*e[24] * e[31] * e[4] - 1.*e[33] * e[20] * e[2] - 1.*e[33] * e[19] * e[1] - 1.*e[33] * e[22] * e[4] - 1.*e[33] * e[23] * e[5];
		A[10] = e[21] * e[25] * e[20] - e[21] * e[19] * e[26] + e[18] * e[22] * e[26] - e[18] * e[23] * e[25] - e[24] * e[22] * e[20] + e[24] * e[19] * e[23];
		A[152] = e[3] * e[4] * e[25] + e[3] * e[23] * e[8] + e[3] * e[5] * e[26] + e[21] * e[4] * e[7] + e[21] * e[5] * e[8] + e[6] * e[25] * e[7] + e[6] * e[26] * e[8] + e[0] * e[19] * e[7] + e[0] * e[1] * e[25] + e[0] * e[20] * e[8] + e[0] * e[2] * e[26] - 1.*e[6] * e[20] * e[2] - 1.*e[6] * e[19] * e[1] - 1.*e[6] * e[22] * e[4] - 1.*e[6] * e[23] * e[5] + e[18] * e[1] * e[7] + e[18] * e[0] * e[6] + e[18] * e[2] * e[8] + e[3] * e[21] * e[6] + e[3] * e[22] * e[7] - .5000000000*e[24] * ep2[4] + .5000000000*e[24] * ep2[0] + 1.500000000*e[24] * ep2[6] - .5000000000*e[24] * ep2[5] - .5000000000*e[24] * ep2[1] + .5000000000*e[24] * ep2[7] + .5000000000*e[24] * ep2[3] - .5000000000*e[24] * ep2[2] + .5000000000*e[24] * ep2[8];
		A[13] = e[6] * e[28] * e[23] - e[6] * e[22] * e[29] - e[6] * e[31] * e[20] - e[3] * e[19] * e[35] + e[3] * e[34] * e[20] + e[3] * e[25] * e[29] - e[21] * e[1] * e[35] + e[21] * e[7] * e[29] + e[21] * e[34] * e[2] + e[24] * e[1] * e[32] + e[24] * e[28] * e[5] - e[24] * e[4] * e[29] - e[24] * e[31] * e[2] + e[33] * e[1] * e[23] + e[33] * e[19] * e[5] - e[33] * e[4] * e[20] - e[33] * e[22] * e[2] - e[21] * e[28] * e[8] + e[30] * e[7] * e[20] + e[30] * e[25] * e[2] - e[30] * e[1] * e[26] + e[18] * e[4] * e[35] - e[18] * e[5] * e[34] + e[18] * e[31] * e[8] - e[18] * e[32] * e[7] + e[27] * e[4] * e[26] + e[27] * e[22] * e[8] - e[27] * e[5] * e[25] - e[27] * e[23] * e[7] - e[3] * e[28] * e[26] - e[0] * e[32] * e[25] + e[0] * e[22] * e[35] - e[0] * e[23] * e[34] + e[0] * e[31] * e[26] - e[30] * e[19] * e[8] + e[6] * e[19] * e[32];
		A[159] = .5000000000*ep2[18] * e[6] + .5000000000*ep2[21] * e[6] + 1.500000000*ep2[24] * e[6] + .5000000000*e[6] * ep2[26] - .5000000000*e[6] * ep2[23] - .5000000000*e[6] * ep2[19] - .5000000000*e[6] * ep2[20] - .5000000000*e[6] * ep2[22] + .5000000000*e[6] * ep2[25] + e[21] * e[3] * e[24] + e[18] * e[20] * e[8] + e[21] * e[4] * e[25] + e[18] * e[19] * e[7] + e[18] * e[1] * e[25] + e[21] * e[22] * e[7] + e[21] * e[23] * e[8] + e[18] * e[0] * e[24] + e[18] * e[2] * e[26] + e[21] * e[5] * e[26] + e[24] * e[26] * e[8] - 1.*e[24] * e[20] * e[2] - 1.*e[24] * e[19] * e[1] - 1.*e[24] * e[22] * e[4] + e[24] * e[25] * e[7] - 1.*e[24] * e[23] * e[5] + e[0] * e[19] * e[25] + e[0] * e[20] * e[26] + e[3] * e[22] * e[25] + e[3] * e[23] * e[26];
		A[12] = e[18] * e[4] * e[8] + e[3] * e[7] * e[20] + e[3] * e[25] * e[2] - e[3] * e[1] * e[26] - e[18] * e[5] * e[7] + e[6] * e[1] * e[23] + e[6] * e[19] * e[5] - e[6] * e[4] * e[20] - e[6] * e[22] * e[2] + e[21] * e[7] * e[2] - e[21] * e[1] * e[8] + e[24] * e[1] * e[5] - e[24] * e[4] * e[2] - e[3] * e[19] * e[8] + e[0] * e[4] * e[26] + e[0] * e[22] * e[8] - e[0] * e[5] * e[25] - e[0] * e[23] * e[7];
		A[158] = e[9] * e[1] * e[7] + e[9] * e[0] * e[6] + e[9] * e[2] * e[8] + e[3] * e[12] * e[6] + e[3] * e[13] * e[7] + e[3] * e[4] * e[16] + e[3] * e[14] * e[8] + e[3] * e[5] * e[17] + e[12] * e[4] * e[7] + e[12] * e[5] * e[8] + e[6] * e[16] * e[7] + e[6] * e[17] * e[8] - 1.*e[6] * e[11] * e[2] - 1.*e[6] * e[10] * e[1] - 1.*e[6] * e[13] * e[4] - 1.*e[6] * e[14] * e[5] + e[0] * e[10] * e[7] + e[0] * e[1] * e[16] + e[0] * e[11] * e[8] + e[0] * e[2] * e[17] + .5000000000*ep2[3] * e[15] + 1.500000000*e[15] * ep2[6] + .5000000000*e[15] * ep2[7] + .5000000000*e[15] * ep2[8] + .5000000000*ep2[0] * e[15] - .5000000000*e[15] * ep2[4] - .5000000000*e[15] * ep2[5] - .5000000000*e[15] * ep2[1] - .5000000000*e[15] * ep2[2];
		A[15] = -e[15] * e[13] * e[2] - e[6] * e[13] * e[11] - e[15] * e[4] * e[11] + e[12] * e[16] * e[2] - e[3] * e[10] * e[17] + e[3] * e[16] * e[11] + e[0] * e[13] * e[17] - e[0] * e[14] * e[16] + e[15] * e[1] * e[14] - e[12] * e[10] * e[8] + e[9] * e[4] * e[17] + e[9] * e[13] * e[8] - e[9] * e[5] * e[16] - e[9] * e[14] * e[7] + e[15] * e[10] * e[5] + e[12] * e[7] * e[11] + e[6] * e[10] * e[14] - e[12] * e[1] * e[17];
		A[157] = e[12] * e[30] * e[24] + e[12] * e[21] * e[33] + e[12] * e[31] * e[25] + e[12] * e[22] * e[34] + e[12] * e[32] * e[26] + e[12] * e[23] * e[35] + e[9] * e[27] * e[24] + e[9] * e[18] * e[33] + e[9] * e[28] * e[25] + e[9] * e[19] * e[34] + e[9] * e[29] * e[26] + e[9] * e[20] * e[35] + e[21] * e[30] * e[15] + e[21] * e[32] * e[17] + e[21] * e[14] * e[35] + e[21] * e[31] * e[16] + e[21] * e[13] * e[34] + e[30] * e[23] * e[17] + e[30] * e[14] * e[26] + e[30] * e[22] * e[16] + e[30] * e[13] * e[25] + e[15] * e[27] * e[18] + 3.*e[15] * e[33] * e[24] - 1.*e[15] * e[29] * e[20] + e[15] * e[35] * e[26] - 1.*e[15] * e[31] * e[22] - 1.*e[15] * e[32] * e[23] - 1.*e[15] * e[28] * e[19] + e[15] * e[34] * e[25] + e[18] * e[29] * e[17] + e[18] * e[11] * e[35] + e[18] * e[28] * e[16] + e[18] * e[10] * e[34] + e[27] * e[20] * e[17] + e[27] * e[11] * e[26] + e[27] * e[19] * e[16] + e[27] * e[10] * e[25] - 1.*e[24] * e[28] * e[10] - 1.*e[24] * e[31] * e[13] - 1.*e[24] * e[32] * e[14] + e[24] * e[34] * e[16] + e[24] * e[35] * e[17] - 1.*e[24] * e[29] * e[11] - 1.*e[33] * e[23] * e[14] + e[33] * e[25] * e[16] + e[33] * e[26] * e[17] - 1.*e[33] * e[20] * e[11] - 1.*e[33] * e[19] * e[10] - 1.*e[33] * e[22] * e[13];
		A[14] = e[18] * e[13] * e[17] + e[9] * e[13] * e[26] + e[9] * e[22] * e[17] - e[9] * e[14] * e[25] - e[18] * e[14] * e[16] - e[15] * e[13] * e[20] - e[15] * e[22] * e[11] + e[12] * e[16] * e[20] + e[12] * e[25] * e[11] - e[12] * e[10] * e[26] - e[12] * e[19] * e[17] + e[21] * e[16] * e[11] - e[21] * e[10] * e[17] - e[9] * e[23] * e[16] + e[24] * e[10] * e[14] - e[24] * e[13] * e[11] + e[15] * e[10] * e[23] + e[15] * e[19] * e[14];
		A[156] = e[21] * e[12] * e[24] + e[21] * e[23] * e[17] + e[21] * e[14] * e[26] + e[21] * e[22] * e[16] + e[21] * e[13] * e[25] + e[24] * e[26] * e[17] + e[24] * e[25] * e[16] + e[9] * e[19] * e[25] + e[9] * e[18] * e[24] + e[9] * e[20] * e[26] + e[12] * e[22] * e[25] + e[12] * e[23] * e[26] + e[18] * e[20] * e[17] + e[18] * e[11] * e[26] + e[18] * e[19] * e[16] + e[18] * e[10] * e[25] - 1.*e[24] * e[23] * e[14] - 1.*e[24] * e[20] * e[11] - 1.*e[24] * e[19] * e[10] - 1.*e[24] * e[22] * e[13] + .5000000000*ep2[21] * e[15] + 1.500000000*ep2[24] * e[15] + .5000000000*e[15] * ep2[25] + .5000000000*e[15] * ep2[26] + .5000000000*e[15] * ep2[18] - .5000000000*e[15] * ep2[23] - .5000000000*e[15] * ep2[19] - .5000000000*e[15] * ep2[20] - .5000000000*e[15] * ep2[22];
		A[18] = e[6] * e[1] * e[14] + e[15] * e[1] * e[5] - e[0] * e[5] * e[16] - e[0] * e[14] * e[7] + e[0] * e[13] * e[8] - e[15] * e[4] * e[2] + e[12] * e[7] * e[2] + e[6] * e[10] * e[5] + e[3] * e[7] * e[11] - e[6] * e[4] * e[11] + e[3] * e[16] * e[2] - e[6] * e[13] * e[2] - e[3] * e[1] * e[17] - e[9] * e[5] * e[7] - e[3] * e[10] * e[8] - e[12] * e[1] * e[8] + e[0] * e[4] * e[17] + e[9] * e[4] * e[8];
		A[128] = -.5000000000*e[14] * ep2[16] - .5000000000*e[14] * ep2[10] - .5000000000*e[14] * ep2[9] + e[11] * e[9] * e[12] + .5000000000*ep3[14] + e[17] * e[13] * e[16] + .5000000000*e[14] * ep2[12] + e[11] * e[10] * e[13] - .5000000000*e[14] * ep2[15] + .5000000000*e[14] * ep2[17] + e[17] * e[12] * e[15] + .5000000000*ep2[11] * e[14] + .5000000000*e[14] * ep2[13];
		A[19] = -e[21] * e[19] * e[8] + e[18] * e[4] * e[26] - e[18] * e[5] * e[25] - e[18] * e[23] * e[7] + e[21] * e[25] * e[2] - e[21] * e[1] * e[26] + e[6] * e[19] * e[23] + e[18] * e[22] * e[8] - e[0] * e[23] * e[25] - e[6] * e[22] * e[20] + e[24] * e[1] * e[23] + e[24] * e[19] * e[5] - e[24] * e[4] * e[20] - e[24] * e[22] * e[2] + e[3] * e[25] * e[20] - e[3] * e[19] * e[26] + e[0] * e[22] * e[26] + e[21] * e[7] * e[20];
		A[129] = .5000000000*ep2[20] * e[32] + 1.500000000*e[32] * ep2[23] + .5000000000*e[32] * ep2[22] + .5000000000*e[32] * ep2[21] + .5000000000*e[32] * ep2[26] - .5000000000*e[32] * ep2[18] - .5000000000*e[32] * ep2[19] - .5000000000*e[32] * ep2[24] - .5000000000*e[32] * ep2[25] + e[20] * e[27] * e[21] + e[20] * e[18] * e[30] + e[20] * e[28] * e[22] + e[20] * e[19] * e[31] + e[20] * e[29] * e[23] + e[29] * e[19] * e[22] + e[29] * e[18] * e[21] + e[23] * e[30] * e[21] + e[23] * e[31] * e[22] + e[26] * e[30] * e[24] + e[26] * e[21] * e[33] + e[26] * e[31] * e[25] + e[26] * e[22] * e[34] + e[26] * e[23] * e[35] + e[35] * e[22] * e[25] + e[35] * e[21] * e[24] - 1.*e[23] * e[27] * e[18] - 1.*e[23] * e[33] * e[24] - 1.*e[23] * e[28] * e[19] - 1.*e[23] * e[34] * e[25];
		A[16] = -e[9] * e[23] * e[25] - e[21] * e[10] * e[26] - e[21] * e[19] * e[17] - e[18] * e[23] * e[16] + e[18] * e[13] * e[26] + e[12] * e[25] * e[20] - e[12] * e[19] * e[26] - e[15] * e[22] * e[20] + e[21] * e[16] * e[20] + e[21] * e[25] * e[11] + e[24] * e[10] * e[23] + e[24] * e[19] * e[14] - e[24] * e[13] * e[20] - e[24] * e[22] * e[11] + e[18] * e[22] * e[17] - e[18] * e[14] * e[25] + e[9] * e[22] * e[26] + e[15] * e[19] * e[23];
		A[130] = .5000000000*e[23] * ep2[21] + e[20] * e[19] * e[22] + e[20] * e[18] * e[21] + .5000000000*ep3[23] + e[26] * e[22] * e[25] + .5000000000*e[23] * ep2[26] - .5000000000*e[23] * ep2[18] + .5000000000*e[23] * ep2[22] - .5000000000*e[23] * ep2[19] + e[26] * e[21] * e[24] + .5000000000*ep2[20] * e[23] - .5000000000*e[23] * ep2[24] - .5000000000*e[23] * ep2[25];
		A[17] = e[18] * e[13] * e[35] - e[18] * e[32] * e[16] + e[18] * e[31] * e[17] - e[18] * e[14] * e[34] + e[27] * e[13] * e[26] + e[27] * e[22] * e[17] - e[27] * e[14] * e[25] - e[27] * e[23] * e[16] - e[9] * e[32] * e[25] + e[9] * e[22] * e[35] - e[9] * e[23] * e[34] + e[9] * e[31] * e[26] + e[15] * e[19] * e[32] + e[15] * e[28] * e[23] - e[15] * e[22] * e[29] - e[15] * e[31] * e[20] + e[24] * e[10] * e[32] + e[24] * e[28] * e[14] - e[24] * e[13] * e[29] - e[24] * e[31] * e[11] + e[33] * e[10] * e[23] + e[33] * e[19] * e[14] - e[33] * e[13] * e[20] - e[33] * e[22] * e[11] + e[21] * e[16] * e[29] - e[21] * e[10] * e[35] - e[21] * e[28] * e[17] + e[30] * e[16] * e[20] + e[30] * e[25] * e[11] - e[30] * e[10] * e[26] - e[30] * e[19] * e[17] - e[12] * e[28] * e[26] - e[12] * e[19] * e[35] + e[12] * e[34] * e[20] + e[12] * e[25] * e[29] + e[21] * e[34] * e[11];
		A[131] = -1.*e[32] * e[10] * e[1] + e[32] * e[13] * e[4] - 1.*e[32] * e[16] * e[7] - 1.*e[32] * e[15] * e[6] - 1.*e[32] * e[9] * e[0] + e[32] * e[12] * e[3] + e[17] * e[30] * e[6] + e[17] * e[3] * e[33] + e[17] * e[31] * e[7] + e[17] * e[4] * e[34] + e[17] * e[5] * e[35] - 1.*e[5] * e[27] * e[9] - 1.*e[5] * e[28] * e[10] - 1.*e[5] * e[33] * e[15] - 1.*e[5] * e[34] * e[16] + e[5] * e[29] * e[11] + e[35] * e[12] * e[6] + e[35] * e[3] * e[15] + e[35] * e[13] * e[7] + e[35] * e[4] * e[16] + e[11] * e[27] * e[3] + e[11] * e[0] * e[30] + e[11] * e[28] * e[4] + e[11] * e[1] * e[31] + e[29] * e[9] * e[3] + e[29] * e[0] * e[12] + e[29] * e[10] * e[4] + e[29] * e[1] * e[13] + e[5] * e[30] * e[12] + 3.*e[5] * e[32] * e[14] + e[5] * e[31] * e[13] + e[8] * e[30] * e[15] + e[8] * e[12] * e[33] + e[8] * e[32] * e[17] + e[8] * e[14] * e[35] + e[8] * e[31] * e[16] + e[8] * e[13] * e[34] + e[2] * e[27] * e[12] + e[2] * e[9] * e[30] + e[2] * e[29] * e[14] + e[2] * e[11] * e[32] + e[2] * e[28] * e[13] + e[2] * e[10] * e[31] - 1.*e[14] * e[27] * e[0] - 1.*e[14] * e[34] * e[7] - 1.*e[14] * e[33] * e[6] + e[14] * e[30] * e[3] - 1.*e[14] * e[28] * e[1] + e[14] * e[31] * e[4];
		A[22] = .5000000000*e[18] * ep2[29] + .5000000000*e[18] * ep2[28] + .5000000000*e[18] * ep2[30] + .5000000000*e[18] * ep2[33] - .5000000000*e[18] * ep2[32] - .5000000000*e[18] * ep2[31] - .5000000000*e[18] * ep2[34] - .5000000000*e[18] * ep2[35] + 1.500000000*e[18] * ep2[27] + e[27] * e[28] * e[19] + e[27] * e[29] * e[20] + e[21] * e[27] * e[30] + e[21] * e[29] * e[32] + e[21] * e[28] * e[31] + e[30] * e[28] * e[22] + e[30] * e[19] * e[31] + e[30] * e[29] * e[23] + e[30] * e[20] * e[32] + e[24] * e[27] * e[33] + e[24] * e[29] * e[35] + e[24] * e[28] * e[34] + e[33] * e[28] * e[25] + e[33] * e[19] * e[34] + e[33] * e[29] * e[26] + e[33] * e[20] * e[35] - 1.*e[27] * e[35] * e[26] - 1.*e[27] * e[31] * e[22] - 1.*e[27] * e[32] * e[23] - 1.*e[27] * e[34] * e[25];
		A[132] = e[20] * e[1] * e[4] + e[20] * e[0] * e[3] + e[20] * e[2] * e[5] + e[5] * e[21] * e[3] + e[5] * e[22] * e[4] + e[8] * e[21] * e[6] + e[8] * e[3] * e[24] + e[8] * e[22] * e[7] + e[8] * e[4] * e[25] + e[8] * e[5] * e[26] + e[26] * e[4] * e[7] + e[26] * e[3] * e[6] + e[2] * e[18] * e[3] + e[2] * e[0] * e[21] + e[2] * e[19] * e[4] + e[2] * e[1] * e[22] - 1.*e[5] * e[19] * e[1] - 1.*e[5] * e[18] * e[0] - 1.*e[5] * e[25] * e[7] - 1.*e[5] * e[24] * e[6] + .5000000000*e[23] * ep2[4] - .5000000000*e[23] * ep2[0] - .5000000000*e[23] * ep2[6] + 1.500000000*e[23] * ep2[5] - .5000000000*e[23] * ep2[1] - .5000000000*e[23] * ep2[7] + .5000000000*e[23] * ep2[3] + .5000000000*e[23] * ep2[2] + .5000000000*e[23] * ep2[8];
		A[23] = 1.500000000*e[9] * ep2[27] + .5000000000*e[9] * ep2[29] + .5000000000*e[9] * ep2[28] - .5000000000*e[9] * ep2[32] - .5000000000*e[9] * ep2[31] + .5000000000*e[9] * ep2[33] + .5000000000*e[9] * ep2[30] - .5000000000*e[9] * ep2[34] - .5000000000*e[9] * ep2[35] + e[33] * e[27] * e[15] + e[33] * e[29] * e[17] + e[33] * e[11] * e[35] + e[33] * e[28] * e[16] + e[33] * e[10] * e[34] + e[27] * e[29] * e[11] + e[27] * e[28] * e[10] + e[27] * e[30] * e[12] - 1.*e[27] * e[31] * e[13] - 1.*e[27] * e[32] * e[14] - 1.*e[27] * e[34] * e[16] - 1.*e[27] * e[35] * e[17] + e[30] * e[29] * e[14] + e[30] * e[11] * e[32] + e[30] * e[28] * e[13] + e[30] * e[10] * e[31] + e[12] * e[29] * e[32] + e[12] * e[28] * e[31] + e[15] * e[29] * e[35] + e[15] * e[28] * e[34];
		A[133] = -1.*e[32] * e[24] * e[6] + e[8] * e[30] * e[24] + e[8] * e[21] * e[33] + e[8] * e[31] * e[25] + e[8] * e[22] * e[34] + e[26] * e[30] * e[6] + e[26] * e[3] * e[33] + e[26] * e[31] * e[7] + e[26] * e[4] * e[34] + e[26] * e[32] * e[8] + e[26] * e[5] * e[35] + e[35] * e[21] * e[6] + e[35] * e[3] * e[24] + e[35] * e[22] * e[7] + e[35] * e[4] * e[25] + e[35] * e[23] * e[8] + e[2] * e[27] * e[21] + e[2] * e[18] * e[30] + e[2] * e[28] * e[22] + e[2] * e[19] * e[31] + e[2] * e[29] * e[23] + e[2] * e[20] * e[32] + e[20] * e[27] * e[3] + e[20] * e[0] * e[30] + e[20] * e[28] * e[4] + e[20] * e[1] * e[31] + e[20] * e[29] * e[5] + e[29] * e[18] * e[3] + e[29] * e[0] * e[21] + e[29] * e[19] * e[4] + e[29] * e[1] * e[22] + e[5] * e[30] * e[21] + e[5] * e[31] * e[22] + 3.*e[5] * e[32] * e[23] - 1.*e[5] * e[27] * e[18] - 1.*e[5] * e[33] * e[24] - 1.*e[5] * e[28] * e[19] - 1.*e[5] * e[34] * e[25] - 1.*e[23] * e[27] * e[0] - 1.*e[23] * e[34] * e[7] - 1.*e[23] * e[33] * e[6] + e[23] * e[30] * e[3] - 1.*e[23] * e[28] * e[1] + e[23] * e[31] * e[4] + e[32] * e[21] * e[3] - 1.*e[32] * e[19] * e[1] + e[32] * e[22] * e[4] - 1.*e[32] * e[18] * e[0] - 1.*e[32] * e[25] * e[7];
		A[20] = .5000000000*e[27] * ep2[33] - .5000000000*e[27] * ep2[32] - .5000000000*e[27] * ep2[31] - .5000000000*e[27] * ep2[34] - .5000000000*e[27] * ep2[35] + e[33] * e[29] * e[35] + .5000000000*e[27] * ep2[29] + e[30] * e[29] * e[32] + e[30] * e[28] * e[31] + e[33] * e[28] * e[34] + .5000000000*e[27] * ep2[28] + .5000000000*e[27] * ep2[30] + .5000000000*ep3[27];
		A[134] = e[14] * e[21] * e[12] + e[14] * e[22] * e[13] + e[17] * e[21] * e[15] + e[17] * e[12] * e[24] + e[17] * e[14] * e[26] + e[17] * e[22] * e[16] + e[17] * e[13] * e[25] + e[26] * e[12] * e[15] + e[26] * e[13] * e[16] - 1.*e[14] * e[24] * e[15] - 1.*e[14] * e[25] * e[16] - 1.*e[14] * e[18] * e[9] - 1.*e[14] * e[19] * e[10] + e[11] * e[18] * e[12] + e[11] * e[9] * e[21] + e[11] * e[19] * e[13] + e[11] * e[10] * e[22] + e[20] * e[11] * e[14] + e[20] * e[9] * e[12] + e[20] * e[10] * e[13] + 1.500000000*e[23] * ep2[14] + .5000000000*e[23] * ep2[12] + .5000000000*e[23] * ep2[13] + .5000000000*e[23] * ep2[17] + .5000000000*ep2[11] * e[23] - .5000000000*e[23] * ep2[16] - .5000000000*e[23] * ep2[9] - .5000000000*e[23] * ep2[15] - .5000000000*e[23] * ep2[10];
		A[21] = 1.500000000*e[0] * ep2[27] + .5000000000*e[0] * ep2[29] + .5000000000*e[0] * ep2[28] + .5000000000*e[0] * ep2[30] - .5000000000*e[0] * ep2[32] - .5000000000*e[0] * ep2[31] + .5000000000*e[0] * ep2[33] - .5000000000*e[0] * ep2[34] - .5000000000*e[0] * ep2[35] - 1.*e[27] * e[31] * e[4] + e[3] * e[27] * e[30] + e[3] * e[29] * e[32] + e[3] * e[28] * e[31] + e[30] * e[28] * e[4] + e[30] * e[1] * e[31] + e[30] * e[29] * e[5] + e[30] * e[2] * e[32] + e[6] * e[27] * e[33] + e[6] * e[29] * e[35] + e[6] * e[28] * e[34] + e[27] * e[28] * e[1] + e[27] * e[29] * e[2] + e[33] * e[28] * e[7] + e[33] * e[1] * e[34] + e[33] * e[29] * e[8] + e[33] * e[2] * e[35] - 1.*e[27] * e[34] * e[7] - 1.*e[27] * e[32] * e[5] - 1.*e[27] * e[35] * e[8];
		A[135] = e[14] * e[12] * e[3] + e[14] * e[13] * e[4] + e[17] * e[12] * e[6] + e[17] * e[3] * e[15] + e[17] * e[13] * e[7] + e[17] * e[4] * e[16] + e[17] * e[14] * e[8] + e[8] * e[12] * e[15] + e[8] * e[13] * e[16] + e[2] * e[11] * e[14] + e[2] * e[9] * e[12] + e[2] * e[10] * e[13] + e[11] * e[9] * e[3] + e[11] * e[0] * e[12] + e[11] * e[10] * e[4] + e[11] * e[1] * e[13] - 1.*e[14] * e[10] * e[1] - 1.*e[14] * e[16] * e[7] - 1.*e[14] * e[15] * e[6] - 1.*e[14] * e[9] * e[0] - .5000000000*e[5] * ep2[16] - .5000000000*e[5] * ep2[9] + .5000000000*e[5] * ep2[11] + .5000000000*e[5] * ep2[12] - .5000000000*e[5] * ep2[15] - .5000000000*e[5] * ep2[10] + .5000000000*e[5] * ep2[13] + 1.500000000*ep2[14] * e[5] + .5000000000*e[5] * ep2[17];
		A[27] = 1.500000000*e[27] * ep2[9] - .5000000000*e[27] * ep2[16] + .5000000000*e[27] * ep2[11] + .5000000000*e[27] * ep2[12] + .5000000000*e[27] * ep2[15] - .5000000000*e[27] * ep2[17] + .5000000000*e[27] * ep2[10] - .5000000000*e[27] * ep2[14] - .5000000000*e[27] * ep2[13] + e[12] * e[10] * e[31] + e[30] * e[11] * e[14] + e[30] * e[10] * e[13] + e[15] * e[9] * e[33] + e[15] * e[29] * e[17] + e[15] * e[11] * e[35] + e[15] * e[28] * e[16] + e[15] * e[10] * e[34] + e[33] * e[11] * e[17] + e[33] * e[10] * e[16] - 1.*e[9] * e[31] * e[13] - 1.*e[9] * e[32] * e[14] - 1.*e[9] * e[34] * e[16] - 1.*e[9] * e[35] * e[17] + e[9] * e[29] * e[11] + e[9] * e[28] * e[10] + e[12] * e[9] * e[30] + e[12] * e[29] * e[14] + e[12] * e[11] * e[32] + e[12] * e[28] * e[13];
		A[137] = e[29] * e[18] * e[12] + e[29] * e[9] * e[21] + e[29] * e[19] * e[13] + e[29] * e[10] * e[22] + e[17] * e[30] * e[24] + e[17] * e[21] * e[33] + e[17] * e[31] * e[25] + e[17] * e[22] * e[34] + e[17] * e[32] * e[26] + e[17] * e[23] * e[35] - 1.*e[23] * e[27] * e[9] - 1.*e[23] * e[28] * e[10] - 1.*e[23] * e[33] * e[15] - 1.*e[23] * e[34] * e[16] - 1.*e[32] * e[24] * e[15] - 1.*e[32] * e[25] * e[16] - 1.*e[32] * e[18] * e[9] - 1.*e[32] * e[19] * e[10] + e[26] * e[30] * e[15] + e[26] * e[12] * e[33] + e[26] * e[31] * e[16] + e[26] * e[13] * e[34] + e[35] * e[21] * e[15] + e[35] * e[12] * e[24] + e[35] * e[22] * e[16] + e[35] * e[13] * e[25] + e[14] * e[30] * e[21] + e[14] * e[31] * e[22] + 3.*e[14] * e[32] * e[23] + e[11] * e[27] * e[21] + e[11] * e[18] * e[30] + e[11] * e[28] * e[22] + e[11] * e[19] * e[31] + e[11] * e[29] * e[23] + e[11] * e[20] * e[32] + e[23] * e[30] * e[12] + e[23] * e[31] * e[13] + e[32] * e[21] * e[12] + e[32] * e[22] * e[13] - 1.*e[14] * e[27] * e[18] - 1.*e[14] * e[33] * e[24] + e[14] * e[29] * e[20] + e[14] * e[35] * e[26] - 1.*e[14] * e[28] * e[19] - 1.*e[14] * e[34] * e[25] + e[20] * e[27] * e[12] + e[20] * e[9] * e[30] + e[20] * e[28] * e[13] + e[20] * e[10] * e[31];
		A[26] = .5000000000*e[0] * ep2[1] + .5000000000*e[0] * ep2[2] + e[6] * e[2] * e[8] + e[6] * e[1] * e[7] + .5000000000*e[0] * ep2[3] + e[3] * e[1] * e[4] + .5000000000*e[0] * ep2[6] + e[3] * e[2] * e[5] - .5000000000*e[0] * ep2[5] - .5000000000*e[0] * ep2[8] + .5000000000*ep3[0] - .5000000000*e[0] * ep2[7] - .5000000000*e[0] * ep2[4];
		A[136] = 1.500000000*ep2[23] * e[14] + .5000000000*e[14] * ep2[26] - .5000000000*e[14] * ep2[18] - .5000000000*e[14] * ep2[19] + .5000000000*e[14] * ep2[20] + .5000000000*e[14] * ep2[22] - .5000000000*e[14] * ep2[24] + .5000000000*e[14] * ep2[21] - .5000000000*e[14] * ep2[25] + e[23] * e[21] * e[12] + e[23] * e[22] * e[13] + e[26] * e[21] * e[15] + e[26] * e[12] * e[24] + e[26] * e[23] * e[17] + e[26] * e[22] * e[16] + e[26] * e[13] * e[25] + e[17] * e[22] * e[25] + e[17] * e[21] * e[24] + e[11] * e[19] * e[22] + e[11] * e[18] * e[21] + e[11] * e[20] * e[23] + e[20] * e[18] * e[12] + e[20] * e[9] * e[21] + e[20] * e[19] * e[13] + e[20] * e[10] * e[22] - 1.*e[23] * e[24] * e[15] - 1.*e[23] * e[25] * e[16] - 1.*e[23] * e[18] * e[9] - 1.*e[23] * e[19] * e[10];
		A[25] = 1.500000000*e[27] * ep2[0] - .5000000000*e[27] * ep2[4] + .5000000000*e[27] * ep2[6] - .5000000000*e[27] * ep2[5] + .5000000000*e[27] * ep2[1] - .5000000000*e[27] * ep2[7] + .5000000000*e[27] * ep2[3] + .5000000000*e[27] * ep2[2] - .5000000000*e[27] * ep2[8] + e[0] * e[33] * e[6] + e[0] * e[30] * e[3] - 1.*e[0] * e[35] * e[8] - 1.*e[0] * e[31] * e[4] + e[3] * e[28] * e[4] + e[3] * e[1] * e[31] + e[3] * e[29] * e[5] + e[3] * e[2] * e[32] + e[30] * e[1] * e[4] + e[30] * e[2] * e[5] + e[6] * e[28] * e[7] + e[6] * e[1] * e[34] + e[6] * e[29] * e[8] + e[6] * e[2] * e[35] + e[33] * e[1] * e[7] + e[33] * e[2] * e[8] + e[0] * e[28] * e[1] + e[0] * e[29] * e[2] - 1.*e[0] * e[34] * e[7] - 1.*e[0] * e[32] * e[5];
		A[139] = e[8] * e[22] * e[25] + e[8] * e[21] * e[24] + e[20] * e[18] * e[3] + e[20] * e[0] * e[21] + e[20] * e[19] * e[4] + e[20] * e[1] * e[22] + e[20] * e[2] * e[23] + e[23] * e[21] * e[3] + e[23] * e[22] * e[4] + e[23] * e[26] * e[8] - 1.*e[23] * e[19] * e[1] - 1.*e[23] * e[18] * e[0] - 1.*e[23] * e[25] * e[7] - 1.*e[23] * e[24] * e[6] + e[2] * e[19] * e[22] + e[2] * e[18] * e[21] + e[26] * e[21] * e[6] + e[26] * e[3] * e[24] + e[26] * e[22] * e[7] + e[26] * e[4] * e[25] + .5000000000*ep2[20] * e[5] + 1.500000000*ep2[23] * e[5] + .5000000000*e[5] * ep2[22] + .5000000000*e[5] * ep2[21] + .5000000000*e[5] * ep2[26] - .5000000000*e[5] * ep2[18] - .5000000000*e[5] * ep2[19] - .5000000000*e[5] * ep2[24] - .5000000000*e[5] * ep2[25];
		A[24] = e[24] * e[11] * e[8] + e[24] * e[2] * e[17] + 3.*e[9] * e[18] * e[0] + e[9] * e[19] * e[1] + e[9] * e[20] * e[2] + e[18] * e[10] * e[1] + e[18] * e[11] * e[2] + e[3] * e[18] * e[12] + e[3] * e[9] * e[21] + e[3] * e[20] * e[14] + e[3] * e[11] * e[23] + e[3] * e[19] * e[13] + e[3] * e[10] * e[22] + e[6] * e[18] * e[15] + e[6] * e[9] * e[24] + e[6] * e[20] * e[17] + e[6] * e[11] * e[26] + e[6] * e[19] * e[16] + e[6] * e[10] * e[25] + e[0] * e[20] * e[11] + e[0] * e[19] * e[10] - 1.*e[9] * e[26] * e[8] - 1.*e[9] * e[22] * e[4] - 1.*e[9] * e[25] * e[7] - 1.*e[9] * e[23] * e[5] + e[12] * e[0] * e[21] + e[12] * e[19] * e[4] + e[12] * e[1] * e[22] + e[12] * e[20] * e[5] + e[12] * e[2] * e[23] - 1.*e[18] * e[13] * e[4] - 1.*e[18] * e[16] * e[7] - 1.*e[18] * e[14] * e[5] - 1.*e[18] * e[17] * e[8] + e[21] * e[10] * e[4] + e[21] * e[1] * e[13] + e[21] * e[11] * e[5] + e[21] * e[2] * e[14] + e[15] * e[0] * e[24] + e[15] * e[19] * e[7] + e[15] * e[1] * e[25] + e[15] * e[20] * e[8] + e[15] * e[2] * e[26] - 1.*e[0] * e[23] * e[14] - 1.*e[0] * e[25] * e[16] - 1.*e[0] * e[26] * e[17] - 1.*e[0] * e[22] * e[13] + e[24] * e[10] * e[7] + e[24] * e[1] * e[16];
		A[138] = e[11] * e[1] * e[4] + e[11] * e[0] * e[3] + e[11] * e[2] * e[5] + e[5] * e[12] * e[3] + e[5] * e[13] * e[4] + e[8] * e[12] * e[6] + e[8] * e[3] * e[15] + e[8] * e[13] * e[7] + e[8] * e[4] * e[16] + e[8] * e[5] * e[17] + e[17] * e[4] * e[7] + e[17] * e[3] * e[6] - 1.*e[5] * e[10] * e[1] - 1.*e[5] * e[16] * e[7] - 1.*e[5] * e[15] * e[6] - 1.*e[5] * e[9] * e[0] + e[2] * e[9] * e[3] + e[2] * e[0] * e[12] + e[2] * e[10] * e[4] + e[2] * e[1] * e[13] + .5000000000*ep2[2] * e[14] - .5000000000*e[14] * ep2[0] - .5000000000*e[14] * ep2[6] - .5000000000*e[14] * ep2[1] - .5000000000*e[14] * ep2[7] + 1.500000000*e[14] * ep2[5] + .5000000000*e[14] * ep2[4] + .5000000000*e[14] * ep2[3] + .5000000000*e[14] * ep2[8];
		A[31] = e[3] * e[27] * e[12] + e[3] * e[9] * e[30] + e[3] * e[29] * e[14] + e[3] * e[11] * e[32] + e[3] * e[28] * e[13] + e[3] * e[10] * e[31] + e[6] * e[27] * e[15] + e[6] * e[9] * e[33] + e[6] * e[29] * e[17] + e[6] * e[11] * e[35] + e[6] * e[28] * e[16] + e[6] * e[10] * e[34] + 3.*e[0] * e[27] * e[9] + e[0] * e[29] * e[11] + e[0] * e[28] * e[10] - 1.*e[9] * e[34] * e[7] - 1.*e[9] * e[32] * e[5] - 1.*e[9] * e[35] * e[8] + e[9] * e[29] * e[2] + e[9] * e[28] * e[1] - 1.*e[9] * e[31] * e[4] + e[12] * e[0] * e[30] + e[12] * e[28] * e[4] + e[12] * e[1] * e[31] + e[12] * e[29] * e[5] + e[12] * e[2] * e[32] + e[27] * e[11] * e[2] + e[27] * e[10] * e[1] - 1.*e[27] * e[13] * e[4] - 1.*e[27] * e[16] * e[7] - 1.*e[27] * e[14] * e[5] - 1.*e[27] * e[17] * e[8] + e[30] * e[10] * e[4] + e[30] * e[1] * e[13] + e[30] * e[11] * e[5] + e[30] * e[2] * e[14] + e[15] * e[0] * e[33] + e[15] * e[28] * e[7] + e[15] * e[1] * e[34] + e[15] * e[29] * e[8] + e[15] * e[2] * e[35] - 1.*e[0] * e[31] * e[13] - 1.*e[0] * e[32] * e[14] - 1.*e[0] * e[34] * e[16] - 1.*e[0] * e[35] * e[17] + e[33] * e[10] * e[7] + e[33] * e[1] * e[16] + e[33] * e[11] * e[8] + e[33] * e[2] * e[17];
		A[141] = .5000000000*ep2[30] * e[6] + .5000000000*e[6] * ep2[27] - .5000000000*e[6] * ep2[32] - .5000000000*e[6] * ep2[28] - .5000000000*e[6] * ep2[29] - .5000000000*e[6] * ep2[31] + 1.500000000*e[6] * ep2[33] + .5000000000*e[6] * ep2[34] + .5000000000*e[6] * ep2[35] + e[0] * e[27] * e[33] + e[0] * e[29] * e[35] + e[0] * e[28] * e[34] + e[3] * e[30] * e[33] + e[3] * e[32] * e[35] + e[3] * e[31] * e[34] + e[30] * e[31] * e[7] + e[30] * e[4] * e[34] + e[30] * e[32] * e[8] + e[30] * e[5] * e[35] + e[27] * e[28] * e[7] + e[27] * e[1] * e[34] + e[27] * e[29] * e[8] + e[27] * e[2] * e[35] + e[33] * e[34] * e[7] + e[33] * e[35] * e[8] - 1.*e[33] * e[32] * e[5] - 1.*e[33] * e[29] * e[2] - 1.*e[33] * e[28] * e[1] - 1.*e[33] * e[31] * e[4];
		A[30] = e[24] * e[20] * e[26] + e[21] * e[19] * e[22] - .5000000000*e[18] * ep2[22] - .5000000000*e[18] * ep2[25] + .5000000000*ep3[18] + .5000000000*e[18] * ep2[21] + e[21] * e[20] * e[23] + .5000000000*e[18] * ep2[20] + .5000000000*e[18] * ep2[19] + .5000000000*e[18] * ep2[24] + e[24] * e[19] * e[25] - .5000000000*e[18] * ep2[23] - .5000000000*e[18] * ep2[26];
		A[140] = .5000000000*e[33] * ep2[35] + .5000000000*ep3[33] + .5000000000*ep2[27] * e[33] + .5000000000*ep2[30] * e[33] - .5000000000*e[33] * ep2[29] + .5000000000*e[33] * ep2[34] - .5000000000*e[33] * ep2[32] - .5000000000*e[33] * ep2[28] + e[30] * e[32] * e[35] - .5000000000*e[33] * ep2[31] + e[27] * e[29] * e[35] + e[27] * e[28] * e[34] + e[30] * e[31] * e[34];
		A[29] = 1.500000000*e[27] * ep2[18] + .5000000000*e[27] * ep2[19] + .5000000000*e[27] * ep2[20] + .5000000000*e[27] * ep2[21] + .5000000000*e[27] * ep2[24] - .5000000000*e[27] * ep2[26] - .5000000000*e[27] * ep2[23] - .5000000000*e[27] * ep2[22] - .5000000000*e[27] * ep2[25] + e[33] * e[20] * e[26] - 1.*e[18] * e[35] * e[26] - 1.*e[18] * e[31] * e[22] - 1.*e[18] * e[32] * e[23] - 1.*e[18] * e[34] * e[25] + e[18] * e[28] * e[19] + e[18] * e[29] * e[20] + e[21] * e[18] * e[30] + e[21] * e[28] * e[22] + e[21] * e[19] * e[31] + e[21] * e[29] * e[23] + e[21] * e[20] * e[32] + e[30] * e[19] * e[22] + e[30] * e[20] * e[23] + e[24] * e[18] * e[33] + e[24] * e[28] * e[25] + e[24] * e[19] * e[34] + e[24] * e[29] * e[26] + e[24] * e[20] * e[35] + e[33] * e[19] * e[25];
		A[143] = e[9] * e[27] * e[33] + e[9] * e[29] * e[35] + e[9] * e[28] * e[34] + e[33] * e[35] * e[17] + e[33] * e[34] * e[16] + e[27] * e[29] * e[17] + e[27] * e[11] * e[35] + e[27] * e[28] * e[16] + e[27] * e[10] * e[34] + e[33] * e[30] * e[12] - 1.*e[33] * e[28] * e[10] - 1.*e[33] * e[31] * e[13] - 1.*e[33] * e[32] * e[14] - 1.*e[33] * e[29] * e[11] + e[30] * e[32] * e[17] + e[30] * e[14] * e[35] + e[30] * e[31] * e[16] + e[30] * e[13] * e[34] + e[12] * e[32] * e[35] + e[12] * e[31] * e[34] + .5000000000*e[15] * ep2[27] - .5000000000*e[15] * ep2[32] - .5000000000*e[15] * ep2[28] - .5000000000*e[15] * ep2[29] - .5000000000*e[15] * ep2[31] + 1.500000000*e[15] * ep2[33] + .5000000000*e[15] * ep2[30] + .5000000000*e[15] * ep2[34] + .5000000000*e[15] * ep2[35];
		A[28] = .5000000000*e[9] * ep2[12] - .5000000000*e[9] * ep2[16] + .5000000000*e[9] * ep2[10] - .5000000000*e[9] * ep2[17] - .5000000000*e[9] * ep2[13] + e[15] * e[10] * e[16] + e[12] * e[11] * e[14] + .5000000000*e[9] * ep2[11] + .5000000000*e[9] * ep2[15] - .5000000000*e[9] * ep2[14] + e[15] * e[11] * e[17] + .5000000000*ep3[9] + e[12] * e[10] * e[13];
		A[142] = e[18] * e[27] * e[33] + e[18] * e[29] * e[35] + e[18] * e[28] * e[34] + e[27] * e[28] * e[25] + e[27] * e[19] * e[34] + e[27] * e[29] * e[26] + e[27] * e[20] * e[35] + e[21] * e[30] * e[33] + e[21] * e[32] * e[35] + e[21] * e[31] * e[34] + e[30] * e[31] * e[25] + e[30] * e[22] * e[34] + e[30] * e[32] * e[26] + e[30] * e[23] * e[35] + e[33] * e[34] * e[25] + e[33] * e[35] * e[26] - 1.*e[33] * e[29] * e[20] - 1.*e[33] * e[31] * e[22] - 1.*e[33] * e[32] * e[23] - 1.*e[33] * e[28] * e[19] + .5000000000*ep2[27] * e[24] + .5000000000*ep2[30] * e[24] + 1.500000000*e[24] * ep2[33] + .5000000000*e[24] * ep2[35] + .5000000000*e[24] * ep2[34] - .5000000000*e[24] * ep2[32] - .5000000000*e[24] * ep2[28] - .5000000000*e[24] * ep2[29] - .5000000000*e[24] * ep2[31];
		A[36] = .5000000000*e[9] * ep2[21] + .5000000000*e[9] * ep2[24] + .5000000000*e[9] * ep2[19] + 1.500000000*e[9] * ep2[18] + .5000000000*e[9] * ep2[20] - .5000000000*e[9] * ep2[26] - .5000000000*e[9] * ep2[23] - .5000000000*e[9] * ep2[22] - .5000000000*e[9] * ep2[25] + e[21] * e[18] * e[12] + e[21] * e[20] * e[14] + e[21] * e[11] * e[23] + e[21] * e[19] * e[13] + e[21] * e[10] * e[22] + e[24] * e[18] * e[15] + e[24] * e[20] * e[17] + e[24] * e[11] * e[26] + e[24] * e[19] * e[16] + e[24] * e[10] * e[25] + e[15] * e[19] * e[25] + e[15] * e[20] * e[26] + e[12] * e[19] * e[22] + e[12] * e[20] * e[23] + e[18] * e[20] * e[11] + e[18] * e[19] * e[10] - 1.*e[18] * e[23] * e[14] - 1.*e[18] * e[25] * e[16] - 1.*e[18] * e[26] * e[17] - 1.*e[18] * e[22] * e[13];
		A[182] = .5000000000*ep2[29] * e[26] + .5000000000*ep2[32] * e[26] + .5000000000*e[26] * ep2[33] + 1.500000000*e[26] * ep2[35] + .5000000000*e[26] * ep2[34] - .5000000000*e[26] * ep2[27] - .5000000000*e[26] * ep2[28] - .5000000000*e[26] * ep2[31] - .5000000000*e[26] * ep2[30] + e[20] * e[27] * e[33] + e[20] * e[29] * e[35] + e[20] * e[28] * e[34] + e[29] * e[27] * e[24] + e[29] * e[18] * e[33] + e[29] * e[28] * e[25] + e[29] * e[19] * e[34] + e[23] * e[30] * e[33] + e[23] * e[32] * e[35] + e[23] * e[31] * e[34] + e[32] * e[30] * e[24] + e[32] * e[21] * e[33] + e[32] * e[31] * e[25] + e[32] * e[22] * e[34] + e[35] * e[33] * e[24] + e[35] * e[34] * e[25] - 1.*e[35] * e[27] * e[18] - 1.*e[35] * e[30] * e[21] - 1.*e[35] * e[31] * e[22] - 1.*e[35] * e[28] * e[19];
		A[37] = e[12] * e[19] * e[31] + e[12] * e[29] * e[23] + e[12] * e[20] * e[32] + 3.*e[9] * e[27] * e[18] + e[9] * e[28] * e[19] + e[9] * e[29] * e[20] + e[21] * e[9] * e[30] + e[21] * e[29] * e[14] + e[21] * e[11] * e[32] + e[21] * e[28] * e[13] + e[21] * e[10] * e[31] + e[30] * e[20] * e[14] + e[30] * e[11] * e[23] + e[30] * e[19] * e[13] + e[30] * e[10] * e[22] + e[9] * e[33] * e[24] - 1.*e[9] * e[35] * e[26] - 1.*e[9] * e[31] * e[22] - 1.*e[9] * e[32] * e[23] - 1.*e[9] * e[34] * e[25] + e[18] * e[29] * e[11] + e[18] * e[28] * e[10] + e[27] * e[20] * e[11] + e[27] * e[19] * e[10] + e[15] * e[27] * e[24] + e[15] * e[18] * e[33] + e[15] * e[28] * e[25] + e[15] * e[19] * e[34] + e[15] * e[29] * e[26] + e[15] * e[20] * e[35] - 1.*e[18] * e[31] * e[13] - 1.*e[18] * e[32] * e[14] - 1.*e[18] * e[34] * e[16] - 1.*e[18] * e[35] * e[17] - 1.*e[27] * e[23] * e[14] - 1.*e[27] * e[25] * e[16] - 1.*e[27] * e[26] * e[17] - 1.*e[27] * e[22] * e[13] + e[24] * e[29] * e[17] + e[24] * e[11] * e[35] + e[24] * e[28] * e[16] + e[24] * e[10] * e[34] + e[33] * e[20] * e[17] + e[33] * e[11] * e[26] + e[33] * e[19] * e[16] + e[33] * e[10] * e[25] + e[12] * e[27] * e[21] + e[12] * e[18] * e[30] + e[12] * e[28] * e[22];
		A[183] = -.5000000000*e[17] * ep2[27] + .5000000000*e[17] * ep2[32] - .5000000000*e[17] * ep2[28] + .5000000000*e[17] * ep2[29] - .5000000000*e[17] * ep2[31] + .5000000000*e[17] * ep2[33] - .5000000000*e[17] * ep2[30] + .5000000000*e[17] * ep2[34] + 1.500000000*e[17] * ep2[35] + e[32] * e[30] * e[15] + e[32] * e[12] * e[33] + e[32] * e[31] * e[16] + e[32] * e[13] * e[34] + e[14] * e[30] * e[33] + e[14] * e[31] * e[34] + e[11] * e[27] * e[33] + e[11] * e[29] * e[35] + e[11] * e[28] * e[34] + e[35] * e[33] * e[15] + e[35] * e[34] * e[16] + e[29] * e[27] * e[15] + e[29] * e[9] * e[33] + e[29] * e[28] * e[16] + e[29] * e[10] * e[34] - 1.*e[35] * e[27] * e[9] - 1.*e[35] * e[30] * e[12] - 1.*e[35] * e[28] * e[10] - 1.*e[35] * e[31] * e[13] + e[35] * e[32] * e[14];
		A[38] = .5000000000*e[9] * ep2[1] + 1.500000000*e[9] * ep2[0] + .5000000000*e[9] * ep2[2] + .5000000000*e[9] * ep2[3] + .5000000000*e[9] * ep2[6] - .5000000000*e[9] * ep2[4] - .5000000000*e[9] * ep2[5] - .5000000000*e[9] * ep2[7] - .5000000000*e[9] * ep2[8] + e[6] * e[0] * e[15] + e[6] * e[10] * e[7] + e[6] * e[1] * e[16] + e[6] * e[11] * e[8] + e[6] * e[2] * e[17] + e[15] * e[1] * e[7] + e[15] * e[2] * e[8] + e[0] * e[11] * e[2] + e[0] * e[10] * e[1] - 1.*e[0] * e[13] * e[4] - 1.*e[0] * e[16] * e[7] - 1.*e[0] * e[14] * e[5] - 1.*e[0] * e[17] * e[8] + e[3] * e[0] * e[12] + e[3] * e[10] * e[4] + e[3] * e[1] * e[13] + e[3] * e[11] * e[5] + e[3] * e[2] * e[14] + e[12] * e[1] * e[4] + e[12] * e[2] * e[5];
		A[180] = .5000000000*e[35] * ep2[33] + .5000000000*e[35] * ep2[34] - .5000000000*e[35] * ep2[27] - .5000000000*e[35] * ep2[28] - .5000000000*e[35] * ep2[31] - .5000000000*e[35] * ep2[30] + e[32] * e[31] * e[34] + .5000000000*ep2[29] * e[35] + .5000000000*ep2[32] * e[35] + e[29] * e[28] * e[34] + e[32] * e[30] * e[33] + .5000000000*ep3[35] + e[29] * e[27] * e[33];
		A[39] = .5000000000*e[0] * ep2[19] + .5000000000*e[0] * ep2[20] + .5000000000*e[0] * ep2[24] - .5000000000*e[0] * ep2[26] - .5000000000*e[0] * ep2[23] - .5000000000*e[0] * ep2[22] - .5000000000*e[0] * ep2[25] + 1.500000000*ep2[18] * e[0] + .5000000000*e[0] * ep2[21] + e[18] * e[19] * e[1] + e[18] * e[20] * e[2] + e[21] * e[18] * e[3] + e[21] * e[19] * e[4] + e[21] * e[1] * e[22] + e[21] * e[20] * e[5] + e[21] * e[2] * e[23] - 1.*e[18] * e[26] * e[8] - 1.*e[18] * e[22] * e[4] - 1.*e[18] * e[25] * e[7] - 1.*e[18] * e[23] * e[5] + e[18] * e[24] * e[6] + e[3] * e[19] * e[22] + e[3] * e[20] * e[23] + e[24] * e[19] * e[7] + e[24] * e[1] * e[25] + e[24] * e[20] * e[8] + e[24] * e[2] * e[26] + e[6] * e[19] * e[25] + e[6] * e[20] * e[26];
		A[181] = .5000000000*ep2[32] * e[8] - .5000000000*e[8] * ep2[27] - .5000000000*e[8] * ep2[28] + .5000000000*e[8] * ep2[29] - .5000000000*e[8] * ep2[31] + .5000000000*e[8] * ep2[33] - .5000000000*e[8] * ep2[30] + .5000000000*e[8] * ep2[34] + 1.500000000*e[8] * ep2[35] + e[2] * e[27] * e[33] + e[2] * e[29] * e[35] + e[2] * e[28] * e[34] + e[5] * e[30] * e[33] + e[5] * e[32] * e[35] + e[5] * e[31] * e[34] + e[32] * e[30] * e[6] + e[32] * e[3] * e[33] + e[32] * e[31] * e[7] + e[32] * e[4] * e[34] + e[29] * e[27] * e[6] + e[29] * e[0] * e[33] + e[29] * e[28] * e[7] + e[29] * e[1] * e[34] + e[35] * e[33] * e[6] + e[35] * e[34] * e[7] - 1.*e[35] * e[27] * e[0] - 1.*e[35] * e[30] * e[3] - 1.*e[35] * e[28] * e[1] - 1.*e[35] * e[31] * e[4];
		A[32] = -.5000000000*e[18] * ep2[4] + 1.500000000*e[18] * ep2[0] + .5000000000*e[18] * ep2[6] - .5000000000*e[18] * ep2[5] + .5000000000*e[18] * ep2[1] - .5000000000*e[18] * ep2[7] + .5000000000*e[18] * ep2[3] + .5000000000*e[18] * ep2[2] - .5000000000*e[18] * ep2[8] + e[3] * e[0] * e[21] + e[3] * e[19] * e[4] + e[3] * e[1] * e[22] + e[3] * e[20] * e[5] + e[3] * e[2] * e[23] + e[21] * e[1] * e[4] + e[21] * e[2] * e[5] + e[6] * e[0] * e[24] + e[6] * e[19] * e[7] + e[6] * e[1] * e[25] + e[6] * e[20] * e[8] + e[6] * e[2] * e[26] + e[24] * e[1] * e[7] + e[24] * e[2] * e[8] + e[0] * e[19] * e[1] + e[0] * e[20] * e[2] - 1.*e[0] * e[26] * e[8] - 1.*e[0] * e[22] * e[4] - 1.*e[0] * e[25] * e[7] - 1.*e[0] * e[23] * e[5];
		A[178] = e[10] * e[1] * e[7] + e[10] * e[0] * e[6] + e[10] * e[2] * e[8] + e[4] * e[12] * e[6] + e[4] * e[3] * e[15] + e[4] * e[13] * e[7] + e[4] * e[14] * e[8] + e[4] * e[5] * e[17] + e[13] * e[3] * e[6] + e[13] * e[5] * e[8] + e[7] * e[15] * e[6] + e[7] * e[17] * e[8] - 1.*e[7] * e[11] * e[2] - 1.*e[7] * e[9] * e[0] - 1.*e[7] * e[14] * e[5] - 1.*e[7] * e[12] * e[3] + e[1] * e[9] * e[6] + e[1] * e[0] * e[15] + e[1] * e[11] * e[8] + e[1] * e[2] * e[17] + 1.500000000*e[16] * ep2[7] + .5000000000*e[16] * ep2[6] + .5000000000*e[16] * ep2[8] + .5000000000*ep2[1] * e[16] - .5000000000*e[16] * ep2[0] - .5000000000*e[16] * ep2[5] - .5000000000*e[16] * ep2[3] - .5000000000*e[16] * ep2[2] + .5000000000*ep2[4] * e[16];
		A[33] = e[0] * e[30] * e[21] - 1.*e[0] * e[35] * e[26] - 1.*e[0] * e[31] * e[22] - 1.*e[0] * e[32] * e[23] - 1.*e[0] * e[34] * e[25] - 1.*e[18] * e[34] * e[7] - 1.*e[18] * e[32] * e[5] - 1.*e[18] * e[35] * e[8] - 1.*e[18] * e[31] * e[4] - 1.*e[27] * e[26] * e[8] - 1.*e[27] * e[22] * e[4] - 1.*e[27] * e[25] * e[7] - 1.*e[27] * e[23] * e[5] + e[6] * e[28] * e[25] + e[6] * e[19] * e[34] + e[6] * e[29] * e[26] + e[6] * e[20] * e[35] + e[21] * e[28] * e[4] + e[21] * e[1] * e[31] + e[21] * e[29] * e[5] + e[21] * e[2] * e[32] + e[30] * e[19] * e[4] + e[30] * e[1] * e[22] + e[30] * e[20] * e[5] + e[30] * e[2] * e[23] + e[24] * e[27] * e[6] + e[24] * e[0] * e[33] + e[24] * e[28] * e[7] + e[24] * e[1] * e[34] + e[24] * e[29] * e[8] + e[24] * e[2] * e[35] + e[33] * e[18] * e[6] + e[33] * e[19] * e[7] + e[33] * e[1] * e[25] + e[33] * e[20] * e[8] + e[33] * e[2] * e[26] + 3.*e[0] * e[27] * e[18] + e[0] * e[28] * e[19] + e[0] * e[29] * e[20] + e[18] * e[28] * e[1] + e[18] * e[29] * e[2] + e[27] * e[19] * e[1] + e[27] * e[20] * e[2] + e[3] * e[27] * e[21] + e[3] * e[18] * e[30] + e[3] * e[28] * e[22] + e[3] * e[19] * e[31] + e[3] * e[29] * e[23] + e[3] * e[20] * e[32];
		A[179] = e[19] * e[18] * e[6] + e[19] * e[0] * e[24] + e[19] * e[1] * e[25] + e[19] * e[20] * e[8] + e[19] * e[2] * e[26] + e[22] * e[21] * e[6] + e[22] * e[3] * e[24] + e[22] * e[4] * e[25] + e[22] * e[23] * e[8] + e[22] * e[5] * e[26] - 1.*e[25] * e[21] * e[3] + e[25] * e[26] * e[8] - 1.*e[25] * e[20] * e[2] - 1.*e[25] * e[18] * e[0] - 1.*e[25] * e[23] * e[5] + e[25] * e[24] * e[6] + e[1] * e[18] * e[24] + e[1] * e[20] * e[26] + e[4] * e[21] * e[24] + e[4] * e[23] * e[26] + .5000000000*ep2[19] * e[7] + .5000000000*ep2[22] * e[7] + 1.500000000*ep2[25] * e[7] + .5000000000*e[7] * ep2[26] - .5000000000*e[7] * ep2[18] - .5000000000*e[7] * ep2[23] - .5000000000*e[7] * ep2[20] + .5000000000*e[7] * ep2[24] - .5000000000*e[7] * ep2[21];
		A[34] = .5000000000*e[18] * ep2[11] + 1.500000000*e[18] * ep2[9] + .5000000000*e[18] * ep2[10] + .5000000000*e[18] * ep2[12] + .5000000000*e[18] * ep2[15] - .5000000000*e[18] * ep2[16] - .5000000000*e[18] * ep2[17] - .5000000000*e[18] * ep2[14] - .5000000000*e[18] * ep2[13] + e[12] * e[9] * e[21] + e[12] * e[20] * e[14] + e[12] * e[11] * e[23] + e[12] * e[19] * e[13] + e[12] * e[10] * e[22] + e[21] * e[11] * e[14] + e[21] * e[10] * e[13] + e[15] * e[9] * e[24] + e[15] * e[20] * e[17] + e[15] * e[11] * e[26] + e[15] * e[19] * e[16] + e[15] * e[10] * e[25] + e[24] * e[11] * e[17] + e[24] * e[10] * e[16] - 1.*e[9] * e[23] * e[14] - 1.*e[9] * e[25] * e[16] - 1.*e[9] * e[26] * e[17] + e[9] * e[20] * e[11] + e[9] * e[19] * e[10] - 1.*e[9] * e[22] * e[13];
		A[176] = e[13] * e[21] * e[24] + e[13] * e[23] * e[26] + e[19] * e[18] * e[15] + e[19] * e[9] * e[24] + e[19] * e[20] * e[17] + e[19] * e[11] * e[26] - 1.*e[25] * e[23] * e[14] - 1.*e[25] * e[20] * e[11] - 1.*e[25] * e[18] * e[9] - 1.*e[25] * e[21] * e[12] + e[22] * e[21] * e[15] + e[22] * e[12] * e[24] + e[22] * e[23] * e[17] + e[22] * e[14] * e[26] + e[22] * e[13] * e[25] + e[25] * e[24] * e[15] + e[25] * e[26] * e[17] + e[10] * e[19] * e[25] + e[10] * e[18] * e[24] + e[10] * e[20] * e[26] - .5000000000*e[16] * ep2[18] - .5000000000*e[16] * ep2[23] + .5000000000*e[16] * ep2[19] - .5000000000*e[16] * ep2[20] - .5000000000*e[16] * ep2[21] + .5000000000*ep2[22] * e[16] + 1.500000000*ep2[25] * e[16] + .5000000000*e[16] * ep2[24] + .5000000000*e[16] * ep2[26];
		A[35] = .5000000000*e[0] * ep2[12] + .5000000000*e[0] * ep2[15] + .5000000000*e[0] * ep2[11] + 1.500000000*e[0] * ep2[9] + .5000000000*e[0] * ep2[10] - .5000000000*e[0] * ep2[16] - .5000000000*e[0] * ep2[17] - .5000000000*e[0] * ep2[14] - .5000000000*e[0] * ep2[13] + e[12] * e[9] * e[3] + e[12] * e[10] * e[4] + e[12] * e[1] * e[13] + e[12] * e[11] * e[5] + e[12] * e[2] * e[14] + e[15] * e[9] * e[6] + e[15] * e[10] * e[7] + e[15] * e[1] * e[16] + e[15] * e[11] * e[8] + e[15] * e[2] * e[17] + e[6] * e[11] * e[17] + e[6] * e[10] * e[16] + e[3] * e[11] * e[14] + e[3] * e[10] * e[13] + e[9] * e[10] * e[1] + e[9] * e[11] * e[2] - 1.*e[9] * e[13] * e[4] - 1.*e[9] * e[16] * e[7] - 1.*e[9] * e[14] * e[5] - 1.*e[9] * e[17] * e[8];
		A[177] = e[19] * e[11] * e[35] + e[28] * e[18] * e[15] + e[28] * e[9] * e[24] + e[28] * e[20] * e[17] + e[28] * e[11] * e[26] - 1.*e[25] * e[27] * e[9] - 1.*e[25] * e[30] * e[12] - 1.*e[25] * e[32] * e[14] + e[25] * e[33] * e[15] + e[25] * e[35] * e[17] - 1.*e[25] * e[29] * e[11] - 1.*e[34] * e[23] * e[14] + e[34] * e[24] * e[15] + e[34] * e[26] * e[17] - 1.*e[34] * e[20] * e[11] - 1.*e[34] * e[18] * e[9] - 1.*e[34] * e[21] * e[12] + e[13] * e[30] * e[24] + e[13] * e[21] * e[33] + e[13] * e[31] * e[25] + e[13] * e[22] * e[34] + e[13] * e[32] * e[26] + e[13] * e[23] * e[35] + e[10] * e[27] * e[24] + e[10] * e[18] * e[33] + e[10] * e[28] * e[25] + e[10] * e[19] * e[34] + e[10] * e[29] * e[26] + e[10] * e[20] * e[35] + e[22] * e[30] * e[15] + e[22] * e[12] * e[33] + e[22] * e[32] * e[17] + e[22] * e[14] * e[35] + e[22] * e[31] * e[16] + e[31] * e[21] * e[15] + e[31] * e[12] * e[24] + e[31] * e[23] * e[17] + e[31] * e[14] * e[26] - 1.*e[16] * e[27] * e[18] + e[16] * e[33] * e[24] - 1.*e[16] * e[30] * e[21] - 1.*e[16] * e[29] * e[20] + e[16] * e[35] * e[26] - 1.*e[16] * e[32] * e[23] + e[16] * e[28] * e[19] + 3.*e[16] * e[34] * e[25] + e[19] * e[27] * e[15] + e[19] * e[9] * e[33] + e[19] * e[29] * e[17];
		A[45] = e[4] * e[27] * e[3] + e[4] * e[0] * e[30] + e[4] * e[29] * e[5] + e[4] * e[2] * e[32] + e[31] * e[0] * e[3] + e[31] * e[2] * e[5] + e[7] * e[27] * e[6] + e[7] * e[0] * e[33] + e[7] * e[29] * e[8] + e[7] * e[2] * e[35] + e[34] * e[0] * e[6] + e[34] * e[2] * e[8] + e[1] * e[27] * e[0] + e[1] * e[29] * e[2] + e[1] * e[34] * e[7] - 1.*e[1] * e[32] * e[5] - 1.*e[1] * e[33] * e[6] - 1.*e[1] * e[30] * e[3] - 1.*e[1] * e[35] * e[8] + e[1] * e[31] * e[4] + 1.500000000*e[28] * ep2[1] + .5000000000*e[28] * ep2[4] + .5000000000*e[28] * ep2[0] - .5000000000*e[28] * ep2[6] - .5000000000*e[28] * ep2[5] + .5000000000*e[28] * ep2[7] - .5000000000*e[28] * ep2[3] + .5000000000*e[28] * ep2[2] - .5000000000*e[28] * ep2[8];
		A[191] = -1.*e[35] * e[10] * e[1] - 1.*e[35] * e[13] * e[4] + e[35] * e[16] * e[7] + e[35] * e[15] * e[6] - 1.*e[35] * e[9] * e[0] - 1.*e[35] * e[12] * e[3] + e[32] * e[12] * e[6] + e[32] * e[3] * e[15] + e[32] * e[13] * e[7] + e[32] * e[4] * e[16] - 1.*e[8] * e[27] * e[9] - 1.*e[8] * e[30] * e[12] - 1.*e[8] * e[28] * e[10] - 1.*e[8] * e[31] * e[13] + e[8] * e[29] * e[11] + e[11] * e[27] * e[6] + e[11] * e[0] * e[33] + e[11] * e[28] * e[7] + e[11] * e[1] * e[34] + e[29] * e[9] * e[6] + e[29] * e[0] * e[15] + e[29] * e[10] * e[7] + e[29] * e[1] * e[16] + e[5] * e[30] * e[15] + e[5] * e[12] * e[33] + e[5] * e[32] * e[17] + e[5] * e[14] * e[35] + e[5] * e[31] * e[16] + e[5] * e[13] * e[34] + e[8] * e[33] * e[15] + 3.*e[8] * e[35] * e[17] + e[8] * e[34] * e[16] + e[2] * e[27] * e[15] + e[2] * e[9] * e[33] + e[2] * e[29] * e[17] + e[2] * e[11] * e[35] + e[2] * e[28] * e[16] + e[2] * e[10] * e[34] - 1.*e[17] * e[27] * e[0] + e[17] * e[34] * e[7] + e[17] * e[33] * e[6] - 1.*e[17] * e[30] * e[3] - 1.*e[17] * e[28] * e[1] - 1.*e[17] * e[31] * e[4] + e[14] * e[30] * e[6] + e[14] * e[3] * e[33] + e[14] * e[31] * e[7] + e[14] * e[4] * e[34] + e[14] * e[32] * e[8];
		A[44] = e[19] * e[11] * e[2] + e[4] * e[18] * e[12] + e[4] * e[9] * e[21] + e[4] * e[20] * e[14] + e[4] * e[11] * e[23] + e[4] * e[19] * e[13] + e[4] * e[10] * e[22] + e[7] * e[18] * e[15] + e[7] * e[9] * e[24] + e[7] * e[20] * e[17] + e[7] * e[11] * e[26] + e[7] * e[19] * e[16] + e[7] * e[10] * e[25] + e[1] * e[18] * e[9] + e[1] * e[20] * e[11] - 1.*e[10] * e[21] * e[3] - 1.*e[10] * e[26] * e[8] - 1.*e[10] * e[23] * e[5] - 1.*e[10] * e[24] * e[6] + e[13] * e[18] * e[3] + e[13] * e[0] * e[21] + e[13] * e[1] * e[22] + e[13] * e[20] * e[5] + e[13] * e[2] * e[23] - 1.*e[19] * e[15] * e[6] - 1.*e[19] * e[14] * e[5] - 1.*e[19] * e[12] * e[3] - 1.*e[19] * e[17] * e[8] + e[22] * e[9] * e[3] + e[22] * e[0] * e[12] + e[22] * e[11] * e[5] + e[22] * e[2] * e[14] + e[16] * e[18] * e[6] + e[16] * e[0] * e[24] + e[16] * e[1] * e[25] + e[16] * e[20] * e[8] + e[16] * e[2] * e[26] - 1.*e[1] * e[23] * e[14] - 1.*e[1] * e[24] * e[15] - 1.*e[1] * e[26] * e[17] - 1.*e[1] * e[21] * e[12] + e[25] * e[9] * e[6] + e[25] * e[0] * e[15] + e[25] * e[11] * e[8] + e[25] * e[2] * e[17] + e[10] * e[18] * e[0] + 3.*e[10] * e[19] * e[1] + e[10] * e[20] * e[2] + e[19] * e[9] * e[0];
		A[190] = .5000000000*ep2[23] * e[26] + .5000000000*e[26] * ep2[25] + .5000000000*ep2[20] * e[26] - .5000000000*e[26] * ep2[18] + .5000000000*ep3[26] + .5000000000*e[26] * ep2[24] + e[20] * e[19] * e[25] - .5000000000*e[26] * ep2[19] - .5000000000*e[26] * ep2[21] + e[20] * e[18] * e[24] - .5000000000*e[26] * ep2[22] + e[23] * e[21] * e[24] + e[23] * e[22] * e[25];
		A[47] = e[16] * e[9] * e[33] + e[16] * e[29] * e[17] + e[16] * e[11] * e[35] + e[16] * e[10] * e[34] + e[34] * e[11] * e[17] + e[34] * e[9] * e[15] - 1.*e[10] * e[30] * e[12] - 1.*e[10] * e[32] * e[14] - 1.*e[10] * e[33] * e[15] - 1.*e[10] * e[35] * e[17] + e[10] * e[27] * e[9] + e[10] * e[29] * e[11] + e[13] * e[27] * e[12] + e[13] * e[9] * e[30] + e[13] * e[29] * e[14] + e[13] * e[11] * e[32] + e[13] * e[10] * e[31] + e[31] * e[11] * e[14] + e[31] * e[9] * e[12] + e[16] * e[27] * e[15] + 1.500000000*e[28] * ep2[10] + .5000000000*e[28] * ep2[16] + .5000000000*e[28] * ep2[9] + .5000000000*e[28] * ep2[11] - .5000000000*e[28] * ep2[12] - .5000000000*e[28] * ep2[15] - .5000000000*e[28] * ep2[17] - .5000000000*e[28] * ep2[14] + .5000000000*e[28] * ep2[13];
		A[189] = .5000000000*ep2[20] * e[35] + .5000000000*ep2[23] * e[35] + 1.500000000*e[35] * ep2[26] + .5000000000*e[35] * ep2[25] + .5000000000*e[35] * ep2[24] - .5000000000*e[35] * ep2[18] - .5000000000*e[35] * ep2[19] - .5000000000*e[35] * ep2[22] - .5000000000*e[35] * ep2[21] + e[20] * e[27] * e[24] + e[20] * e[18] * e[33] + e[20] * e[28] * e[25] + e[20] * e[19] * e[34] + e[20] * e[29] * e[26] + e[29] * e[19] * e[25] + e[29] * e[18] * e[24] + e[23] * e[30] * e[24] + e[23] * e[21] * e[33] + e[23] * e[31] * e[25] + e[23] * e[22] * e[34] + e[23] * e[32] * e[26] + e[32] * e[22] * e[25] + e[32] * e[21] * e[24] + e[26] * e[33] * e[24] + e[26] * e[34] * e[25] - 1.*e[26] * e[27] * e[18] - 1.*e[26] * e[30] * e[21] - 1.*e[26] * e[31] * e[22] - 1.*e[26] * e[28] * e[19];
		A[46] = e[4] * e[2] * e[5] + .5000000000*e[1] * ep2[0] - .5000000000*e[1] * ep2[6] + e[7] * e[0] * e[6] + .5000000000*e[1] * ep2[7] + .5000000000*e[1] * ep2[4] - .5000000000*e[1] * ep2[8] + .5000000000*e[1] * ep2[2] - .5000000000*e[1] * ep2[3] + .5000000000*ep3[1] + e[7] * e[2] * e[8] - .5000000000*e[1] * ep2[5] + e[4] * e[0] * e[3];
		A[188] = -.5000000000*e[17] * ep2[13] - .5000000000*e[17] * ep2[9] + .5000000000*e[17] * ep2[16] + .5000000000*e[17] * ep2[15] + .5000000000*ep3[17] - .5000000000*e[17] * ep2[10] + e[14] * e[13] * e[16] + e[14] * e[12] * e[15] + .5000000000*ep2[14] * e[17] + e[11] * e[10] * e[16] - .5000000000*e[17] * ep2[12] + .5000000000*ep2[11] * e[17] + e[11] * e[9] * e[15];
		A[41] = e[4] * e[27] * e[30] + e[4] * e[29] * e[32] + e[4] * e[28] * e[31] + e[31] * e[27] * e[3] + e[31] * e[0] * e[30] + e[31] * e[29] * e[5] + e[31] * e[2] * e[32] + e[7] * e[27] * e[33] + e[7] * e[29] * e[35] + e[7] * e[28] * e[34] + e[28] * e[27] * e[0] + e[28] * e[29] * e[2] + e[34] * e[27] * e[6] + e[34] * e[0] * e[33] + e[34] * e[29] * e[8] + e[34] * e[2] * e[35] - 1.*e[28] * e[32] * e[5] - 1.*e[28] * e[33] * e[6] - 1.*e[28] * e[30] * e[3] - 1.*e[28] * e[35] * e[8] + .5000000000*e[1] * ep2[27] + .5000000000*e[1] * ep2[29] + 1.500000000*e[1] * ep2[28] + .5000000000*e[1] * ep2[31] - .5000000000*e[1] * ep2[32] - .5000000000*e[1] * ep2[33] - .5000000000*e[1] * ep2[30] + .5000000000*e[1] * ep2[34] - .5000000000*e[1] * ep2[35];
		A[187] = .5000000000*ep2[11] * e[35] + .5000000000*e[35] * ep2[16] - .5000000000*e[35] * ep2[9] - .5000000000*e[35] * ep2[12] + .5000000000*e[35] * ep2[15] + 1.500000000*e[35] * ep2[17] - .5000000000*e[35] * ep2[10] + .5000000000*e[35] * ep2[14] - .5000000000*e[35] * ep2[13] + e[11] * e[27] * e[15] + e[11] * e[9] * e[33] + e[11] * e[29] * e[17] + e[11] * e[28] * e[16] + e[11] * e[10] * e[34] + e[29] * e[9] * e[15] + e[29] * e[10] * e[16] + e[14] * e[30] * e[15] + e[14] * e[12] * e[33] + e[14] * e[32] * e[17] + e[14] * e[31] * e[16] + e[14] * e[13] * e[34] + e[32] * e[12] * e[15] + e[32] * e[13] * e[16] + e[17] * e[33] * e[15] + e[17] * e[34] * e[16] - 1.*e[17] * e[27] * e[9] - 1.*e[17] * e[30] * e[12] - 1.*e[17] * e[28] * e[10] - 1.*e[17] * e[31] * e[13];
		A[40] = e[34] * e[27] * e[33] + e[34] * e[29] * e[35] - .5000000000*e[28] * ep2[30] - .5000000000*e[28] * ep2[35] + .5000000000*ep3[28] + .5000000000*e[28] * ep2[27] + .5000000000*e[28] * ep2[29] + e[31] * e[27] * e[30] + e[31] * e[29] * e[32] - .5000000000*e[28] * ep2[32] - .5000000000*e[28] * ep2[33] + .5000000000*e[28] * ep2[31] + .5000000000*e[28] * ep2[34];
		A[186] = .5000000000*ep2[5] * e[8] + e[2] * e[0] * e[6] + .5000000000*ep2[2] * e[8] + .5000000000*ep3[8] - .5000000000*e[8] * ep2[0] + e[5] * e[4] * e[7] + e[5] * e[3] * e[6] + .5000000000*e[8] * ep2[7] + e[2] * e[1] * e[7] - .5000000000*e[8] * ep2[1] - .5000000000*e[8] * ep2[4] - .5000000000*e[8] * ep2[3] + .5000000000*e[8] * ep2[6];
		A[43] = e[28] * e[27] * e[9] + e[28] * e[29] * e[11] - 1.*e[28] * e[30] * e[12] + e[28] * e[31] * e[13] - 1.*e[28] * e[32] * e[14] - 1.*e[28] * e[33] * e[15] - 1.*e[28] * e[35] * e[17] + e[31] * e[27] * e[12] + e[31] * e[9] * e[30] + e[31] * e[29] * e[14] + e[31] * e[11] * e[32] + e[13] * e[27] * e[30] + e[13] * e[29] * e[32] + e[16] * e[27] * e[33] + e[16] * e[29] * e[35] + e[34] * e[27] * e[15] + e[34] * e[9] * e[33] + e[34] * e[29] * e[17] + e[34] * e[11] * e[35] + e[34] * e[28] * e[16] + .5000000000*e[10] * ep2[27] + .5000000000*e[10] * ep2[29] + 1.500000000*e[10] * ep2[28] - .5000000000*e[10] * ep2[32] + .5000000000*e[10] * ep2[31] - .5000000000*e[10] * ep2[33] - .5000000000*e[10] * ep2[30] + .5000000000*e[10] * ep2[34] - .5000000000*e[10] * ep2[35];
		A[185] = -.5000000000*e[35] * ep2[1] + .5000000000*e[35] * ep2[7] - .5000000000*e[35] * ep2[3] + .5000000000*ep2[2] * e[35] + 1.500000000*e[35] * ep2[8] - .5000000000*e[35] * ep2[4] - .5000000000*e[35] * ep2[0] + .5000000000*e[35] * ep2[6] + .5000000000*e[35] * ep2[5] + e[2] * e[27] * e[6] + e[2] * e[0] * e[33] + e[2] * e[28] * e[7] + e[2] * e[1] * e[34] + e[2] * e[29] * e[8] - 1.*e[8] * e[27] * e[0] + e[8] * e[34] * e[7] + e[8] * e[32] * e[5] + e[8] * e[33] * e[6] - 1.*e[8] * e[30] * e[3] - 1.*e[8] * e[28] * e[1] - 1.*e[8] * e[31] * e[4] + e[29] * e[1] * e[7] + e[29] * e[0] * e[6] + e[5] * e[30] * e[6] + e[5] * e[3] * e[33] + e[5] * e[31] * e[7] + e[5] * e[4] * e[34] + e[32] * e[4] * e[7] + e[32] * e[3] * e[6];
		A[42] = e[28] * e[27] * e[18] + e[28] * e[29] * e[20] + e[22] * e[27] * e[30] + e[22] * e[29] * e[32] + e[22] * e[28] * e[31] + e[31] * e[27] * e[21] + e[31] * e[18] * e[30] + e[31] * e[29] * e[23] + e[31] * e[20] * e[32] + e[25] * e[27] * e[33] + e[25] * e[29] * e[35] + e[25] * e[28] * e[34] + e[34] * e[27] * e[24] + e[34] * e[18] * e[33] + e[34] * e[29] * e[26] + e[34] * e[20] * e[35] - 1.*e[28] * e[33] * e[24] - 1.*e[28] * e[30] * e[21] - 1.*e[28] * e[35] * e[26] - 1.*e[28] * e[32] * e[23] - .5000000000*e[19] * ep2[33] - .5000000000*e[19] * ep2[30] - .5000000000*e[19] * ep2[35] + .5000000000*e[19] * ep2[27] + .5000000000*e[19] * ep2[29] + 1.500000000*e[19] * ep2[28] + .5000000000*e[19] * ep2[31] + .5000000000*e[19] * ep2[34] - .5000000000*e[19] * ep2[32];
		A[184] = e[23] * e[3] * e[15] - 1.*e[17] * e[19] * e[1] - 1.*e[17] * e[22] * e[4] - 1.*e[17] * e[18] * e[0] + e[17] * e[25] * e[7] + e[17] * e[24] * e[6] + e[14] * e[21] * e[6] + e[14] * e[3] * e[24] + e[14] * e[22] * e[7] + e[14] * e[4] * e[25] + e[14] * e[23] * e[8] - 1.*e[26] * e[10] * e[1] - 1.*e[26] * e[13] * e[4] + e[26] * e[16] * e[7] + e[26] * e[15] * e[6] - 1.*e[26] * e[9] * e[0] - 1.*e[26] * e[12] * e[3] + e[23] * e[12] * e[6] + e[11] * e[18] * e[6] + e[11] * e[0] * e[24] + e[11] * e[19] * e[7] + e[11] * e[1] * e[25] + e[11] * e[20] * e[8] + e[11] * e[2] * e[26] + e[20] * e[9] * e[6] + e[20] * e[0] * e[15] + e[20] * e[10] * e[7] + e[20] * e[1] * e[16] + e[20] * e[2] * e[17] + e[5] * e[21] * e[15] + e[5] * e[12] * e[24] + e[5] * e[23] * e[17] + e[5] * e[14] * e[26] + e[5] * e[22] * e[16] + e[5] * e[13] * e[25] + e[8] * e[24] * e[15] + 3.*e[8] * e[26] * e[17] + e[8] * e[25] * e[16] + e[2] * e[18] * e[15] + e[2] * e[9] * e[24] + e[2] * e[19] * e[16] + e[2] * e[10] * e[25] - 1.*e[17] * e[21] * e[3] + e[23] * e[4] * e[16] + e[23] * e[13] * e[7] - 1.*e[8] * e[18] * e[9] - 1.*e[8] * e[21] * e[12] - 1.*e[8] * e[19] * e[10] - 1.*e[8] * e[22] * e[13];
		A[54] = e[13] * e[18] * e[12] + e[13] * e[9] * e[21] + e[13] * e[20] * e[14] + e[13] * e[11] * e[23] + e[13] * e[10] * e[22] + e[22] * e[11] * e[14] + e[22] * e[9] * e[12] + e[16] * e[18] * e[15] + e[16] * e[9] * e[24] + e[16] * e[20] * e[17] + e[16] * e[11] * e[26] + e[16] * e[10] * e[25] + e[25] * e[11] * e[17] + e[25] * e[9] * e[15] - 1.*e[10] * e[23] * e[14] - 1.*e[10] * e[24] * e[15] - 1.*e[10] * e[26] * e[17] + e[10] * e[20] * e[11] + e[10] * e[18] * e[9] - 1.*e[10] * e[21] * e[12] + .5000000000*e[19] * ep2[11] + .5000000000*e[19] * ep2[9] + 1.500000000*e[19] * ep2[10] + .5000000000*e[19] * ep2[13] + .5000000000*e[19] * ep2[16] - .5000000000*e[19] * ep2[12] - .5000000000*e[19] * ep2[15] - .5000000000*e[19] * ep2[17] - .5000000000*e[19] * ep2[14];
		A[164] = e[10] * e[18] * e[6] + e[10] * e[0] * e[24] + e[10] * e[19] * e[7] + e[10] * e[1] * e[25] + e[10] * e[20] * e[8] + e[10] * e[2] * e[26] + e[19] * e[9] * e[6] + e[19] * e[0] * e[15] + e[19] * e[1] * e[16] + e[19] * e[11] * e[8] + e[19] * e[2] * e[17] + e[4] * e[21] * e[15] + e[4] * e[12] * e[24] + e[4] * e[23] * e[17] + e[4] * e[14] * e[26] + e[4] * e[22] * e[16] + e[4] * e[13] * e[25] + e[7] * e[24] * e[15] + e[7] * e[26] * e[17] + 3.*e[7] * e[25] * e[16] + e[1] * e[18] * e[15] + e[1] * e[9] * e[24] + e[1] * e[20] * e[17] + e[1] * e[11] * e[26] - 1.*e[16] * e[21] * e[3] + e[16] * e[26] * e[8] - 1.*e[16] * e[20] * e[2] - 1.*e[16] * e[18] * e[0] - 1.*e[16] * e[23] * e[5] + e[16] * e[24] * e[6] + e[13] * e[21] * e[6] + e[13] * e[3] * e[24] + e[13] * e[22] * e[7] + e[13] * e[23] * e[8] + e[13] * e[5] * e[26] - 1.*e[25] * e[11] * e[2] + e[25] * e[15] * e[6] - 1.*e[25] * e[9] * e[0] - 1.*e[25] * e[14] * e[5] - 1.*e[25] * e[12] * e[3] + e[25] * e[17] * e[8] + e[22] * e[12] * e[6] + e[22] * e[3] * e[15] + e[22] * e[14] * e[8] + e[22] * e[5] * e[17] - 1.*e[7] * e[23] * e[14] - 1.*e[7] * e[20] * e[11] - 1.*e[7] * e[18] * e[9] - 1.*e[7] * e[21] * e[12];
		A[55] = e[13] * e[9] * e[3] + e[13] * e[0] * e[12] + e[13] * e[10] * e[4] + e[13] * e[11] * e[5] + e[13] * e[2] * e[14] + e[16] * e[9] * e[6] + e[16] * e[0] * e[15] + e[16] * e[10] * e[7] + e[16] * e[11] * e[8] + e[16] * e[2] * e[17] + e[7] * e[11] * e[17] + e[7] * e[9] * e[15] + e[4] * e[11] * e[14] + e[4] * e[9] * e[12] + e[10] * e[9] * e[0] + e[10] * e[11] * e[2] - 1.*e[10] * e[15] * e[6] - 1.*e[10] * e[14] * e[5] - 1.*e[10] * e[12] * e[3] - 1.*e[10] * e[17] * e[8] + .5000000000*e[1] * ep2[11] + .5000000000*e[1] * ep2[9] + 1.500000000*e[1] * ep2[10] - .5000000000*e[1] * ep2[12] - .5000000000*e[1] * ep2[15] - .5000000000*e[1] * ep2[17] - .5000000000*e[1] * ep2[14] + .5000000000*e[1] * ep2[13] + .5000000000*e[1] * ep2[16];
		A[165] = e[1] * e[27] * e[6] + e[1] * e[0] * e[33] + e[1] * e[28] * e[7] + e[1] * e[29] * e[8] + e[1] * e[2] * e[35] - 1.*e[7] * e[27] * e[0] - 1.*e[7] * e[32] * e[5] + e[7] * e[33] * e[6] - 1.*e[7] * e[30] * e[3] + e[7] * e[35] * e[8] - 1.*e[7] * e[29] * e[2] + e[7] * e[31] * e[4] + e[28] * e[0] * e[6] + e[28] * e[2] * e[8] + e[4] * e[30] * e[6] + e[4] * e[3] * e[33] + e[4] * e[32] * e[8] + e[4] * e[5] * e[35] + e[31] * e[3] * e[6] + e[31] * e[5] * e[8] + .5000000000*ep2[1] * e[34] + 1.500000000*e[34] * ep2[7] + .5000000000*e[34] * ep2[4] - .5000000000*e[34] * ep2[0] + .5000000000*e[34] * ep2[6] - .5000000000*e[34] * ep2[5] - .5000000000*e[34] * ep2[3] - .5000000000*e[34] * ep2[2] + .5000000000*e[34] * ep2[8];
		A[52] = e[4] * e[18] * e[3] + e[4] * e[0] * e[21] + e[4] * e[1] * e[22] + e[4] * e[20] * e[5] + e[4] * e[2] * e[23] + e[22] * e[0] * e[3] + e[22] * e[2] * e[5] + e[7] * e[18] * e[6] + e[7] * e[0] * e[24] + e[7] * e[1] * e[25] + e[7] * e[20] * e[8] + e[7] * e[2] * e[26] + e[25] * e[0] * e[6] + e[25] * e[2] * e[8] + e[1] * e[18] * e[0] + e[1] * e[20] * e[2] - 1.*e[1] * e[21] * e[3] - 1.*e[1] * e[26] * e[8] - 1.*e[1] * e[23] * e[5] - 1.*e[1] * e[24] * e[6] + .5000000000*e[19] * ep2[4] + .5000000000*e[19] * ep2[0] - .5000000000*e[19] * ep2[6] - .5000000000*e[19] * ep2[5] + 1.500000000*e[19] * ep2[1] + .5000000000*e[19] * ep2[7] - .5000000000*e[19] * ep2[3] + .5000000000*e[19] * ep2[2] - .5000000000*e[19] * ep2[8];
		A[166] = -.5000000000*e[7] * ep2[0] + e[4] * e[5] * e[8] + .5000000000*ep2[4] * e[7] - .5000000000*e[7] * ep2[2] + .5000000000*e[7] * ep2[8] - .5000000000*e[7] * ep2[5] + .5000000000*e[7] * ep2[6] + e[1] * e[0] * e[6] + .5000000000*ep3[7] + e[4] * e[3] * e[6] + e[1] * e[2] * e[8] - .5000000000*e[7] * ep2[3] + .5000000000*ep2[1] * e[7];
		A[53] = -1.*e[1] * e[32] * e[23] - 1.*e[19] * e[32] * e[5] - 1.*e[19] * e[33] * e[6] - 1.*e[19] * e[30] * e[3] - 1.*e[19] * e[35] * e[8] - 1.*e[28] * e[21] * e[3] - 1.*e[28] * e[26] * e[8] - 1.*e[28] * e[23] * e[5] - 1.*e[28] * e[24] * e[6] + e[7] * e[27] * e[24] + e[7] * e[18] * e[33] + e[7] * e[29] * e[26] + e[7] * e[20] * e[35] + e[22] * e[27] * e[3] + e[22] * e[0] * e[30] + e[22] * e[29] * e[5] + e[22] * e[2] * e[32] + e[31] * e[18] * e[3] + e[31] * e[0] * e[21] + e[31] * e[20] * e[5] + e[31] * e[2] * e[23] + e[25] * e[27] * e[6] + e[25] * e[0] * e[33] + e[25] * e[28] * e[7] + e[25] * e[1] * e[34] + e[25] * e[29] * e[8] + e[25] * e[2] * e[35] + e[34] * e[18] * e[6] + e[34] * e[0] * e[24] + e[34] * e[19] * e[7] + e[34] * e[20] * e[8] + e[34] * e[2] * e[26] + e[1] * e[27] * e[18] + 3.*e[1] * e[28] * e[19] + e[1] * e[29] * e[20] + e[19] * e[27] * e[0] + e[19] * e[29] * e[2] + e[28] * e[18] * e[0] + e[28] * e[20] * e[2] + e[4] * e[27] * e[21] + e[4] * e[18] * e[30] + e[4] * e[28] * e[22] + e[4] * e[19] * e[31] + e[4] * e[29] * e[23] + e[4] * e[20] * e[32] - 1.*e[1] * e[33] * e[24] - 1.*e[1] * e[30] * e[21] - 1.*e[1] * e[35] * e[26] + e[1] * e[31] * e[22];
		A[167] = e[10] * e[27] * e[15] + e[10] * e[9] * e[33] + e[10] * e[29] * e[17] + e[10] * e[11] * e[35] + e[10] * e[28] * e[16] + e[28] * e[11] * e[17] + e[28] * e[9] * e[15] + e[13] * e[30] * e[15] + e[13] * e[12] * e[33] + e[13] * e[32] * e[17] + e[13] * e[14] * e[35] + e[13] * e[31] * e[16] + e[31] * e[14] * e[17] + e[31] * e[12] * e[15] + e[16] * e[33] * e[15] + e[16] * e[35] * e[17] - 1.*e[16] * e[27] * e[9] - 1.*e[16] * e[30] * e[12] - 1.*e[16] * e[32] * e[14] - 1.*e[16] * e[29] * e[11] + .5000000000*ep2[10] * e[34] + 1.500000000*e[34] * ep2[16] - .5000000000*e[34] * ep2[9] - .5000000000*e[34] * ep2[11] - .5000000000*e[34] * ep2[12] + .5000000000*e[34] * ep2[15] + .5000000000*e[34] * ep2[17] - .5000000000*e[34] * ep2[14] + .5000000000*e[34] * ep2[13];
		A[50] = .5000000000*e[19] * ep2[18] + .5000000000*e[19] * ep2[25] + .5000000000*e[19] * ep2[22] + e[25] * e[20] * e[26] - .5000000000*e[19] * ep2[21] + .5000000000*e[19] * ep2[20] - .5000000000*e[19] * ep2[26] - .5000000000*e[19] * ep2[23] - .5000000000*e[19] * ep2[24] + .5000000000*ep3[19] + e[22] * e[20] * e[23] + e[25] * e[18] * e[24] + e[22] * e[18] * e[21];
		A[160] = .5000000000*e[34] * ep2[33] + .5000000000*e[34] * ep2[35] - .5000000000*e[34] * ep2[27] - .5000000000*e[34] * ep2[32] - .5000000000*e[34] * ep2[29] - .5000000000*e[34] * ep2[30] + .5000000000*ep2[28] * e[34] + e[31] * e[30] * e[33] + e[31] * e[32] * e[35] + e[28] * e[27] * e[33] + .5000000000*ep3[34] + e[28] * e[29] * e[35] + .5000000000*ep2[31] * e[34];
		A[51] = e[4] * e[28] * e[13] + e[4] * e[10] * e[31] + e[7] * e[27] * e[15] + e[7] * e[9] * e[33] + e[7] * e[29] * e[17] + e[7] * e[11] * e[35] + e[7] * e[28] * e[16] + e[7] * e[10] * e[34] + e[1] * e[27] * e[9] + e[1] * e[29] * e[11] + 3.*e[1] * e[28] * e[10] + e[10] * e[27] * e[0] - 1.*e[10] * e[32] * e[5] - 1.*e[10] * e[33] * e[6] - 1.*e[10] * e[30] * e[3] - 1.*e[10] * e[35] * e[8] + e[10] * e[29] * e[2] + e[13] * e[27] * e[3] + e[13] * e[0] * e[30] + e[13] * e[1] * e[31] + e[13] * e[29] * e[5] + e[13] * e[2] * e[32] + e[28] * e[11] * e[2] - 1.*e[28] * e[15] * e[6] + e[28] * e[9] * e[0] - 1.*e[28] * e[14] * e[5] - 1.*e[28] * e[12] * e[3] - 1.*e[28] * e[17] * e[8] + e[31] * e[9] * e[3] + e[31] * e[0] * e[12] + e[31] * e[11] * e[5] + e[31] * e[2] * e[14] + e[16] * e[27] * e[6] + e[16] * e[0] * e[33] + e[16] * e[1] * e[34] + e[16] * e[29] * e[8] + e[16] * e[2] * e[35] - 1.*e[1] * e[30] * e[12] - 1.*e[1] * e[32] * e[14] - 1.*e[1] * e[33] * e[15] - 1.*e[1] * e[35] * e[17] + e[34] * e[9] * e[6] + e[34] * e[0] * e[15] + e[34] * e[11] * e[8] + e[34] * e[2] * e[17] + e[4] * e[27] * e[12] + e[4] * e[9] * e[30] + e[4] * e[29] * e[14] + e[4] * e[11] * e[32];
		A[161] = e[4] * e[30] * e[33] + e[4] * e[32] * e[35] + e[4] * e[31] * e[34] + e[31] * e[30] * e[6] + e[31] * e[3] * e[33] + e[31] * e[32] * e[8] + e[31] * e[5] * e[35] + e[28] * e[27] * e[6] + e[28] * e[0] * e[33] + e[28] * e[29] * e[8] + e[28] * e[2] * e[35] + e[34] * e[33] * e[6] + e[34] * e[35] * e[8] - 1.*e[34] * e[27] * e[0] - 1.*e[34] * e[32] * e[5] - 1.*e[34] * e[30] * e[3] - 1.*e[34] * e[29] * e[2] + e[1] * e[27] * e[33] + e[1] * e[29] * e[35] + e[1] * e[28] * e[34] + .5000000000*ep2[31] * e[7] - .5000000000*e[7] * ep2[27] - .5000000000*e[7] * ep2[32] + .5000000000*e[7] * ep2[28] - .5000000000*e[7] * ep2[29] + .5000000000*e[7] * ep2[33] - .5000000000*e[7] * ep2[30] + 1.500000000*e[7] * ep2[34] + .5000000000*e[7] * ep2[35];
		A[48] = -.5000000000*e[10] * ep2[14] - .5000000000*e[10] * ep2[17] - .5000000000*e[10] * ep2[15] + e[13] * e[11] * e[14] + e[16] * e[11] * e[17] + .5000000000*e[10] * ep2[13] + e[13] * e[9] * e[12] - .5000000000*e[10] * ep2[12] + .5000000000*ep3[10] + e[16] * e[9] * e[15] + .5000000000*e[10] * ep2[16] + .5000000000*e[10] * ep2[11] + .5000000000*e[10] * ep2[9];
		A[162] = e[22] * e[32] * e[35] + e[22] * e[31] * e[34] + e[31] * e[30] * e[24] + e[31] * e[21] * e[33] + e[31] * e[32] * e[26] + e[31] * e[23] * e[35] + e[34] * e[33] * e[24] + e[34] * e[35] * e[26] - 1.*e[34] * e[27] * e[18] - 1.*e[34] * e[30] * e[21] - 1.*e[34] * e[29] * e[20] - 1.*e[34] * e[32] * e[23] + e[19] * e[27] * e[33] + e[19] * e[29] * e[35] + e[19] * e[28] * e[34] + e[28] * e[27] * e[24] + e[28] * e[18] * e[33] + e[28] * e[29] * e[26] + e[28] * e[20] * e[35] + e[22] * e[30] * e[33] + .5000000000*ep2[28] * e[25] + .5000000000*ep2[31] * e[25] + .5000000000*e[25] * ep2[33] + .5000000000*e[25] * ep2[35] + 1.500000000*e[25] * ep2[34] - .5000000000*e[25] * ep2[27] - .5000000000*e[25] * ep2[32] - .5000000000*e[25] * ep2[29] - .5000000000*e[25] * ep2[30];
		A[49] = -1.*e[19] * e[35] * e[26] - 1.*e[19] * e[32] * e[23] + e[19] * e[27] * e[18] + e[19] * e[29] * e[20] + e[22] * e[27] * e[21] + e[22] * e[18] * e[30] + e[22] * e[19] * e[31] + e[22] * e[29] * e[23] + e[22] * e[20] * e[32] + e[31] * e[18] * e[21] + e[31] * e[20] * e[23] + e[25] * e[27] * e[24] + e[25] * e[18] * e[33] + e[25] * e[19] * e[34] + e[25] * e[29] * e[26] + e[25] * e[20] * e[35] + e[34] * e[18] * e[24] + e[34] * e[20] * e[26] - 1.*e[19] * e[33] * e[24] - 1.*e[19] * e[30] * e[21] + 1.500000000*e[28] * ep2[19] + .5000000000*e[28] * ep2[18] + .5000000000*e[28] * ep2[20] + .5000000000*e[28] * ep2[22] + .5000000000*e[28] * ep2[25] - .5000000000*e[28] * ep2[26] - .5000000000*e[28] * ep2[23] - .5000000000*e[28] * ep2[24] - .5000000000*e[28] * ep2[21];
		A[163] = e[10] * e[27] * e[33] + e[10] * e[29] * e[35] + e[10] * e[28] * e[34] + e[34] * e[33] * e[15] + e[34] * e[35] * e[17] + e[28] * e[27] * e[15] + e[28] * e[9] * e[33] + e[28] * e[29] * e[17] + e[28] * e[11] * e[35] - 1.*e[34] * e[27] * e[9] - 1.*e[34] * e[30] * e[12] + e[34] * e[31] * e[13] - 1.*e[34] * e[32] * e[14] - 1.*e[34] * e[29] * e[11] + e[31] * e[30] * e[15] + e[31] * e[12] * e[33] + e[31] * e[32] * e[17] + e[31] * e[14] * e[35] + e[13] * e[30] * e[33] + e[13] * e[32] * e[35] - .5000000000*e[16] * ep2[27] - .5000000000*e[16] * ep2[32] + .5000000000*e[16] * ep2[28] - .5000000000*e[16] * ep2[29] + .5000000000*e[16] * ep2[31] + .5000000000*e[16] * ep2[33] - .5000000000*e[16] * ep2[30] + 1.500000000*e[16] * ep2[34] + .5000000000*e[16] * ep2[35];
		A[63] = e[29] * e[32] * e[14] - 1.*e[29] * e[33] * e[15] - 1.*e[29] * e[34] * e[16] + e[32] * e[27] * e[12] + e[32] * e[9] * e[30] + e[32] * e[28] * e[13] + e[32] * e[10] * e[31] + e[14] * e[27] * e[30] + e[14] * e[28] * e[31] + e[17] * e[27] * e[33] + e[17] * e[28] * e[34] + e[35] * e[27] * e[15] + e[35] * e[9] * e[33] + e[35] * e[29] * e[17] + e[35] * e[28] * e[16] + e[35] * e[10] * e[34] + e[29] * e[27] * e[9] + e[29] * e[28] * e[10] - 1.*e[29] * e[30] * e[12] - 1.*e[29] * e[31] * e[13] + .5000000000*e[11] * ep2[27] + 1.500000000*e[11] * ep2[29] + .5000000000*e[11] * ep2[28] + .5000000000*e[11] * ep2[32] - .5000000000*e[11] * ep2[31] - .5000000000*e[11] * ep2[33] - .5000000000*e[11] * ep2[30] - .5000000000*e[11] * ep2[34] + .5000000000*e[11] * ep2[35];
		A[173] = e[1] * e[20] * e[35] + e[19] * e[27] * e[6] + e[19] * e[0] * e[33] + e[19] * e[28] * e[7] + e[19] * e[29] * e[8] + e[19] * e[2] * e[35] + e[28] * e[18] * e[6] + e[28] * e[0] * e[24] + e[28] * e[20] * e[8] + e[28] * e[2] * e[26] + e[4] * e[30] * e[24] + e[4] * e[21] * e[33] + e[4] * e[31] * e[25] + e[4] * e[22] * e[34] + e[4] * e[32] * e[26] + e[4] * e[23] * e[35] - 1.*e[7] * e[27] * e[18] + e[7] * e[33] * e[24] - 1.*e[7] * e[30] * e[21] - 1.*e[7] * e[29] * e[20] + e[7] * e[35] * e[26] + e[7] * e[31] * e[22] - 1.*e[7] * e[32] * e[23] - 1.*e[25] * e[27] * e[0] - 1.*e[25] * e[32] * e[5] - 1.*e[25] * e[30] * e[3] - 1.*e[25] * e[29] * e[2] - 1.*e[34] * e[21] * e[3] - 1.*e[34] * e[20] * e[2] - 1.*e[34] * e[18] * e[0] - 1.*e[34] * e[23] * e[5] + e[22] * e[30] * e[6] + e[22] * e[3] * e[33] + e[22] * e[32] * e[8] + e[22] * e[5] * e[35] + e[31] * e[21] * e[6] + e[31] * e[3] * e[24] + e[31] * e[23] * e[8] + e[31] * e[5] * e[26] + e[34] * e[26] * e[8] + e[1] * e[27] * e[24] + e[1] * e[18] * e[33] + e[1] * e[28] * e[25] + e[1] * e[19] * e[34] + e[1] * e[29] * e[26] + e[34] * e[24] * e[6] + e[25] * e[33] * e[6] + 3.*e[25] * e[34] * e[7] + e[25] * e[35] * e[8];
		A[62] = .5000000000*e[20] * ep2[27] + 1.500000000*e[20] * ep2[29] + .5000000000*e[20] * ep2[28] + .5000000000*e[20] * ep2[32] + .5000000000*e[20] * ep2[35] - .5000000000*e[20] * ep2[31] - .5000000000*e[20] * ep2[33] - .5000000000*e[20] * ep2[30] - .5000000000*e[20] * ep2[34] + e[29] * e[27] * e[18] + e[29] * e[28] * e[19] + e[23] * e[27] * e[30] + e[23] * e[29] * e[32] + e[23] * e[28] * e[31] + e[32] * e[27] * e[21] + e[32] * e[18] * e[30] + e[32] * e[28] * e[22] + e[32] * e[19] * e[31] + e[26] * e[27] * e[33] + e[26] * e[29] * e[35] + e[26] * e[28] * e[34] + e[35] * e[27] * e[24] + e[35] * e[18] * e[33] + e[35] * e[28] * e[25] + e[35] * e[19] * e[34] - 1.*e[29] * e[33] * e[24] - 1.*e[29] * e[30] * e[21] - 1.*e[29] * e[31] * e[22] - 1.*e[29] * e[34] * e[25];
		A[172] = e[19] * e[1] * e[7] + e[19] * e[0] * e[6] + e[19] * e[2] * e[8] + e[4] * e[21] * e[6] + e[4] * e[3] * e[24] + e[4] * e[22] * e[7] + e[4] * e[23] * e[8] + e[4] * e[5] * e[26] + e[22] * e[3] * e[6] + e[22] * e[5] * e[8] + e[7] * e[24] * e[6] + e[7] * e[26] * e[8] + e[1] * e[18] * e[6] + e[1] * e[0] * e[24] + e[1] * e[20] * e[8] + e[1] * e[2] * e[26] - 1.*e[7] * e[21] * e[3] - 1.*e[7] * e[20] * e[2] - 1.*e[7] * e[18] * e[0] - 1.*e[7] * e[23] * e[5] + .5000000000*e[25] * ep2[4] - .5000000000*e[25] * ep2[0] + .5000000000*e[25] * ep2[6] - .5000000000*e[25] * ep2[5] + .5000000000*e[25] * ep2[1] + 1.500000000*e[25] * ep2[7] - .5000000000*e[25] * ep2[3] - .5000000000*e[25] * ep2[2] + .5000000000*e[25] * ep2[8];
		A[61] = e[5] * e[27] * e[30] + e[5] * e[29] * e[32] + e[5] * e[28] * e[31] + e[32] * e[27] * e[3] + e[32] * e[0] * e[30] + e[32] * e[28] * e[4] + e[32] * e[1] * e[31] + e[8] * e[27] * e[33] + e[8] * e[29] * e[35] + e[8] * e[28] * e[34] + e[29] * e[27] * e[0] + e[29] * e[28] * e[1] + e[35] * e[27] * e[6] + e[35] * e[0] * e[33] + e[35] * e[28] * e[7] + e[35] * e[1] * e[34] - 1.*e[29] * e[34] * e[7] - 1.*e[29] * e[33] * e[6] - 1.*e[29] * e[30] * e[3] - 1.*e[29] * e[31] * e[4] + .5000000000*e[2] * ep2[27] + 1.500000000*e[2] * ep2[29] + .5000000000*e[2] * ep2[28] + .5000000000*e[2] * ep2[32] - .5000000000*e[2] * ep2[31] - .5000000000*e[2] * ep2[33] - .5000000000*e[2] * ep2[30] - .5000000000*e[2] * ep2[34] + .5000000000*e[2] * ep2[35];
		A[175] = e[13] * e[12] * e[6] + e[13] * e[3] * e[15] + e[13] * e[4] * e[16] + e[13] * e[14] * e[8] + e[13] * e[5] * e[17] + e[16] * e[15] * e[6] + e[16] * e[17] * e[8] + e[1] * e[11] * e[17] + e[1] * e[9] * e[15] + e[1] * e[10] * e[16] + e[4] * e[14] * e[17] + e[4] * e[12] * e[15] + e[10] * e[9] * e[6] + e[10] * e[0] * e[15] + e[10] * e[11] * e[8] + e[10] * e[2] * e[17] - 1.*e[16] * e[11] * e[2] - 1.*e[16] * e[9] * e[0] - 1.*e[16] * e[14] * e[5] - 1.*e[16] * e[12] * e[3] + .5000000000*ep2[13] * e[7] + 1.500000000*ep2[16] * e[7] + .5000000000*e[7] * ep2[17] + .5000000000*e[7] * ep2[15] - .5000000000*e[7] * ep2[9] - .5000000000*e[7] * ep2[11] - .5000000000*e[7] * ep2[12] + .5000000000*e[7] * ep2[10] - .5000000000*e[7] * ep2[14];
		A[60] = .5000000000*e[29] * ep2[32] + .5000000000*e[29] * ep2[35] - .5000000000*e[29] * ep2[31] - .5000000000*e[29] * ep2[33] - .5000000000*e[29] * ep2[30] - .5000000000*e[29] * ep2[34] + e[32] * e[27] * e[30] + .5000000000*ep3[29] + .5000000000*e[29] * ep2[28] + e[35] * e[28] * e[34] + .5000000000*e[29] * ep2[27] + e[35] * e[27] * e[33] + e[32] * e[28] * e[31];
		A[174] = -1.*e[16] * e[21] * e[12] + e[10] * e[18] * e[15] + e[10] * e[9] * e[24] + e[10] * e[20] * e[17] + e[10] * e[11] * e[26] + e[19] * e[11] * e[17] + e[19] * e[9] * e[15] + e[19] * e[10] * e[16] + e[13] * e[21] * e[15] + e[13] * e[12] * e[24] + e[13] * e[23] * e[17] + e[13] * e[14] * e[26] + e[13] * e[22] * e[16] + e[22] * e[14] * e[17] + e[22] * e[12] * e[15] + e[16] * e[24] * e[15] + e[16] * e[26] * e[17] - 1.*e[16] * e[23] * e[14] - 1.*e[16] * e[20] * e[11] - 1.*e[16] * e[18] * e[9] + .5000000000*ep2[13] * e[25] + 1.500000000*e[25] * ep2[16] + .5000000000*e[25] * ep2[17] + .5000000000*e[25] * ep2[15] + .5000000000*ep2[10] * e[25] - .5000000000*e[25] * ep2[9] - .5000000000*e[25] * ep2[11] - .5000000000*e[25] * ep2[12] - .5000000000*e[25] * ep2[14];
		A[59] = e[19] * e[20] * e[2] + e[22] * e[18] * e[3] + e[22] * e[0] * e[21] + e[22] * e[19] * e[4] + e[22] * e[20] * e[5] + e[22] * e[2] * e[23] - 1.*e[19] * e[21] * e[3] - 1.*e[19] * e[26] * e[8] + e[19] * e[25] * e[7] - 1.*e[19] * e[23] * e[5] - 1.*e[19] * e[24] * e[6] + e[4] * e[18] * e[21] + e[4] * e[20] * e[23] + e[25] * e[18] * e[6] + e[25] * e[0] * e[24] + e[25] * e[20] * e[8] + e[25] * e[2] * e[26] + e[7] * e[18] * e[24] + e[7] * e[20] * e[26] + e[19] * e[18] * e[0] + 1.500000000*ep2[19] * e[1] + .5000000000*e[1] * ep2[22] + .5000000000*e[1] * ep2[18] + .5000000000*e[1] * ep2[20] + .5000000000*e[1] * ep2[25] - .5000000000*e[1] * ep2[26] - .5000000000*e[1] * ep2[23] - .5000000000*e[1] * ep2[24] - .5000000000*e[1] * ep2[21];
		A[169] = e[19] * e[27] * e[24] + e[19] * e[18] * e[33] + e[19] * e[28] * e[25] + e[19] * e[29] * e[26] + e[19] * e[20] * e[35] + e[28] * e[18] * e[24] + e[28] * e[20] * e[26] + e[22] * e[30] * e[24] + e[22] * e[21] * e[33] + e[22] * e[31] * e[25] + e[22] * e[32] * e[26] + e[22] * e[23] * e[35] + e[31] * e[21] * e[24] + e[31] * e[23] * e[26] + e[25] * e[33] * e[24] + e[25] * e[35] * e[26] - 1.*e[25] * e[27] * e[18] - 1.*e[25] * e[30] * e[21] - 1.*e[25] * e[29] * e[20] - 1.*e[25] * e[32] * e[23] - .5000000000*e[34] * ep2[18] - .5000000000*e[34] * ep2[23] - .5000000000*e[34] * ep2[20] - .5000000000*e[34] * ep2[21] + .5000000000*ep2[19] * e[34] + .5000000000*ep2[22] * e[34] + 1.500000000*e[34] * ep2[25] + .5000000000*e[34] * ep2[24] + .5000000000*e[34] * ep2[26];
		A[58] = e[16] * e[0] * e[6] + e[16] * e[2] * e[8] + e[1] * e[11] * e[2] - 1.*e[1] * e[15] * e[6] + e[1] * e[9] * e[0] - 1.*e[1] * e[14] * e[5] - 1.*e[1] * e[12] * e[3] - 1.*e[1] * e[17] * e[8] + e[4] * e[9] * e[3] + e[4] * e[0] * e[12] + e[4] * e[1] * e[13] + e[4] * e[11] * e[5] + e[4] * e[2] * e[14] + e[13] * e[0] * e[3] + e[13] * e[2] * e[5] + e[7] * e[9] * e[6] + e[7] * e[0] * e[15] + e[7] * e[1] * e[16] + e[7] * e[11] * e[8] + e[7] * e[2] * e[17] - .5000000000*e[10] * ep2[6] - .5000000000*e[10] * ep2[5] - .5000000000*e[10] * ep2[3] - .5000000000*e[10] * ep2[8] + 1.500000000*e[10] * ep2[1] + .5000000000*e[10] * ep2[0] + .5000000000*e[10] * ep2[2] + .5000000000*e[10] * ep2[4] + .5000000000*e[10] * ep2[7];
		A[168] = e[13] * e[14] * e[17] + e[13] * e[12] * e[15] + e[10] * e[9] * e[15] + .5000000000*e[16] * ep2[15] - .5000000000*e[16] * ep2[11] - .5000000000*e[16] * ep2[12] - .5000000000*e[16] * ep2[14] + e[10] * e[11] * e[17] + .5000000000*ep2[10] * e[16] + .5000000000*ep3[16] - .5000000000*e[16] * ep2[9] + .5000000000*e[16] * ep2[17] + .5000000000*ep2[13] * e[16];
		A[57] = e[10] * e[29] * e[20] + e[22] * e[27] * e[12] + e[22] * e[9] * e[30] + e[22] * e[29] * e[14] + e[22] * e[11] * e[32] + e[22] * e[10] * e[31] + e[31] * e[18] * e[12] + e[31] * e[9] * e[21] + e[31] * e[20] * e[14] + e[31] * e[11] * e[23] - 1.*e[10] * e[33] * e[24] - 1.*e[10] * e[30] * e[21] - 1.*e[10] * e[35] * e[26] - 1.*e[10] * e[32] * e[23] + e[10] * e[34] * e[25] + e[19] * e[27] * e[9] + e[19] * e[29] * e[11] + e[28] * e[18] * e[9] + e[28] * e[20] * e[11] + e[16] * e[27] * e[24] + e[16] * e[18] * e[33] + e[16] * e[28] * e[25] + e[16] * e[19] * e[34] + e[16] * e[29] * e[26] + e[16] * e[20] * e[35] - 1.*e[19] * e[30] * e[12] - 1.*e[19] * e[32] * e[14] - 1.*e[19] * e[33] * e[15] - 1.*e[19] * e[35] * e[17] - 1.*e[28] * e[23] * e[14] - 1.*e[28] * e[24] * e[15] - 1.*e[28] * e[26] * e[17] - 1.*e[28] * e[21] * e[12] + e[25] * e[27] * e[15] + e[25] * e[9] * e[33] + e[25] * e[29] * e[17] + e[25] * e[11] * e[35] + e[34] * e[18] * e[15] + e[34] * e[9] * e[24] + e[34] * e[20] * e[17] + e[34] * e[11] * e[26] + e[13] * e[27] * e[21] + e[13] * e[18] * e[30] + e[13] * e[28] * e[22] + e[13] * e[19] * e[31] + e[13] * e[29] * e[23] + e[13] * e[20] * e[32] + e[10] * e[27] * e[18] + 3.*e[10] * e[28] * e[19];
		A[171] = e[4] * e[30] * e[15] + e[4] * e[12] * e[33] + e[4] * e[32] * e[17] + e[4] * e[14] * e[35] + e[4] * e[31] * e[16] + e[4] * e[13] * e[34] + e[7] * e[33] * e[15] + e[7] * e[35] * e[17] + 3.*e[7] * e[34] * e[16] + e[1] * e[27] * e[15] + e[1] * e[9] * e[33] + e[1] * e[29] * e[17] + e[1] * e[11] * e[35] + e[1] * e[28] * e[16] + e[1] * e[10] * e[34] - 1.*e[16] * e[27] * e[0] - 1.*e[16] * e[32] * e[5] + e[16] * e[33] * e[6] - 1.*e[16] * e[30] * e[3] + e[16] * e[35] * e[8] - 1.*e[16] * e[29] * e[2] + e[13] * e[30] * e[6] + e[13] * e[3] * e[33] + e[13] * e[31] * e[7] + e[13] * e[32] * e[8] + e[13] * e[5] * e[35] - 1.*e[34] * e[11] * e[2] + e[34] * e[15] * e[6] - 1.*e[34] * e[9] * e[0] - 1.*e[34] * e[14] * e[5] - 1.*e[34] * e[12] * e[3] + e[34] * e[17] * e[8] + e[31] * e[12] * e[6] + e[31] * e[3] * e[15] + e[31] * e[14] * e[8] + e[31] * e[5] * e[17] - 1.*e[7] * e[27] * e[9] - 1.*e[7] * e[30] * e[12] + e[7] * e[28] * e[10] - 1.*e[7] * e[32] * e[14] + e[10] * e[27] * e[6] + e[10] * e[0] * e[33] + e[10] * e[29] * e[8] + e[10] * e[2] * e[35] + e[28] * e[9] * e[6] + e[28] * e[0] * e[15] + e[28] * e[11] * e[8] + e[28] * e[2] * e[17] - 1.*e[7] * e[29] * e[11];
		A[56] = e[22] * e[18] * e[12] + e[22] * e[9] * e[21] + e[22] * e[20] * e[14] + e[22] * e[11] * e[23] + e[22] * e[19] * e[13] + e[25] * e[18] * e[15] + e[25] * e[9] * e[24] + e[25] * e[20] * e[17] + e[25] * e[11] * e[26] + e[25] * e[19] * e[16] + e[16] * e[18] * e[24] + e[16] * e[20] * e[26] + e[13] * e[18] * e[21] + e[13] * e[20] * e[23] + e[19] * e[18] * e[9] + e[19] * e[20] * e[11] - 1.*e[19] * e[23] * e[14] - 1.*e[19] * e[24] * e[15] - 1.*e[19] * e[26] * e[17] - 1.*e[19] * e[21] * e[12] + .5000000000*e[10] * ep2[22] + .5000000000*e[10] * ep2[25] + 1.500000000*e[10] * ep2[19] + .5000000000*e[10] * ep2[18] + .5000000000*e[10] * ep2[20] - .5000000000*e[10] * ep2[26] - .5000000000*e[10] * ep2[23] - .5000000000*e[10] * ep2[24] - .5000000000*e[10] * ep2[21];
		A[170] = e[19] * e[20] * e[26] - .5000000000*e[25] * ep2[20] + e[22] * e[21] * e[24] + e[19] * e[18] * e[24] + .5000000000*ep2[22] * e[25] - .5000000000*e[25] * ep2[21] - .5000000000*e[25] * ep2[23] + .5000000000*ep2[19] * e[25] - .5000000000*e[25] * ep2[18] + .5000000000*e[25] * ep2[24] + .5000000000*e[25] * ep2[26] + .5000000000*ep3[25] + e[22] * e[23] * e[26];
		A[73] = -1.*e[20] * e[33] * e[6] - 1.*e[20] * e[30] * e[3] - 1.*e[20] * e[31] * e[4] - 1.*e[29] * e[21] * e[3] - 1.*e[29] * e[22] * e[4] - 1.*e[29] * e[25] * e[7] - 1.*e[29] * e[24] * e[6] + e[8] * e[27] * e[24] + e[8] * e[18] * e[33] + e[8] * e[28] * e[25] + e[8] * e[19] * e[34] + e[23] * e[27] * e[3] + e[23] * e[0] * e[30] + e[23] * e[28] * e[4] + e[23] * e[1] * e[31] + e[32] * e[18] * e[3] + e[32] * e[0] * e[21] + e[32] * e[19] * e[4] + e[32] * e[1] * e[22] + e[26] * e[27] * e[6] + e[26] * e[0] * e[33] + e[26] * e[28] * e[7] + e[26] * e[1] * e[34] + e[26] * e[29] * e[8] + e[26] * e[2] * e[35] + e[35] * e[18] * e[6] + e[35] * e[0] * e[24] + e[35] * e[19] * e[7] + e[35] * e[1] * e[25] + e[35] * e[20] * e[8] + e[2] * e[27] * e[18] + e[2] * e[28] * e[19] + 3.*e[2] * e[29] * e[20] + e[20] * e[27] * e[0] + e[20] * e[28] * e[1] + e[29] * e[18] * e[0] + e[29] * e[19] * e[1] + e[5] * e[27] * e[21] + e[5] * e[18] * e[30] + e[5] * e[28] * e[22] + e[5] * e[19] * e[31] + e[5] * e[29] * e[23] + e[5] * e[20] * e[32] - 1.*e[2] * e[33] * e[24] - 1.*e[2] * e[30] * e[21] - 1.*e[2] * e[31] * e[22] + e[2] * e[32] * e[23] - 1.*e[2] * e[34] * e[25] - 1.*e[20] * e[34] * e[7];
		A[72] = e[5] * e[18] * e[3] + e[5] * e[0] * e[21] + e[5] * e[19] * e[4] + e[5] * e[1] * e[22] + e[5] * e[2] * e[23] + e[23] * e[1] * e[4] + e[23] * e[0] * e[3] + e[8] * e[18] * e[6] + e[8] * e[0] * e[24] + e[8] * e[19] * e[7] + e[8] * e[1] * e[25] + e[8] * e[2] * e[26] + e[26] * e[1] * e[7] + e[26] * e[0] * e[6] + e[2] * e[18] * e[0] + e[2] * e[19] * e[1] - 1.*e[2] * e[21] * e[3] - 1.*e[2] * e[22] * e[4] - 1.*e[2] * e[25] * e[7] - 1.*e[2] * e[24] * e[6] - .5000000000*e[20] * ep2[4] + .5000000000*e[20] * ep2[0] - .5000000000*e[20] * ep2[6] + .5000000000*e[20] * ep2[5] + .5000000000*e[20] * ep2[1] - .5000000000*e[20] * ep2[7] - .5000000000*e[20] * ep2[3] + 1.500000000*e[20] * ep2[2] + .5000000000*e[20] * ep2[8];
		A[75] = e[14] * e[9] * e[3] + e[14] * e[0] * e[12] + e[14] * e[10] * e[4] + e[14] * e[1] * e[13] + e[14] * e[11] * e[5] + e[17] * e[9] * e[6] + e[17] * e[0] * e[15] + e[17] * e[10] * e[7] + e[17] * e[1] * e[16] + e[17] * e[11] * e[8] + e[8] * e[9] * e[15] + e[8] * e[10] * e[16] + e[5] * e[9] * e[12] + e[5] * e[10] * e[13] + e[11] * e[9] * e[0] + e[11] * e[10] * e[1] - 1.*e[11] * e[13] * e[4] - 1.*e[11] * e[16] * e[7] - 1.*e[11] * e[15] * e[6] - 1.*e[11] * e[12] * e[3] + .5000000000*e[2] * ep2[14] + .5000000000*e[2] * ep2[17] + 1.500000000*e[2] * ep2[11] + .5000000000*e[2] * ep2[9] + .5000000000*e[2] * ep2[10] - .5000000000*e[2] * ep2[16] - .5000000000*e[2] * ep2[12] - .5000000000*e[2] * ep2[15] - .5000000000*e[2] * ep2[13];
		A[74] = e[14] * e[18] * e[12] + e[14] * e[9] * e[21] + e[14] * e[11] * e[23] + e[14] * e[19] * e[13] + e[14] * e[10] * e[22] + e[23] * e[9] * e[12] + e[23] * e[10] * e[13] + e[17] * e[18] * e[15] + e[17] * e[9] * e[24] + e[17] * e[11] * e[26] + e[17] * e[19] * e[16] + e[17] * e[10] * e[25] + e[26] * e[9] * e[15] + e[26] * e[10] * e[16] - 1.*e[11] * e[24] * e[15] - 1.*e[11] * e[25] * e[16] + e[11] * e[18] * e[9] - 1.*e[11] * e[21] * e[12] + e[11] * e[19] * e[10] - 1.*e[11] * e[22] * e[13] + 1.500000000*e[20] * ep2[11] + .5000000000*e[20] * ep2[9] + .5000000000*e[20] * ep2[10] + .5000000000*e[20] * ep2[14] + .5000000000*e[20] * ep2[17] - .5000000000*e[20] * ep2[16] - .5000000000*e[20] * ep2[12] - .5000000000*e[20] * ep2[15] - .5000000000*e[20] * ep2[13];
		A[77] = e[23] * e[10] * e[31] + e[32] * e[18] * e[12] + e[32] * e[9] * e[21] + e[32] * e[19] * e[13] + e[32] * e[10] * e[22] - 1.*e[11] * e[33] * e[24] - 1.*e[11] * e[30] * e[21] + e[11] * e[35] * e[26] - 1.*e[11] * e[31] * e[22] - 1.*e[11] * e[34] * e[25] + e[20] * e[27] * e[9] + e[20] * e[28] * e[10] + e[29] * e[18] * e[9] + e[29] * e[19] * e[10] + e[17] * e[27] * e[24] + e[17] * e[18] * e[33] + e[17] * e[28] * e[25] + e[17] * e[19] * e[34] + e[17] * e[29] * e[26] + e[17] * e[20] * e[35] - 1.*e[20] * e[30] * e[12] - 1.*e[20] * e[31] * e[13] - 1.*e[20] * e[33] * e[15] - 1.*e[20] * e[34] * e[16] - 1.*e[29] * e[24] * e[15] - 1.*e[29] * e[25] * e[16] - 1.*e[29] * e[21] * e[12] - 1.*e[29] * e[22] * e[13] + e[26] * e[27] * e[15] + e[26] * e[9] * e[33] + e[26] * e[28] * e[16] + e[26] * e[10] * e[34] + e[35] * e[18] * e[15] + e[35] * e[9] * e[24] + e[35] * e[19] * e[16] + e[35] * e[10] * e[25] + e[14] * e[27] * e[21] + e[14] * e[18] * e[30] + e[14] * e[28] * e[22] + e[14] * e[19] * e[31] + e[14] * e[29] * e[23] + e[14] * e[20] * e[32] + e[11] * e[27] * e[18] + e[11] * e[28] * e[19] + 3.*e[11] * e[29] * e[20] + e[23] * e[27] * e[12] + e[23] * e[9] * e[30] + e[23] * e[11] * e[32] + e[23] * e[28] * e[13];
		A[76] = e[23] * e[18] * e[12] + e[23] * e[9] * e[21] + e[23] * e[20] * e[14] + e[23] * e[19] * e[13] + e[23] * e[10] * e[22] + e[26] * e[18] * e[15] + e[26] * e[9] * e[24] + e[26] * e[20] * e[17] + e[26] * e[19] * e[16] + e[26] * e[10] * e[25] + e[17] * e[19] * e[25] + e[17] * e[18] * e[24] + e[14] * e[19] * e[22] + e[14] * e[18] * e[21] + e[20] * e[18] * e[9] + e[20] * e[19] * e[10] - 1.*e[20] * e[24] * e[15] - 1.*e[20] * e[25] * e[16] - 1.*e[20] * e[21] * e[12] - 1.*e[20] * e[22] * e[13] + .5000000000*e[11] * ep2[23] + .5000000000*e[11] * ep2[26] + .5000000000*e[11] * ep2[19] + .5000000000*e[11] * ep2[18] + 1.500000000*e[11] * ep2[20] - .5000000000*e[11] * ep2[22] - .5000000000*e[11] * ep2[24] - .5000000000*e[11] * ep2[21] - .5000000000*e[11] * ep2[25];
		A[79] = -1.*e[20] * e[21] * e[3] + e[20] * e[26] * e[8] - 1.*e[20] * e[22] * e[4] - 1.*e[20] * e[25] * e[7] - 1.*e[20] * e[24] * e[6] + e[5] * e[19] * e[22] + e[5] * e[18] * e[21] + e[26] * e[18] * e[6] + e[26] * e[0] * e[24] + e[26] * e[19] * e[7] + e[26] * e[1] * e[25] + e[8] * e[19] * e[25] + e[8] * e[18] * e[24] + e[20] * e[18] * e[0] + e[20] * e[19] * e[1] + e[23] * e[18] * e[3] + e[23] * e[0] * e[21] + e[23] * e[19] * e[4] + e[23] * e[1] * e[22] + e[23] * e[20] * e[5] + 1.500000000*ep2[20] * e[2] + .5000000000*e[2] * ep2[23] + .5000000000*e[2] * ep2[19] + .5000000000*e[2] * ep2[18] + .5000000000*e[2] * ep2[26] - .5000000000*e[2] * ep2[22] - .5000000000*e[2] * ep2[24] - .5000000000*e[2] * ep2[21] - .5000000000*e[2] * ep2[25];
		A[78] = -1.*e[2] * e[15] * e[6] + e[2] * e[9] * e[0] - 1.*e[2] * e[12] * e[3] + e[5] * e[9] * e[3] + e[5] * e[0] * e[12] + e[5] * e[10] * e[4] + e[5] * e[1] * e[13] + e[5] * e[2] * e[14] + e[14] * e[1] * e[4] + e[14] * e[0] * e[3] + e[8] * e[9] * e[6] + e[8] * e[0] * e[15] + e[8] * e[10] * e[7] + e[8] * e[1] * e[16] + e[8] * e[2] * e[17] + e[17] * e[1] * e[7] + e[17] * e[0] * e[6] + e[2] * e[10] * e[1] - 1.*e[2] * e[13] * e[4] - 1.*e[2] * e[16] * e[7] + .5000000000*e[11] * ep2[1] + .5000000000*e[11] * ep2[0] + 1.500000000*e[11] * ep2[2] + .5000000000*e[11] * ep2[5] + .5000000000*e[11] * ep2[8] - .5000000000*e[11] * ep2[4] - .5000000000*e[11] * ep2[6] - .5000000000*e[11] * ep2[7] - .5000000000*e[11] * ep2[3];
		A[64] = e[5] * e[19] * e[13] + e[5] * e[10] * e[22] + e[8] * e[18] * e[15] + e[8] * e[9] * e[24] + e[8] * e[20] * e[17] + e[8] * e[11] * e[26] + e[8] * e[19] * e[16] + e[8] * e[10] * e[25] + e[2] * e[18] * e[9] + e[2] * e[19] * e[10] - 1.*e[11] * e[21] * e[3] - 1.*e[11] * e[22] * e[4] - 1.*e[11] * e[25] * e[7] - 1.*e[11] * e[24] * e[6] + e[14] * e[18] * e[3] + e[14] * e[0] * e[21] + e[14] * e[19] * e[4] + e[14] * e[1] * e[22] + e[14] * e[2] * e[23] - 1.*e[20] * e[13] * e[4] - 1.*e[20] * e[16] * e[7] - 1.*e[20] * e[15] * e[6] - 1.*e[20] * e[12] * e[3] + e[23] * e[9] * e[3] + e[23] * e[0] * e[12] + e[23] * e[10] * e[4] + e[23] * e[1] * e[13] + e[17] * e[18] * e[6] + e[17] * e[0] * e[24] + e[17] * e[19] * e[7] + e[17] * e[1] * e[25] + e[17] * e[2] * e[26] - 1.*e[2] * e[24] * e[15] - 1.*e[2] * e[25] * e[16] - 1.*e[2] * e[21] * e[12] - 1.*e[2] * e[22] * e[13] + e[26] * e[9] * e[6] + e[26] * e[0] * e[15] + e[26] * e[10] * e[7] + e[26] * e[1] * e[16] + e[11] * e[18] * e[0] + e[11] * e[19] * e[1] + 3.*e[11] * e[20] * e[2] + e[20] * e[9] * e[0] + e[20] * e[10] * e[1] + e[5] * e[18] * e[12] + e[5] * e[9] * e[21] + e[5] * e[20] * e[14] + e[5] * e[11] * e[23];
		A[65] = e[32] * e[1] * e[4] + e[32] * e[0] * e[3] + e[8] * e[27] * e[6] + e[8] * e[0] * e[33] + e[8] * e[28] * e[7] + e[8] * e[1] * e[34] + e[35] * e[1] * e[7] + e[35] * e[0] * e[6] + e[2] * e[27] * e[0] + e[2] * e[28] * e[1] - 1.*e[2] * e[34] * e[7] + e[2] * e[32] * e[5] - 1.*e[2] * e[33] * e[6] - 1.*e[2] * e[30] * e[3] + e[2] * e[35] * e[8] - 1.*e[2] * e[31] * e[4] + e[5] * e[27] * e[3] + e[5] * e[0] * e[30] + e[5] * e[28] * e[4] + e[5] * e[1] * e[31] + 1.500000000*e[29] * ep2[2] - .5000000000*e[29] * ep2[4] + .5000000000*e[29] * ep2[0] - .5000000000*e[29] * ep2[6] + .5000000000*e[29] * ep2[5] + .5000000000*e[29] * ep2[1] - .5000000000*e[29] * ep2[7] - .5000000000*e[29] * ep2[3] + .5000000000*e[29] * ep2[8];
		A[66] = e[5] * e[0] * e[3] + e[8] * e[1] * e[7] + e[8] * e[0] * e[6] + e[5] * e[1] * e[4] - .5000000000*e[2] * ep2[4] + .5000000000*ep3[2] + .5000000000*e[2] * ep2[1] - .5000000000*e[2] * ep2[3] + .5000000000*e[2] * ep2[0] + .5000000000*e[2] * ep2[8] + .5000000000*e[2] * ep2[5] - .5000000000*e[2] * ep2[6] - .5000000000*e[2] * ep2[7];
		A[67] = e[35] * e[9] * e[15] + e[35] * e[10] * e[16] - 1.*e[11] * e[30] * e[12] - 1.*e[11] * e[31] * e[13] - 1.*e[11] * e[33] * e[15] - 1.*e[11] * e[34] * e[16] + e[11] * e[27] * e[9] + e[11] * e[28] * e[10] + e[14] * e[27] * e[12] + e[14] * e[9] * e[30] + e[14] * e[11] * e[32] + e[14] * e[28] * e[13] + e[14] * e[10] * e[31] + e[32] * e[9] * e[12] + e[32] * e[10] * e[13] + e[17] * e[27] * e[15] + e[17] * e[9] * e[33] + e[17] * e[11] * e[35] + e[17] * e[28] * e[16] + e[17] * e[10] * e[34] + 1.500000000*e[29] * ep2[11] - .5000000000*e[29] * ep2[16] + .5000000000*e[29] * ep2[9] - .5000000000*e[29] * ep2[12] - .5000000000*e[29] * ep2[15] + .5000000000*e[29] * ep2[17] + .5000000000*e[29] * ep2[10] + .5000000000*e[29] * ep2[14] - .5000000000*e[29] * ep2[13];
		A[68] = e[14] * e[9] * e[12] + e[17] * e[10] * e[16] + e[17] * e[9] * e[15] + .5000000000*ep3[11] + e[14] * e[10] * e[13] + .5000000000*e[11] * ep2[10] - .5000000000*e[11] * ep2[15] + .5000000000*e[11] * ep2[14] - .5000000000*e[11] * ep2[13] - .5000000000*e[11] * ep2[12] + .5000000000*e[11] * ep2[9] - .5000000000*e[11] * ep2[16] + .5000000000*e[11] * ep2[17];
		A[69] = e[20] * e[27] * e[18] + e[20] * e[28] * e[19] + e[23] * e[27] * e[21] + e[23] * e[18] * e[30] + e[23] * e[28] * e[22] + e[23] * e[19] * e[31] + e[23] * e[20] * e[32] + e[32] * e[19] * e[22] + e[32] * e[18] * e[21] + e[26] * e[27] * e[24] + e[26] * e[18] * e[33] + e[26] * e[28] * e[25] + e[26] * e[19] * e[34] + e[26] * e[20] * e[35] + e[35] * e[19] * e[25] + e[35] * e[18] * e[24] - 1.*e[20] * e[33] * e[24] - 1.*e[20] * e[30] * e[21] - 1.*e[20] * e[31] * e[22] - 1.*e[20] * e[34] * e[25] + .5000000000*e[29] * ep2[23] + .5000000000*e[29] * ep2[26] - .5000000000*e[29] * ep2[22] - .5000000000*e[29] * ep2[24] - .5000000000*e[29] * ep2[21] - .5000000000*e[29] * ep2[25] + 1.500000000*e[29] * ep2[20] + .5000000000*e[29] * ep2[19] + .5000000000*e[29] * ep2[18];
		A[70] = .5000000000*e[20] * ep2[26] + .5000000000*e[20] * ep2[18] + .5000000000*ep3[20] + .5000000000*e[20] * ep2[19] + e[26] * e[18] * e[24] + .5000000000*e[20] * ep2[23] - .5000000000*e[20] * ep2[25] + e[23] * e[19] * e[22] - .5000000000*e[20] * ep2[24] - .5000000000*e[20] * ep2[21] - .5000000000*e[20] * ep2[22] + e[23] * e[18] * e[21] + e[26] * e[19] * e[25];
		A[71] = e[8] * e[28] * e[16] + e[8] * e[10] * e[34] + e[2] * e[27] * e[9] + 3.*e[2] * e[29] * e[11] + e[2] * e[28] * e[10] + e[11] * e[27] * e[0] - 1.*e[11] * e[34] * e[7] - 1.*e[11] * e[33] * e[6] - 1.*e[11] * e[30] * e[3] + e[11] * e[28] * e[1] - 1.*e[11] * e[31] * e[4] + e[14] * e[27] * e[3] + e[14] * e[0] * e[30] + e[14] * e[28] * e[4] + e[14] * e[1] * e[31] + e[14] * e[2] * e[32] + e[29] * e[10] * e[1] - 1.*e[29] * e[13] * e[4] - 1.*e[29] * e[16] * e[7] - 1.*e[29] * e[15] * e[6] + e[29] * e[9] * e[0] - 1.*e[29] * e[12] * e[3] + e[32] * e[9] * e[3] + e[32] * e[0] * e[12] + e[32] * e[10] * e[4] + e[32] * e[1] * e[13] + e[17] * e[27] * e[6] + e[17] * e[0] * e[33] + e[17] * e[28] * e[7] + e[17] * e[1] * e[34] + e[17] * e[2] * e[35] - 1.*e[2] * e[30] * e[12] - 1.*e[2] * e[31] * e[13] - 1.*e[2] * e[33] * e[15] - 1.*e[2] * e[34] * e[16] + e[35] * e[9] * e[6] + e[35] * e[0] * e[15] + e[35] * e[10] * e[7] + e[35] * e[1] * e[16] + e[5] * e[27] * e[12] + e[5] * e[9] * e[30] + e[5] * e[29] * e[14] + e[5] * e[11] * e[32] + e[5] * e[28] * e[13] + e[5] * e[10] * e[31] + e[8] * e[27] * e[15] + e[8] * e[9] * e[33] + e[8] * e[29] * e[17] + e[8] * e[11] * e[35];
		A[91] = -1.*e[12] * e[34] * e[7] + e[12] * e[32] * e[5] - 1.*e[12] * e[35] * e[8] - 1.*e[12] * e[29] * e[2] - 1.*e[12] * e[28] * e[1] + e[12] * e[31] * e[4] - 1.*e[30] * e[11] * e[2] - 1.*e[30] * e[10] * e[1] + e[30] * e[13] * e[4] - 1.*e[30] * e[16] * e[7] + e[30] * e[14] * e[5] - 1.*e[30] * e[17] * e[8] + e[15] * e[3] * e[33] + e[15] * e[31] * e[7] + e[15] * e[4] * e[34] + e[15] * e[32] * e[8] + e[15] * e[5] * e[35] + e[3] * e[27] * e[9] - 1.*e[3] * e[28] * e[10] - 1.*e[3] * e[34] * e[16] - 1.*e[3] * e[35] * e[17] - 1.*e[3] * e[29] * e[11] + e[33] * e[13] * e[7] + e[33] * e[4] * e[16] + e[33] * e[14] * e[8] + e[33] * e[5] * e[17] + e[9] * e[28] * e[4] + e[9] * e[1] * e[31] + e[9] * e[29] * e[5] + e[9] * e[2] * e[32] + e[27] * e[10] * e[4] + e[27] * e[1] * e[13] + e[27] * e[11] * e[5] + e[27] * e[2] * e[14] + 3.*e[3] * e[30] * e[12] + e[3] * e[32] * e[14] + e[3] * e[31] * e[13] + e[6] * e[30] * e[15] + e[6] * e[12] * e[33] + e[6] * e[32] * e[17] + e[6] * e[14] * e[35] + e[6] * e[31] * e[16] + e[6] * e[13] * e[34] + e[0] * e[27] * e[12] + e[0] * e[9] * e[30] + e[0] * e[29] * e[14] + e[0] * e[11] * e[32] + e[0] * e[28] * e[13] + e[0] * e[10] * e[31];
		A[90] = .5000000000*e[21] * ep2[24] - .5000000000*e[21] * ep2[25] + .5000000000*e[21] * ep2[23] - .5000000000*e[21] * ep2[26] + .5000000000*ep2[18] * e[21] + .5000000000*e[21] * ep2[22] - .5000000000*e[21] * ep2[20] + e[24] * e[22] * e[25] + e[24] * e[23] * e[26] - .5000000000*e[21] * ep2[19] + e[18] * e[19] * e[22] + e[18] * e[20] * e[23] + .5000000000*ep3[21];
		A[89] = -.5000000000*e[30] * ep2[26] - .5000000000*e[30] * ep2[19] - .5000000000*e[30] * ep2[20] - .5000000000*e[30] * ep2[25] + .5000000000*ep2[18] * e[30] + 1.500000000*e[30] * ep2[21] + .5000000000*e[30] * ep2[22] + .5000000000*e[30] * ep2[23] + .5000000000*e[30] * ep2[24] + e[18] * e[27] * e[21] + e[18] * e[28] * e[22] + e[18] * e[19] * e[31] + e[18] * e[29] * e[23] + e[18] * e[20] * e[32] + e[27] * e[19] * e[22] + e[27] * e[20] * e[23] + e[21] * e[31] * e[22] + e[21] * e[32] * e[23] + e[24] * e[21] * e[33] + e[24] * e[31] * e[25] + e[24] * e[22] * e[34] + e[24] * e[32] * e[26] + e[24] * e[23] * e[35] + e[33] * e[22] * e[25] + e[33] * e[23] * e[26] - 1.*e[21] * e[29] * e[20] - 1.*e[21] * e[35] * e[26] - 1.*e[21] * e[28] * e[19] - 1.*e[21] * e[34] * e[25];
		A[88] = .5000000000*e[12] * ep2[15] - .5000000000*e[12] * ep2[17] + e[15] * e[13] * e[16] - .5000000000*e[12] * ep2[10] + e[15] * e[14] * e[17] - .5000000000*e[12] * ep2[16] - .5000000000*e[12] * ep2[11] + e[9] * e[10] * e[13] + .5000000000*e[12] * ep2[13] + .5000000000*ep2[9] * e[12] + .5000000000*ep3[12] + e[9] * e[11] * e[14] + .5000000000*e[12] * ep2[14];
		A[95] = e[12] * e[13] * e[4] + e[12] * e[14] * e[5] + e[15] * e[12] * e[6] + e[15] * e[13] * e[7] + e[15] * e[4] * e[16] + e[15] * e[14] * e[8] + e[15] * e[5] * e[17] + e[6] * e[14] * e[17] + e[6] * e[13] * e[16] + e[0] * e[11] * e[14] + e[0] * e[9] * e[12] + e[0] * e[10] * e[13] + e[9] * e[10] * e[4] + e[9] * e[1] * e[13] + e[9] * e[11] * e[5] + e[9] * e[2] * e[14] - 1.*e[12] * e[11] * e[2] - 1.*e[12] * e[10] * e[1] - 1.*e[12] * e[16] * e[7] - 1.*e[12] * e[17] * e[8] + 1.500000000*ep2[12] * e[3] + .5000000000*e[3] * ep2[15] - .5000000000*e[3] * ep2[16] + .5000000000*e[3] * ep2[9] - .5000000000*e[3] * ep2[11] - .5000000000*e[3] * ep2[17] - .5000000000*e[3] * ep2[10] + .5000000000*e[3] * ep2[14] + .5000000000*e[3] * ep2[13];
		A[94] = e[18] * e[11] * e[14] + e[18] * e[9] * e[12] + e[18] * e[10] * e[13] + e[12] * e[23] * e[14] + e[12] * e[22] * e[13] + e[15] * e[12] * e[24] + e[15] * e[23] * e[17] + e[15] * e[14] * e[26] + e[15] * e[22] * e[16] + e[15] * e[13] * e[25] + e[24] * e[14] * e[17] + e[24] * e[13] * e[16] - 1.*e[12] * e[25] * e[16] - 1.*e[12] * e[26] * e[17] - 1.*e[12] * e[20] * e[11] - 1.*e[12] * e[19] * e[10] + e[9] * e[20] * e[14] + e[9] * e[11] * e[23] + e[9] * e[19] * e[13] + e[9] * e[10] * e[22] + .5000000000*ep2[9] * e[21] - .5000000000*e[21] * ep2[16] - .5000000000*e[21] * ep2[11] - .5000000000*e[21] * ep2[17] - .5000000000*e[21] * ep2[10] + 1.500000000*e[21] * ep2[12] + .5000000000*e[21] * ep2[14] + .5000000000*e[21] * ep2[13] + .5000000000*e[21] * ep2[15];
		A[93] = -1.*e[21] * e[35] * e[8] - 1.*e[21] * e[29] * e[2] - 1.*e[21] * e[28] * e[1] + e[21] * e[31] * e[4] - 1.*e[30] * e[26] * e[8] - 1.*e[30] * e[20] * e[2] - 1.*e[30] * e[19] * e[1] + e[30] * e[22] * e[4] - 1.*e[30] * e[25] * e[7] + e[30] * e[23] * e[5] + e[6] * e[31] * e[25] + e[6] * e[22] * e[34] + e[6] * e[32] * e[26] + e[6] * e[23] * e[35] + e[24] * e[30] * e[6] + e[24] * e[3] * e[33] + e[24] * e[31] * e[7] + e[24] * e[4] * e[34] + e[24] * e[32] * e[8] + e[24] * e[5] * e[35] + e[33] * e[21] * e[6] + e[33] * e[22] * e[7] + e[33] * e[4] * e[25] + e[33] * e[23] * e[8] + e[33] * e[5] * e[26] + e[0] * e[27] * e[21] + e[0] * e[18] * e[30] + e[0] * e[28] * e[22] + e[0] * e[19] * e[31] + e[0] * e[29] * e[23] + e[0] * e[20] * e[32] + e[18] * e[27] * e[3] + e[18] * e[28] * e[4] + e[18] * e[1] * e[31] + e[18] * e[29] * e[5] + e[18] * e[2] * e[32] + e[27] * e[19] * e[4] + e[27] * e[1] * e[22] + e[27] * e[20] * e[5] + e[27] * e[2] * e[23] + 3.*e[3] * e[30] * e[21] + e[3] * e[31] * e[22] + e[3] * e[32] * e[23] - 1.*e[3] * e[29] * e[20] - 1.*e[3] * e[35] * e[26] - 1.*e[3] * e[28] * e[19] - 1.*e[3] * e[34] * e[25] - 1.*e[21] * e[34] * e[7] + e[21] * e[32] * e[5];
		A[92] = e[18] * e[1] * e[4] + e[18] * e[0] * e[3] + e[18] * e[2] * e[5] + e[3] * e[22] * e[4] + e[3] * e[23] * e[5] + e[6] * e[3] * e[24] + e[6] * e[22] * e[7] + e[6] * e[4] * e[25] + e[6] * e[23] * e[8] + e[6] * e[5] * e[26] + e[24] * e[4] * e[7] + e[24] * e[5] * e[8] + e[0] * e[19] * e[4] + e[0] * e[1] * e[22] + e[0] * e[20] * e[5] + e[0] * e[2] * e[23] - 1.*e[3] * e[26] * e[8] - 1.*e[3] * e[20] * e[2] - 1.*e[3] * e[19] * e[1] - 1.*e[3] * e[25] * e[7] + .5000000000*e[21] * ep2[4] + .5000000000*e[21] * ep2[0] + .5000000000*e[21] * ep2[6] + .5000000000*e[21] * ep2[5] - .5000000000*e[21] * ep2[1] - .5000000000*e[21] * ep2[7] + 1.500000000*e[21] * ep2[3] - .5000000000*e[21] * ep2[2] - .5000000000*e[21] * ep2[8];
		A[82] = .5000000000*ep2[27] * e[21] + 1.500000000*e[21] * ep2[30] + .5000000000*e[21] * ep2[32] + .5000000000*e[21] * ep2[31] + .5000000000*e[21] * ep2[33] - .5000000000*e[21] * ep2[28] - .5000000000*e[21] * ep2[29] - .5000000000*e[21] * ep2[34] - .5000000000*e[21] * ep2[35] + e[18] * e[27] * e[30] + e[18] * e[29] * e[32] + e[18] * e[28] * e[31] + e[27] * e[28] * e[22] + e[27] * e[19] * e[31] + e[27] * e[29] * e[23] + e[27] * e[20] * e[32] + e[30] * e[31] * e[22] + e[30] * e[32] * e[23] + e[24] * e[30] * e[33] + e[24] * e[32] * e[35] + e[24] * e[31] * e[34] + e[33] * e[31] * e[25] + e[33] * e[22] * e[34] + e[33] * e[32] * e[26] + e[33] * e[23] * e[35] - 1.*e[30] * e[29] * e[20] - 1.*e[30] * e[35] * e[26] - 1.*e[30] * e[28] * e[19] - 1.*e[30] * e[34] * e[25];
		A[192] = -.5000000000*e[26] * ep2[4] - .5000000000*e[26] * ep2[0] + .5000000000*e[26] * ep2[6] + .5000000000*e[26] * ep2[5] - .5000000000*e[26] * ep2[1] + .5000000000*e[26] * ep2[7] - .5000000000*e[26] * ep2[3] + .5000000000*e[26] * ep2[2] + 1.500000000*e[26] * ep2[8] + e[20] * e[0] * e[6] + e[20] * e[2] * e[8] + e[5] * e[21] * e[6] + e[5] * e[3] * e[24] + e[5] * e[22] * e[7] + e[5] * e[4] * e[25] + e[5] * e[23] * e[8] + e[23] * e[4] * e[7] + e[23] * e[3] * e[6] + e[8] * e[24] * e[6] + e[8] * e[25] * e[7] + e[2] * e[18] * e[6] + e[2] * e[0] * e[24] + e[2] * e[19] * e[7] + e[2] * e[1] * e[25] - 1.*e[8] * e[21] * e[3] - 1.*e[8] * e[19] * e[1] - 1.*e[8] * e[22] * e[4] - 1.*e[8] * e[18] * e[0] + e[20] * e[1] * e[7];
		A[83] = e[9] * e[27] * e[30] + e[9] * e[29] * e[32] + e[9] * e[28] * e[31] + e[33] * e[30] * e[15] + e[33] * e[32] * e[17] + e[33] * e[14] * e[35] + e[33] * e[31] * e[16] + e[33] * e[13] * e[34] + e[27] * e[29] * e[14] + e[27] * e[11] * e[32] + e[27] * e[28] * e[13] + e[27] * e[10] * e[31] - 1.*e[30] * e[28] * e[10] + e[30] * e[31] * e[13] + e[30] * e[32] * e[14] - 1.*e[30] * e[34] * e[16] - 1.*e[30] * e[35] * e[17] - 1.*e[30] * e[29] * e[11] + e[15] * e[32] * e[35] + e[15] * e[31] * e[34] - .5000000000*e[12] * ep2[34] - .5000000000*e[12] * ep2[35] + .5000000000*e[12] * ep2[27] + .5000000000*e[12] * ep2[32] - .5000000000*e[12] * ep2[28] - .5000000000*e[12] * ep2[29] + .5000000000*e[12] * ep2[31] + .5000000000*e[12] * ep2[33] + 1.500000000*e[12] * ep2[30];
		A[193] = e[23] * e[30] * e[6] + e[23] * e[3] * e[33] + e[23] * e[31] * e[7] + e[23] * e[4] * e[34] + e[32] * e[21] * e[6] + e[32] * e[3] * e[24] + e[32] * e[22] * e[7] + e[32] * e[4] * e[25] + e[26] * e[33] * e[6] + e[26] * e[34] * e[7] + 3.*e[26] * e[35] * e[8] + e[35] * e[24] * e[6] + e[35] * e[25] * e[7] + e[2] * e[27] * e[24] + e[2] * e[18] * e[33] + e[2] * e[28] * e[25] + e[2] * e[19] * e[34] + e[2] * e[29] * e[26] + e[2] * e[20] * e[35] + e[20] * e[27] * e[6] + e[20] * e[0] * e[33] + e[20] * e[28] * e[7] + e[20] * e[1] * e[34] + e[20] * e[29] * e[8] + e[29] * e[18] * e[6] + e[29] * e[0] * e[24] + e[29] * e[19] * e[7] + e[29] * e[1] * e[25] + e[5] * e[30] * e[24] + e[5] * e[21] * e[33] + e[5] * e[31] * e[25] + e[5] * e[22] * e[34] + e[5] * e[32] * e[26] + e[5] * e[23] * e[35] - 1.*e[8] * e[27] * e[18] + e[8] * e[33] * e[24] - 1.*e[8] * e[30] * e[21] - 1.*e[8] * e[31] * e[22] + e[8] * e[32] * e[23] - 1.*e[8] * e[28] * e[19] + e[8] * e[34] * e[25] - 1.*e[26] * e[27] * e[0] - 1.*e[26] * e[30] * e[3] - 1.*e[26] * e[28] * e[1] - 1.*e[26] * e[31] * e[4] - 1.*e[35] * e[21] * e[3] - 1.*e[35] * e[19] * e[1] - 1.*e[35] * e[22] * e[4] - 1.*e[35] * e[18] * e[0];
		A[80] = e[27] * e[29] * e[32] + e[27] * e[28] * e[31] + e[33] * e[32] * e[35] + e[33] * e[31] * e[34] + .5000000000*ep3[30] - .5000000000*e[30] * ep2[28] - .5000000000*e[30] * ep2[29] - .5000000000*e[30] * ep2[34] + .5000000000*e[30] * ep2[33] + .5000000000*ep2[27] * e[30] + .5000000000*e[30] * ep2[32] + .5000000000*e[30] * ep2[31] - .5000000000*e[30] * ep2[35];
		A[194] = .5000000000*ep2[14] * e[26] + 1.500000000*e[26] * ep2[17] + .5000000000*e[26] * ep2[15] + .5000000000*e[26] * ep2[16] + .5000000000*ep2[11] * e[26] - .5000000000*e[26] * ep2[9] - .5000000000*e[26] * ep2[12] - .5000000000*e[26] * ep2[10] - .5000000000*e[26] * ep2[13] + e[20] * e[11] * e[17] + e[20] * e[9] * e[15] + e[20] * e[10] * e[16] + e[14] * e[21] * e[15] + e[14] * e[12] * e[24] + e[14] * e[23] * e[17] + e[14] * e[22] * e[16] + e[14] * e[13] * e[25] + e[23] * e[12] * e[15] + e[23] * e[13] * e[16] + e[17] * e[24] * e[15] + e[17] * e[25] * e[16] - 1.*e[17] * e[18] * e[9] - 1.*e[17] * e[21] * e[12] - 1.*e[17] * e[19] * e[10] - 1.*e[17] * e[22] * e[13] + e[11] * e[18] * e[15] + e[11] * e[9] * e[24] + e[11] * e[19] * e[16] + e[11] * e[10] * e[25];
		A[81] = e[0] * e[27] * e[30] + e[0] * e[29] * e[32] + e[0] * e[28] * e[31] + e[30] * e[31] * e[4] + e[30] * e[32] * e[5] + e[6] * e[30] * e[33] + e[6] * e[32] * e[35] + e[6] * e[31] * e[34] + e[27] * e[28] * e[4] + e[27] * e[1] * e[31] + e[27] * e[29] * e[5] + e[27] * e[2] * e[32] + e[33] * e[31] * e[7] + e[33] * e[4] * e[34] + e[33] * e[32] * e[8] + e[33] * e[5] * e[35] - 1.*e[30] * e[34] * e[7] - 1.*e[30] * e[35] * e[8] - 1.*e[30] * e[29] * e[2] - 1.*e[30] * e[28] * e[1] + 1.500000000*e[3] * ep2[30] + .5000000000*e[3] * ep2[32] + .5000000000*e[3] * ep2[31] + .5000000000*e[3] * ep2[27] - .5000000000*e[3] * ep2[28] - .5000000000*e[3] * ep2[29] + .5000000000*e[3] * ep2[33] - .5000000000*e[3] * ep2[34] - .5000000000*e[3] * ep2[35];
		A[195] = .5000000000*ep2[14] * e[8] + 1.500000000*ep2[17] * e[8] + .5000000000*e[8] * ep2[15] + .5000000000*e[8] * ep2[16] - .5000000000*e[8] * ep2[9] + .5000000000*e[8] * ep2[11] - .5000000000*e[8] * ep2[12] - .5000000000*e[8] * ep2[10] - .5000000000*e[8] * ep2[13] + e[14] * e[12] * e[6] + e[14] * e[3] * e[15] + e[14] * e[13] * e[7] + e[14] * e[4] * e[16] + e[14] * e[5] * e[17] + e[17] * e[15] * e[6] + e[17] * e[16] * e[7] + e[2] * e[11] * e[17] + e[2] * e[9] * e[15] + e[2] * e[10] * e[16] + e[5] * e[12] * e[15] + e[5] * e[13] * e[16] + e[11] * e[9] * e[6] + e[11] * e[0] * e[15] + e[11] * e[10] * e[7] + e[11] * e[1] * e[16] - 1.*e[17] * e[10] * e[1] - 1.*e[17] * e[13] * e[4] - 1.*e[17] * e[9] * e[0] - 1.*e[17] * e[12] * e[3];
		A[86] = -.5000000000*e[3] * ep2[1] - .5000000000*e[3] * ep2[7] + .5000000000*ep3[3] - .5000000000*e[3] * ep2[8] + e[0] * e[2] * e[5] + .5000000000*e[3] * ep2[6] + .5000000000*e[3] * ep2[4] - .5000000000*e[3] * ep2[2] + e[0] * e[1] * e[4] + e[6] * e[4] * e[7] + .5000000000*ep2[0] * e[3] + .5000000000*e[3] * ep2[5] + e[6] * e[5] * e[8];
		A[196] = .5000000000*ep2[23] * e[17] + 1.500000000*ep2[26] * e[17] + .5000000000*e[17] * ep2[25] + .5000000000*e[17] * ep2[24] - .5000000000*e[17] * ep2[18] - .5000000000*e[17] * ep2[19] + .5000000000*e[17] * ep2[20] - .5000000000*e[17] * ep2[22] - .5000000000*e[17] * ep2[21] + e[23] * e[21] * e[15] + e[23] * e[12] * e[24] + e[23] * e[14] * e[26] + e[23] * e[22] * e[16] + e[23] * e[13] * e[25] + e[26] * e[24] * e[15] + e[26] * e[25] * e[16] + e[11] * e[19] * e[25] + e[11] * e[18] * e[24] + e[11] * e[20] * e[26] + e[14] * e[22] * e[25] + e[14] * e[21] * e[24] + e[20] * e[18] * e[15] + e[20] * e[9] * e[24] + e[20] * e[19] * e[16] + e[20] * e[10] * e[25] - 1.*e[26] * e[18] * e[9] - 1.*e[26] * e[21] * e[12] - 1.*e[26] * e[19] * e[10] - 1.*e[26] * e[22] * e[13];
		A[87] = -1.*e[12] * e[34] * e[16] - 1.*e[12] * e[35] * e[17] - 1.*e[12] * e[29] * e[11] + e[9] * e[27] * e[12] + e[9] * e[29] * e[14] + e[9] * e[11] * e[32] + e[9] * e[28] * e[13] + e[9] * e[10] * e[31] + e[27] * e[11] * e[14] + e[27] * e[10] * e[13] + e[12] * e[32] * e[14] + e[12] * e[31] * e[13] + e[15] * e[12] * e[33] + e[15] * e[32] * e[17] + e[15] * e[14] * e[35] + e[15] * e[31] * e[16] + e[15] * e[13] * e[34] + e[33] * e[14] * e[17] + e[33] * e[13] * e[16] - 1.*e[12] * e[28] * e[10] + .5000000000*ep2[9] * e[30] - .5000000000*e[30] * ep2[16] - .5000000000*e[30] * ep2[11] + 1.500000000*e[30] * ep2[12] + .5000000000*e[30] * ep2[15] - .5000000000*e[30] * ep2[17] - .5000000000*e[30] * ep2[10] + .5000000000*e[30] * ep2[14] + .5000000000*e[30] * ep2[13];
		A[197] = e[32] * e[22] * e[16] + e[32] * e[13] * e[25] - 1.*e[17] * e[27] * e[18] + e[17] * e[33] * e[24] - 1.*e[17] * e[30] * e[21] + e[17] * e[29] * e[20] + 3.*e[17] * e[35] * e[26] - 1.*e[17] * e[31] * e[22] - 1.*e[17] * e[28] * e[19] + e[17] * e[34] * e[25] + e[20] * e[27] * e[15] + e[20] * e[9] * e[33] + e[20] * e[28] * e[16] + e[20] * e[10] * e[34] + e[29] * e[18] * e[15] + e[29] * e[9] * e[24] + e[29] * e[19] * e[16] + e[29] * e[10] * e[25] - 1.*e[26] * e[27] * e[9] - 1.*e[26] * e[30] * e[12] - 1.*e[26] * e[28] * e[10] - 1.*e[26] * e[31] * e[13] + e[26] * e[33] * e[15] + e[26] * e[34] * e[16] + e[35] * e[24] * e[15] + e[35] * e[25] * e[16] - 1.*e[35] * e[18] * e[9] - 1.*e[35] * e[21] * e[12] - 1.*e[35] * e[19] * e[10] - 1.*e[35] * e[22] * e[13] + e[14] * e[30] * e[24] + e[14] * e[21] * e[33] + e[14] * e[31] * e[25] + e[14] * e[22] * e[34] + e[14] * e[32] * e[26] + e[14] * e[23] * e[35] + e[11] * e[27] * e[24] + e[11] * e[18] * e[33] + e[11] * e[28] * e[25] + e[11] * e[19] * e[34] + e[11] * e[29] * e[26] + e[11] * e[20] * e[35] + e[23] * e[30] * e[15] + e[23] * e[12] * e[33] + e[23] * e[32] * e[17] + e[23] * e[31] * e[16] + e[23] * e[13] * e[34] + e[32] * e[21] * e[15] + e[32] * e[12] * e[24];
		A[84] = e[6] * e[23] * e[17] + e[6] * e[14] * e[26] + e[6] * e[22] * e[16] + e[6] * e[13] * e[25] + e[0] * e[20] * e[14] + e[0] * e[11] * e[23] + e[0] * e[19] * e[13] + e[0] * e[10] * e[22] - 1.*e[12] * e[26] * e[8] - 1.*e[12] * e[20] * e[2] - 1.*e[12] * e[19] * e[1] + e[12] * e[22] * e[4] - 1.*e[12] * e[25] * e[7] + e[12] * e[23] * e[5] - 1.*e[21] * e[11] * e[2] - 1.*e[21] * e[10] * e[1] + e[21] * e[13] * e[4] - 1.*e[21] * e[16] * e[7] + e[21] * e[14] * e[5] - 1.*e[21] * e[17] * e[8] + e[15] * e[3] * e[24] + e[15] * e[22] * e[7] + e[15] * e[4] * e[25] + e[15] * e[23] * e[8] + e[15] * e[5] * e[26] - 1.*e[3] * e[25] * e[16] - 1.*e[3] * e[26] * e[17] - 1.*e[3] * e[20] * e[11] - 1.*e[3] * e[19] * e[10] + e[24] * e[13] * e[7] + e[24] * e[4] * e[16] + e[24] * e[14] * e[8] + e[24] * e[5] * e[17] + e[9] * e[18] * e[3] + e[9] * e[0] * e[21] + e[9] * e[19] * e[4] + e[9] * e[1] * e[22] + e[9] * e[20] * e[5] + e[9] * e[2] * e[23] + e[18] * e[0] * e[12] + e[18] * e[10] * e[4] + e[18] * e[1] * e[13] + e[18] * e[11] * e[5] + e[18] * e[2] * e[14] + 3.*e[3] * e[21] * e[12] + e[3] * e[23] * e[14] + e[3] * e[22] * e[13] + e[6] * e[21] * e[15] + e[6] * e[12] * e[24];
		A[198] = .5000000000*ep2[5] * e[17] + 1.500000000*e[17] * ep2[8] + .5000000000*e[17] * ep2[7] + .5000000000*e[17] * ep2[6] + .5000000000*ep2[2] * e[17] - .5000000000*e[17] * ep2[4] - .5000000000*e[17] * ep2[0] - .5000000000*e[17] * ep2[1] - .5000000000*e[17] * ep2[3] + e[11] * e[1] * e[7] + e[11] * e[0] * e[6] + e[11] * e[2] * e[8] + e[5] * e[12] * e[6] + e[5] * e[3] * e[15] + e[5] * e[13] * e[7] + e[5] * e[4] * e[16] + e[5] * e[14] * e[8] + e[14] * e[4] * e[7] + e[14] * e[3] * e[6] + e[8] * e[15] * e[6] + e[8] * e[16] * e[7] - 1.*e[8] * e[10] * e[1] - 1.*e[8] * e[13] * e[4] - 1.*e[8] * e[9] * e[0] - 1.*e[8] * e[12] * e[3] + e[2] * e[9] * e[6] + e[2] * e[0] * e[15] + e[2] * e[10] * e[7] + e[2] * e[1] * e[16];
		A[85] = e[6] * e[4] * e[34] + e[6] * e[32] * e[8] + e[6] * e[5] * e[35] + e[33] * e[4] * e[7] + e[33] * e[5] * e[8] + e[0] * e[27] * e[3] + e[0] * e[28] * e[4] + e[0] * e[1] * e[31] + e[0] * e[29] * e[5] + e[0] * e[2] * e[32] - 1.*e[3] * e[34] * e[7] + e[3] * e[32] * e[5] + e[3] * e[33] * e[6] - 1.*e[3] * e[35] * e[8] - 1.*e[3] * e[29] * e[2] - 1.*e[3] * e[28] * e[1] + e[3] * e[31] * e[4] + e[27] * e[1] * e[4] + e[27] * e[2] * e[5] + e[6] * e[31] * e[7] + .5000000000*e[30] * ep2[4] + .5000000000*e[30] * ep2[6] + .5000000000*e[30] * ep2[5] - .5000000000*e[30] * ep2[1] - .5000000000*e[30] * ep2[7] - .5000000000*e[30] * ep2[2] - .5000000000*e[30] * ep2[8] + .5000000000*ep2[0] * e[30] + 1.500000000*e[30] * ep2[3];
		A[199] = .5000000000*ep2[23] * e[8] + 1.500000000*ep2[26] * e[8] - .5000000000*e[8] * ep2[18] - .5000000000*e[8] * ep2[19] - .5000000000*e[8] * ep2[22] + .5000000000*e[8] * ep2[24] - .5000000000*e[8] * ep2[21] + .5000000000*e[8] * ep2[25] + .5000000000*ep2[20] * e[8] + e[20] * e[18] * e[6] + e[20] * e[0] * e[24] + e[20] * e[19] * e[7] + e[20] * e[1] * e[25] + e[20] * e[2] * e[26] + e[23] * e[21] * e[6] + e[23] * e[3] * e[24] + e[23] * e[22] * e[7] + e[23] * e[4] * e[25] + e[23] * e[5] * e[26] - 1.*e[26] * e[21] * e[3] - 1.*e[26] * e[19] * e[1] - 1.*e[26] * e[22] * e[4] - 1.*e[26] * e[18] * e[0] + e[26] * e[25] * e[7] + e[26] * e[24] * e[6] + e[2] * e[19] * e[25] + e[2] * e[18] * e[24] + e[5] * e[22] * e[25] + e[5] * e[21] * e[24];
		A[109] = e[19] * e[27] * e[21] + e[19] * e[18] * e[30] + e[19] * e[28] * e[22] + e[19] * e[29] * e[23] + e[19] * e[20] * e[32] + e[28] * e[18] * e[21] + e[28] * e[20] * e[23] + e[22] * e[30] * e[21] + e[22] * e[32] * e[23] + e[25] * e[30] * e[24] + e[25] * e[21] * e[33] + e[25] * e[22] * e[34] + e[25] * e[32] * e[26] + e[25] * e[23] * e[35] + e[34] * e[21] * e[24] + e[34] * e[23] * e[26] - 1.*e[22] * e[27] * e[18] - 1.*e[22] * e[33] * e[24] - 1.*e[22] * e[29] * e[20] - 1.*e[22] * e[35] * e[26] + .5000000000*ep2[19] * e[31] + 1.500000000*e[31] * ep2[22] + .5000000000*e[31] * ep2[21] + .5000000000*e[31] * ep2[23] + .5000000000*e[31] * ep2[25] - .5000000000*e[31] * ep2[26] - .5000000000*e[31] * ep2[18] - .5000000000*e[31] * ep2[20] - .5000000000*e[31] * ep2[24];
		A[108] = -.5000000000*e[13] * ep2[15] + .5000000000*e[13] * ep2[16] + .5000000000*e[13] * ep2[12] + e[16] * e[12] * e[15] + .5000000000*ep3[13] + e[10] * e[11] * e[14] + .5000000000*e[13] * ep2[14] - .5000000000*e[13] * ep2[17] - .5000000000*e[13] * ep2[11] - .5000000000*e[13] * ep2[9] + .5000000000*ep2[10] * e[13] + e[10] * e[9] * e[12] + e[16] * e[14] * e[17];
		A[111] = -1.*e[13] * e[29] * e[2] - 1.*e[31] * e[11] * e[2] - 1.*e[31] * e[15] * e[6] - 1.*e[31] * e[9] * e[0] + e[31] * e[14] * e[5] + e[31] * e[12] * e[3] - 1.*e[31] * e[17] * e[8] + e[16] * e[30] * e[6] + e[16] * e[3] * e[33] + e[16] * e[4] * e[34] + e[16] * e[32] * e[8] + e[16] * e[5] * e[35] - 1.*e[4] * e[27] * e[9] + e[4] * e[28] * e[10] - 1.*e[4] * e[33] * e[15] - 1.*e[4] * e[35] * e[17] - 1.*e[4] * e[29] * e[11] + e[34] * e[12] * e[6] + e[34] * e[3] * e[15] + e[34] * e[14] * e[8] + e[34] * e[5] * e[17] + e[10] * e[27] * e[3] + e[10] * e[0] * e[30] + e[10] * e[29] * e[5] + e[10] * e[2] * e[32] + e[28] * e[9] * e[3] + e[28] * e[0] * e[12] + e[28] * e[11] * e[5] + e[28] * e[2] * e[14] + e[4] * e[30] * e[12] + e[4] * e[32] * e[14] + 3.*e[4] * e[31] * e[13] + e[7] * e[30] * e[15] + e[7] * e[12] * e[33] + e[7] * e[32] * e[17] + e[7] * e[14] * e[35] + e[7] * e[31] * e[16] + e[7] * e[13] * e[34] + e[1] * e[27] * e[12] + e[1] * e[9] * e[30] + e[1] * e[29] * e[14] + e[1] * e[11] * e[32] + e[1] * e[28] * e[13] + e[1] * e[10] * e[31] - 1.*e[13] * e[27] * e[0] + e[13] * e[32] * e[5] - 1.*e[13] * e[33] * e[6] + e[13] * e[30] * e[3] - 1.*e[13] * e[35] * e[8];
		A[110] = e[25] * e[23] * e[26] + e[19] * e[20] * e[23] + e[19] * e[18] * e[21] + e[25] * e[21] * e[24] + .5000000000*ep3[22] + .5000000000*e[22] * ep2[23] + .5000000000*ep2[19] * e[22] - .5000000000*e[22] * ep2[18] - .5000000000*e[22] * ep2[24] + .5000000000*e[22] * ep2[21] + .5000000000*e[22] * ep2[25] - .5000000000*e[22] * ep2[20] - .5000000000*e[22] * ep2[26];
		A[105] = e[34] * e[5] * e[8] + e[1] * e[27] * e[3] + e[1] * e[0] * e[30] + e[1] * e[28] * e[4] + e[1] * e[29] * e[5] + e[1] * e[2] * e[32] - 1.*e[4] * e[27] * e[0] + e[4] * e[34] * e[7] + e[4] * e[32] * e[5] - 1.*e[4] * e[33] * e[6] + e[4] * e[30] * e[3] - 1.*e[4] * e[35] * e[8] - 1.*e[4] * e[29] * e[2] + e[28] * e[0] * e[3] + e[28] * e[2] * e[5] + e[7] * e[30] * e[6] + e[7] * e[3] * e[33] + e[7] * e[32] * e[8] + e[7] * e[5] * e[35] + e[34] * e[3] * e[6] + .5000000000*ep2[1] * e[31] + 1.500000000*e[31] * ep2[4] - .5000000000*e[31] * ep2[0] - .5000000000*e[31] * ep2[6] + .5000000000*e[31] * ep2[5] + .5000000000*e[31] * ep2[7] + .5000000000*e[31] * ep2[3] - .5000000000*e[31] * ep2[2] - .5000000000*e[31] * ep2[8];
		A[104] = e[1] * e[20] * e[14] + e[1] * e[11] * e[23] + e[13] * e[21] * e[3] - 1.*e[13] * e[26] * e[8] - 1.*e[13] * e[20] * e[2] - 1.*e[13] * e[18] * e[0] + e[13] * e[23] * e[5] - 1.*e[13] * e[24] * e[6] - 1.*e[22] * e[11] * e[2] - 1.*e[22] * e[15] * e[6] - 1.*e[22] * e[9] * e[0] + e[22] * e[14] * e[5] + e[22] * e[12] * e[3] - 1.*e[22] * e[17] * e[8] + e[16] * e[21] * e[6] + e[16] * e[3] * e[24] + e[16] * e[4] * e[25] + e[16] * e[23] * e[8] + e[16] * e[5] * e[26] - 1.*e[4] * e[24] * e[15] - 1.*e[4] * e[26] * e[17] - 1.*e[4] * e[20] * e[11] - 1.*e[4] * e[18] * e[9] + e[25] * e[12] * e[6] + e[25] * e[3] * e[15] + e[25] * e[14] * e[8] + e[25] * e[5] * e[17] + e[10] * e[18] * e[3] + e[10] * e[0] * e[21] + e[10] * e[19] * e[4] + e[10] * e[1] * e[22] + e[10] * e[20] * e[5] + e[10] * e[2] * e[23] + e[19] * e[9] * e[3] + e[19] * e[0] * e[12] + e[19] * e[1] * e[13] + e[19] * e[11] * e[5] + e[19] * e[2] * e[14] + e[4] * e[21] * e[12] + e[4] * e[23] * e[14] + 3.*e[4] * e[22] * e[13] + e[7] * e[21] * e[15] + e[7] * e[12] * e[24] + e[7] * e[23] * e[17] + e[7] * e[14] * e[26] + e[7] * e[22] * e[16] + e[7] * e[13] * e[25] + e[1] * e[18] * e[12] + e[1] * e[9] * e[21];
		A[107] = e[10] * e[27] * e[12] + e[10] * e[9] * e[30] + e[10] * e[29] * e[14] + e[10] * e[11] * e[32] + e[10] * e[28] * e[13] + e[28] * e[11] * e[14] + e[28] * e[9] * e[12] + e[13] * e[30] * e[12] + e[13] * e[32] * e[14] + e[16] * e[30] * e[15] + e[16] * e[12] * e[33] + e[16] * e[32] * e[17] + e[16] * e[14] * e[35] + e[16] * e[13] * e[34] + e[34] * e[14] * e[17] + e[34] * e[12] * e[15] - 1.*e[13] * e[27] * e[9] - 1.*e[13] * e[33] * e[15] - 1.*e[13] * e[35] * e[17] - 1.*e[13] * e[29] * e[11] + .5000000000*ep2[10] * e[31] + .5000000000*e[31] * ep2[16] - .5000000000*e[31] * ep2[9] - .5000000000*e[31] * ep2[11] + .5000000000*e[31] * ep2[12] - .5000000000*e[31] * ep2[15] - .5000000000*e[31] * ep2[17] + .5000000000*e[31] * ep2[14] + 1.500000000*e[31] * ep2[13];
		A[106] = -.5000000000*e[4] * ep2[6] - .5000000000*e[4] * ep2[0] + e[1] * e[2] * e[5] + .5000000000*e[4] * ep2[7] + e[1] * e[0] * e[3] + e[7] * e[5] * e[8] - .5000000000*e[4] * ep2[8] + .5000000000*e[4] * ep2[3] + .5000000000*e[4] * ep2[5] + e[7] * e[3] * e[6] - .5000000000*e[4] * ep2[2] + .5000000000*ep3[4] + .5000000000*ep2[1] * e[4];
		A[100] = e[34] * e[32] * e[35] - .5000000000*e[31] * ep2[35] + .5000000000*e[31] * ep2[34] + .5000000000*ep2[28] * e[31] + .5000000000*ep3[31] + .5000000000*e[31] * ep2[32] + e[34] * e[30] * e[33] - .5000000000*e[31] * ep2[27] + .5000000000*e[31] * ep2[30] - .5000000000*e[31] * ep2[33] - .5000000000*e[31] * ep2[29] + e[28] * e[29] * e[32] + e[28] * e[27] * e[30];
		A[101] = e[1] * e[27] * e[30] + e[1] * e[29] * e[32] + e[1] * e[28] * e[31] + e[31] * e[30] * e[3] + e[31] * e[32] * e[5] + e[7] * e[30] * e[33] + e[7] * e[32] * e[35] + e[7] * e[31] * e[34] + e[28] * e[27] * e[3] + e[28] * e[0] * e[30] + e[28] * e[29] * e[5] + e[28] * e[2] * e[32] + e[34] * e[30] * e[6] + e[34] * e[3] * e[33] + e[34] * e[32] * e[8] + e[34] * e[5] * e[35] - 1.*e[31] * e[27] * e[0] - 1.*e[31] * e[33] * e[6] - 1.*e[31] * e[35] * e[8] - 1.*e[31] * e[29] * e[2] + .5000000000*e[4] * ep2[30] + .5000000000*e[4] * ep2[32] + 1.500000000*e[4] * ep2[31] - .5000000000*e[4] * ep2[27] + .5000000000*e[4] * ep2[28] - .5000000000*e[4] * ep2[29] - .5000000000*e[4] * ep2[33] + .5000000000*e[4] * ep2[34] - .5000000000*e[4] * ep2[35];
		A[102] = .5000000000*e[22] * ep2[30] + .5000000000*e[22] * ep2[32] + 1.500000000*e[22] * ep2[31] + .5000000000*e[22] * ep2[34] - .5000000000*e[22] * ep2[27] - .5000000000*e[22] * ep2[29] - .5000000000*e[22] * ep2[33] - .5000000000*e[22] * ep2[35] + e[28] * e[18] * e[30] + e[28] * e[29] * e[23] + e[28] * e[20] * e[32] + e[31] * e[30] * e[21] + e[31] * e[32] * e[23] + e[25] * e[30] * e[33] + e[25] * e[32] * e[35] + e[25] * e[31] * e[34] + e[34] * e[30] * e[24] + e[34] * e[21] * e[33] + e[34] * e[32] * e[26] + e[34] * e[23] * e[35] - 1.*e[31] * e[27] * e[18] - 1.*e[31] * e[33] * e[24] - 1.*e[31] * e[29] * e[20] - 1.*e[31] * e[35] * e[26] + e[19] * e[27] * e[30] + e[19] * e[29] * e[32] + e[19] * e[28] * e[31] + e[28] * e[27] * e[21] + .5000000000*ep2[28] * e[22];
		A[103] = e[16] * e[30] * e[33] + e[16] * e[32] * e[35] + e[10] * e[27] * e[30] + e[10] * e[29] * e[32] + e[10] * e[28] * e[31] + e[34] * e[30] * e[15] + e[34] * e[12] * e[33] + e[34] * e[32] * e[17] + e[34] * e[14] * e[35] + e[34] * e[31] * e[16] + e[28] * e[27] * e[12] + e[28] * e[9] * e[30] + e[28] * e[29] * e[14] + e[28] * e[11] * e[32] - 1.*e[31] * e[27] * e[9] + e[31] * e[30] * e[12] + e[31] * e[32] * e[14] - 1.*e[31] * e[33] * e[15] - 1.*e[31] * e[35] * e[17] - 1.*e[31] * e[29] * e[11] - .5000000000*e[13] * ep2[27] + .5000000000*e[13] * ep2[32] + .5000000000*e[13] * ep2[28] - .5000000000*e[13] * ep2[29] + 1.500000000*e[13] * ep2[31] - .5000000000*e[13] * ep2[33] + .5000000000*e[13] * ep2[30] + .5000000000*e[13] * ep2[34] - .5000000000*e[13] * ep2[35];
		A[96] = e[21] * e[23] * e[14] + e[21] * e[22] * e[13] + e[24] * e[21] * e[15] + e[24] * e[23] * e[17] + e[24] * e[14] * e[26] + e[24] * e[22] * e[16] + e[24] * e[13] * e[25] + e[15] * e[22] * e[25] + e[15] * e[23] * e[26] + e[9] * e[19] * e[22] + e[9] * e[18] * e[21] + e[9] * e[20] * e[23] + e[18] * e[20] * e[14] + e[18] * e[11] * e[23] + e[18] * e[19] * e[13] + e[18] * e[10] * e[22] - 1.*e[21] * e[25] * e[16] - 1.*e[21] * e[26] * e[17] - 1.*e[21] * e[20] * e[11] - 1.*e[21] * e[19] * e[10] + 1.500000000*ep2[21] * e[12] + .5000000000*e[12] * ep2[24] - .5000000000*e[12] * ep2[26] + .5000000000*e[12] * ep2[18] + .5000000000*e[12] * ep2[23] - .5000000000*e[12] * ep2[19] - .5000000000*e[12] * ep2[20] + .5000000000*e[12] * ep2[22] - .5000000000*e[12] * ep2[25];
		A[97] = -1.*e[12] * e[29] * e[20] - 1.*e[12] * e[35] * e[26] - 1.*e[12] * e[28] * e[19] - 1.*e[12] * e[34] * e[25] + e[18] * e[29] * e[14] + e[18] * e[11] * e[32] + e[18] * e[28] * e[13] + e[18] * e[10] * e[31] + e[27] * e[20] * e[14] + e[27] * e[11] * e[23] + e[27] * e[19] * e[13] + e[27] * e[10] * e[22] + e[15] * e[30] * e[24] + e[15] * e[21] * e[33] + e[15] * e[31] * e[25] + e[15] * e[22] * e[34] + e[15] * e[32] * e[26] + e[15] * e[23] * e[35] - 1.*e[21] * e[28] * e[10] - 1.*e[21] * e[34] * e[16] - 1.*e[21] * e[35] * e[17] - 1.*e[21] * e[29] * e[11] - 1.*e[30] * e[25] * e[16] - 1.*e[30] * e[26] * e[17] - 1.*e[30] * e[20] * e[11] - 1.*e[30] * e[19] * e[10] + e[24] * e[32] * e[17] + e[24] * e[14] * e[35] + e[24] * e[31] * e[16] + e[24] * e[13] * e[34] + e[33] * e[23] * e[17] + e[33] * e[14] * e[26] + e[33] * e[22] * e[16] + e[33] * e[13] * e[25] + 3.*e[12] * e[30] * e[21] + e[12] * e[31] * e[22] + e[12] * e[32] * e[23] + e[9] * e[27] * e[21] + e[9] * e[18] * e[30] + e[9] * e[28] * e[22] + e[9] * e[19] * e[31] + e[9] * e[29] * e[23] + e[9] * e[20] * e[32] + e[21] * e[32] * e[14] + e[21] * e[31] * e[13] + e[30] * e[23] * e[14] + e[30] * e[22] * e[13] + e[12] * e[27] * e[18] + e[12] * e[33] * e[24];
		A[98] = e[0] * e[11] * e[5] + e[0] * e[2] * e[14] + e[9] * e[1] * e[4] + e[9] * e[0] * e[3] + e[9] * e[2] * e[5] + e[3] * e[13] * e[4] + e[3] * e[14] * e[5] + e[6] * e[3] * e[15] + e[6] * e[13] * e[7] + e[6] * e[4] * e[16] + e[6] * e[14] * e[8] + e[6] * e[5] * e[17] + e[15] * e[4] * e[7] + e[15] * e[5] * e[8] - 1.*e[3] * e[11] * e[2] - 1.*e[3] * e[10] * e[1] - 1.*e[3] * e[16] * e[7] - 1.*e[3] * e[17] * e[8] + e[0] * e[10] * e[4] + e[0] * e[1] * e[13] + 1.500000000*e[12] * ep2[3] + .5000000000*e[12] * ep2[4] + .5000000000*e[12] * ep2[5] + .5000000000*e[12] * ep2[6] + .5000000000*ep2[0] * e[12] - .5000000000*e[12] * ep2[1] - .5000000000*e[12] * ep2[7] - .5000000000*e[12] * ep2[2] - .5000000000*e[12] * ep2[8];
		A[99] = e[21] * e[24] * e[6] + e[0] * e[19] * e[22] + e[0] * e[20] * e[23] + e[24] * e[22] * e[7] + e[24] * e[4] * e[25] + e[24] * e[23] * e[8] + e[24] * e[5] * e[26] + e[6] * e[22] * e[25] + e[6] * e[23] * e[26] + e[18] * e[0] * e[21] + e[18] * e[19] * e[4] + e[18] * e[1] * e[22] + e[18] * e[20] * e[5] + e[18] * e[2] * e[23] + e[21] * e[22] * e[4] + e[21] * e[23] * e[5] - 1.*e[21] * e[26] * e[8] - 1.*e[21] * e[20] * e[2] - 1.*e[21] * e[19] * e[1] - 1.*e[21] * e[25] * e[7] + 1.500000000*ep2[21] * e[3] + .5000000000*e[3] * ep2[22] + .5000000000*e[3] * ep2[23] + .5000000000*e[3] * ep2[24] - .5000000000*e[3] * ep2[26] - .5000000000*e[3] * ep2[19] - .5000000000*e[3] * ep2[20] - .5000000000*e[3] * ep2[25] + .5000000000*ep2[18] * e[3];
		A[127] = e[11] * e[27] * e[12] + e[11] * e[9] * e[30] + e[11] * e[29] * e[14] + e[11] * e[28] * e[13] + e[11] * e[10] * e[31] + e[29] * e[9] * e[12] + e[29] * e[10] * e[13] + e[14] * e[30] * e[12] + e[14] * e[31] * e[13] + e[17] * e[30] * e[15] + e[17] * e[12] * e[33] + e[17] * e[14] * e[35] + e[17] * e[31] * e[16] + e[17] * e[13] * e[34] + e[35] * e[12] * e[15] + e[35] * e[13] * e[16] - 1.*e[14] * e[27] * e[9] - 1.*e[14] * e[28] * e[10] - 1.*e[14] * e[33] * e[15] - 1.*e[14] * e[34] * e[16] + .5000000000*ep2[11] * e[32] - .5000000000*e[32] * ep2[16] - .5000000000*e[32] * ep2[9] + .5000000000*e[32] * ep2[12] - .5000000000*e[32] * ep2[15] + .5000000000*e[32] * ep2[17] - .5000000000*e[32] * ep2[10] + 1.500000000*e[32] * ep2[14] + .5000000000*e[32] * ep2[13];
		A[126] = e[8] * e[3] * e[6] + .5000000000*ep2[2] * e[5] - .5000000000*e[5] * ep2[0] + .5000000000*e[5] * ep2[4] - .5000000000*e[5] * ep2[6] + .5000000000*e[5] * ep2[8] + e[8] * e[4] * e[7] + .5000000000*ep3[5] + e[2] * e[0] * e[3] + .5000000000*e[5] * ep2[3] - .5000000000*e[5] * ep2[7] + e[2] * e[1] * e[4] - .5000000000*e[5] * ep2[1];
		A[125] = e[2] * e[27] * e[3] + e[2] * e[0] * e[30] + e[2] * e[28] * e[4] + e[2] * e[1] * e[31] + e[2] * e[29] * e[5] - 1.*e[5] * e[27] * e[0] - 1.*e[5] * e[34] * e[7] - 1.*e[5] * e[33] * e[6] + e[5] * e[30] * e[3] + e[5] * e[35] * e[8] - 1.*e[5] * e[28] * e[1] + e[5] * e[31] * e[4] + e[29] * e[1] * e[4] + e[29] * e[0] * e[3] + e[8] * e[30] * e[6] + e[8] * e[3] * e[33] + e[8] * e[31] * e[7] + e[8] * e[4] * e[34] + e[35] * e[4] * e[7] + e[35] * e[3] * e[6] + .5000000000*ep2[2] * e[32] + 1.500000000*e[32] * ep2[5] + .5000000000*e[32] * ep2[4] - .5000000000*e[32] * ep2[0] - .5000000000*e[32] * ep2[6] - .5000000000*e[32] * ep2[1] - .5000000000*e[32] * ep2[7] + .5000000000*e[32] * ep2[3] + .5000000000*e[32] * ep2[8];
		A[124] = -1.*e[14] * e[19] * e[1] + e[14] * e[22] * e[4] - 1.*e[14] * e[18] * e[0] - 1.*e[14] * e[25] * e[7] - 1.*e[14] * e[24] * e[6] - 1.*e[23] * e[10] * e[1] + e[23] * e[13] * e[4] - 1.*e[23] * e[16] * e[7] - 1.*e[23] * e[15] * e[6] - 1.*e[23] * e[9] * e[0] + e[23] * e[12] * e[3] + e[17] * e[21] * e[6] + e[17] * e[3] * e[24] + e[17] * e[22] * e[7] + e[17] * e[4] * e[25] + e[17] * e[5] * e[26] - 1.*e[5] * e[24] * e[15] - 1.*e[5] * e[25] * e[16] - 1.*e[5] * e[18] * e[9] - 1.*e[5] * e[19] * e[10] + e[26] * e[12] * e[6] + e[26] * e[3] * e[15] + e[26] * e[13] * e[7] + e[26] * e[4] * e[16] + e[11] * e[18] * e[3] + e[11] * e[0] * e[21] + e[11] * e[19] * e[4] + e[11] * e[1] * e[22] + e[11] * e[20] * e[5] + e[11] * e[2] * e[23] + e[20] * e[9] * e[3] + e[20] * e[0] * e[12] + e[20] * e[10] * e[4] + e[20] * e[1] * e[13] + e[20] * e[2] * e[14] + e[5] * e[21] * e[12] + 3.*e[5] * e[23] * e[14] + e[5] * e[22] * e[13] + e[8] * e[21] * e[15] + e[8] * e[12] * e[24] + e[8] * e[23] * e[17] + e[8] * e[14] * e[26] + e[8] * e[22] * e[16] + e[8] * e[13] * e[25] + e[2] * e[18] * e[12] + e[2] * e[9] * e[21] + e[2] * e[19] * e[13] + e[2] * e[10] * e[22] + e[14] * e[21] * e[3];
		A[123] = -.5000000000*e[14] * ep2[27] + 1.500000000*e[14] * ep2[32] - .5000000000*e[14] * ep2[28] + .5000000000*e[14] * ep2[29] + .5000000000*e[14] * ep2[31] - .5000000000*e[14] * ep2[33] + .5000000000*e[14] * ep2[30] - .5000000000*e[14] * ep2[34] + .5000000000*e[14] * ep2[35] + e[11] * e[27] * e[30] + e[11] * e[29] * e[32] + e[11] * e[28] * e[31] + e[35] * e[30] * e[15] + e[35] * e[12] * e[33] + e[35] * e[32] * e[17] + e[35] * e[31] * e[16] + e[35] * e[13] * e[34] + e[29] * e[27] * e[12] + e[29] * e[9] * e[30] + e[29] * e[28] * e[13] + e[29] * e[10] * e[31] - 1.*e[32] * e[27] * e[9] + e[32] * e[30] * e[12] - 1.*e[32] * e[28] * e[10] + e[32] * e[31] * e[13] - 1.*e[32] * e[33] * e[15] - 1.*e[32] * e[34] * e[16] + e[17] * e[30] * e[33] + e[17] * e[31] * e[34];
		A[122] = -.5000000000*e[23] * ep2[33] - .5000000000*e[23] * ep2[34] + .5000000000*ep2[29] * e[23] + .5000000000*e[23] * ep2[30] + 1.500000000*e[23] * ep2[32] + .5000000000*e[23] * ep2[31] + .5000000000*e[23] * ep2[35] - .5000000000*e[23] * ep2[27] - .5000000000*e[23] * ep2[28] + e[32] * e[30] * e[21] + e[32] * e[31] * e[22] + e[26] * e[30] * e[33] + e[26] * e[32] * e[35] + e[26] * e[31] * e[34] + e[35] * e[30] * e[24] + e[35] * e[21] * e[33] + e[35] * e[31] * e[25] + e[35] * e[22] * e[34] - 1.*e[32] * e[27] * e[18] - 1.*e[32] * e[33] * e[24] - 1.*e[32] * e[28] * e[19] - 1.*e[32] * e[34] * e[25] + e[20] * e[27] * e[30] + e[20] * e[29] * e[32] + e[20] * e[28] * e[31] + e[29] * e[27] * e[21] + e[29] * e[18] * e[30] + e[29] * e[28] * e[22] + e[29] * e[19] * e[31];
		A[121] = e[2] * e[27] * e[30] + e[2] * e[29] * e[32] + e[2] * e[28] * e[31] + e[32] * e[30] * e[3] + e[32] * e[31] * e[4] + e[8] * e[30] * e[33] + e[8] * e[32] * e[35] + e[8] * e[31] * e[34] + e[29] * e[27] * e[3] + e[29] * e[0] * e[30] + e[29] * e[28] * e[4] + e[29] * e[1] * e[31] + e[35] * e[30] * e[6] + e[35] * e[3] * e[33] + e[35] * e[31] * e[7] + e[35] * e[4] * e[34] - 1.*e[32] * e[27] * e[0] - 1.*e[32] * e[34] * e[7] - 1.*e[32] * e[33] * e[6] - 1.*e[32] * e[28] * e[1] + .5000000000*e[5] * ep2[30] + 1.500000000*e[5] * ep2[32] + .5000000000*e[5] * ep2[31] - .5000000000*e[5] * ep2[27] - .5000000000*e[5] * ep2[28] + .5000000000*e[5] * ep2[29] - .5000000000*e[5] * ep2[33] - .5000000000*e[5] * ep2[34] + .5000000000*e[5] * ep2[35];
		A[120] = .5000000000*e[32] * ep2[31] + .5000000000*e[32] * ep2[35] - .5000000000*e[32] * ep2[27] + e[29] * e[27] * e[30] + e[29] * e[28] * e[31] + e[35] * e[30] * e[33] + e[35] * e[31] * e[34] + .5000000000*ep2[29] * e[32] + .5000000000*ep3[32] - .5000000000*e[32] * ep2[33] - .5000000000*e[32] * ep2[34] + .5000000000*e[32] * ep2[30] - .5000000000*e[32] * ep2[28];
		A[118] = e[10] * e[1] * e[4] + e[10] * e[0] * e[3] + e[10] * e[2] * e[5] + e[4] * e[12] * e[3] + e[4] * e[14] * e[5] + e[7] * e[12] * e[6] + e[7] * e[3] * e[15] + e[7] * e[4] * e[16] + e[7] * e[14] * e[8] + e[7] * e[5] * e[17] + e[16] * e[3] * e[6] + e[16] * e[5] * e[8] - 1.*e[4] * e[11] * e[2] - 1.*e[4] * e[15] * e[6] - 1.*e[4] * e[9] * e[0] - 1.*e[4] * e[17] * e[8] + e[1] * e[9] * e[3] + e[1] * e[0] * e[12] + e[1] * e[11] * e[5] + e[1] * e[2] * e[14] + 1.500000000*e[13] * ep2[4] + .5000000000*e[13] * ep2[3] + .5000000000*e[13] * ep2[5] + .5000000000*e[13] * ep2[7] + .5000000000*ep2[1] * e[13] - .5000000000*e[13] * ep2[0] - .5000000000*e[13] * ep2[6] - .5000000000*e[13] * ep2[2] - .5000000000*e[13] * ep2[8];
		A[119] = e[25] * e[21] * e[6] + e[25] * e[3] * e[24] + e[25] * e[23] * e[8] + e[25] * e[5] * e[26] + e[7] * e[21] * e[24] + e[7] * e[23] * e[26] + e[19] * e[18] * e[3] + e[19] * e[0] * e[21] + e[19] * e[1] * e[22] + e[19] * e[20] * e[5] + e[19] * e[2] * e[23] + e[22] * e[21] * e[3] + e[22] * e[23] * e[5] - 1.*e[22] * e[26] * e[8] - 1.*e[22] * e[20] * e[2] - 1.*e[22] * e[18] * e[0] + e[22] * e[25] * e[7] - 1.*e[22] * e[24] * e[6] + e[1] * e[18] * e[21] + e[1] * e[20] * e[23] + .5000000000*e[4] * ep2[25] - .5000000000*e[4] * ep2[26] - .5000000000*e[4] * ep2[18] - .5000000000*e[4] * ep2[20] - .5000000000*e[4] * ep2[24] + .5000000000*ep2[19] * e[4] + 1.500000000*ep2[22] * e[4] + .5000000000*e[4] * ep2[21] + .5000000000*e[4] * ep2[23];
		A[116] = e[22] * e[21] * e[12] + e[22] * e[23] * e[14] + e[25] * e[21] * e[15] + e[25] * e[12] * e[24] + e[25] * e[23] * e[17] + e[25] * e[14] * e[26] + e[25] * e[22] * e[16] + e[16] * e[21] * e[24] + e[16] * e[23] * e[26] + e[10] * e[19] * e[22] + e[10] * e[18] * e[21] + e[10] * e[20] * e[23] + e[19] * e[18] * e[12] + e[19] * e[9] * e[21] + e[19] * e[20] * e[14] + e[19] * e[11] * e[23] - 1.*e[22] * e[24] * e[15] - 1.*e[22] * e[26] * e[17] - 1.*e[22] * e[20] * e[11] - 1.*e[22] * e[18] * e[9] - .5000000000*e[13] * ep2[26] - .5000000000*e[13] * ep2[18] + .5000000000*e[13] * ep2[23] + .5000000000*e[13] * ep2[19] - .5000000000*e[13] * ep2[20] - .5000000000*e[13] * ep2[24] + .5000000000*e[13] * ep2[21] + 1.500000000*ep2[22] * e[13] + .5000000000*e[13] * ep2[25];
		A[117] = e[13] * e[30] * e[21] + 3.*e[13] * e[31] * e[22] + e[13] * e[32] * e[23] + e[10] * e[27] * e[21] + e[10] * e[18] * e[30] + e[10] * e[28] * e[22] + e[10] * e[19] * e[31] + e[10] * e[29] * e[23] + e[10] * e[20] * e[32] + e[22] * e[30] * e[12] + e[22] * e[32] * e[14] + e[31] * e[21] * e[12] + e[31] * e[23] * e[14] - 1.*e[13] * e[27] * e[18] - 1.*e[13] * e[33] * e[24] - 1.*e[13] * e[29] * e[20] - 1.*e[13] * e[35] * e[26] + e[13] * e[28] * e[19] + e[13] * e[34] * e[25] + e[19] * e[27] * e[12] + e[19] * e[9] * e[30] + e[19] * e[29] * e[14] + e[19] * e[11] * e[32] + e[28] * e[18] * e[12] + e[28] * e[9] * e[21] + e[28] * e[20] * e[14] + e[28] * e[11] * e[23] + e[16] * e[30] * e[24] + e[16] * e[21] * e[33] + e[16] * e[31] * e[25] + e[16] * e[22] * e[34] + e[16] * e[32] * e[26] + e[16] * e[23] * e[35] - 1.*e[22] * e[27] * e[9] - 1.*e[22] * e[33] * e[15] - 1.*e[22] * e[35] * e[17] - 1.*e[22] * e[29] * e[11] - 1.*e[31] * e[24] * e[15] - 1.*e[31] * e[26] * e[17] - 1.*e[31] * e[20] * e[11] - 1.*e[31] * e[18] * e[9] + e[25] * e[30] * e[15] + e[25] * e[12] * e[33] + e[25] * e[32] * e[17] + e[25] * e[14] * e[35] + e[34] * e[21] * e[15] + e[34] * e[12] * e[24] + e[34] * e[23] * e[17] + e[34] * e[14] * e[26];
		A[114] = e[19] * e[11] * e[14] + e[19] * e[9] * e[12] + e[19] * e[10] * e[13] + e[13] * e[21] * e[12] + e[13] * e[23] * e[14] + e[16] * e[21] * e[15] + e[16] * e[12] * e[24] + e[16] * e[23] * e[17] + e[16] * e[14] * e[26] + e[16] * e[13] * e[25] + e[25] * e[14] * e[17] + e[25] * e[12] * e[15] - 1.*e[13] * e[24] * e[15] - 1.*e[13] * e[26] * e[17] - 1.*e[13] * e[20] * e[11] - 1.*e[13] * e[18] * e[9] + e[10] * e[18] * e[12] + e[10] * e[9] * e[21] + e[10] * e[20] * e[14] + e[10] * e[11] * e[23] + 1.500000000*e[22] * ep2[13] + .5000000000*e[22] * ep2[14] + .5000000000*e[22] * ep2[12] + .5000000000*e[22] * ep2[16] + .5000000000*ep2[10] * e[22] - .5000000000*e[22] * ep2[9] - .5000000000*e[22] * ep2[11] - .5000000000*e[22] * ep2[15] - .5000000000*e[22] * ep2[17];
		A[115] = e[13] * e[12] * e[3] + e[13] * e[14] * e[5] + e[16] * e[12] * e[6] + e[16] * e[3] * e[15] + e[16] * e[13] * e[7] + e[16] * e[14] * e[8] + e[16] * e[5] * e[17] + e[7] * e[14] * e[17] + e[7] * e[12] * e[15] + e[1] * e[11] * e[14] + e[1] * e[9] * e[12] + e[1] * e[10] * e[13] + e[10] * e[9] * e[3] + e[10] * e[0] * e[12] + e[10] * e[11] * e[5] + e[10] * e[2] * e[14] - 1.*e[13] * e[11] * e[2] - 1.*e[13] * e[15] * e[6] - 1.*e[13] * e[9] * e[0] - 1.*e[13] * e[17] * e[8] + 1.500000000*ep2[13] * e[4] + .5000000000*e[4] * ep2[16] - .5000000000*e[4] * ep2[9] - .5000000000*e[4] * ep2[11] + .5000000000*e[4] * ep2[12] - .5000000000*e[4] * ep2[15] - .5000000000*e[4] * ep2[17] + .5000000000*e[4] * ep2[10] + .5000000000*e[4] * ep2[14];
		A[112] = e[19] * e[1] * e[4] + e[19] * e[0] * e[3] + e[19] * e[2] * e[5] + e[4] * e[21] * e[3] + e[4] * e[23] * e[5] + e[7] * e[21] * e[6] + e[7] * e[3] * e[24] + e[7] * e[4] * e[25] + e[7] * e[23] * e[8] + e[7] * e[5] * e[26] + e[25] * e[3] * e[6] + e[25] * e[5] * e[8] + e[1] * e[18] * e[3] + e[1] * e[0] * e[21] + e[1] * e[20] * e[5] + e[1] * e[2] * e[23] - 1.*e[4] * e[26] * e[8] - 1.*e[4] * e[20] * e[2] - 1.*e[4] * e[18] * e[0] - 1.*e[4] * e[24] * e[6] + 1.500000000*e[22] * ep2[4] - .5000000000*e[22] * ep2[0] - .5000000000*e[22] * ep2[6] + .5000000000*e[22] * ep2[5] + .5000000000*e[22] * ep2[1] + .5000000000*e[22] * ep2[7] + .5000000000*e[22] * ep2[3] - .5000000000*e[22] * ep2[2] - .5000000000*e[22] * ep2[8];
		A[113] = -1.*e[31] * e[20] * e[2] - 1.*e[31] * e[18] * e[0] + e[31] * e[23] * e[5] - 1.*e[31] * e[24] * e[6] + e[7] * e[30] * e[24] + e[7] * e[21] * e[33] + e[7] * e[32] * e[26] + e[7] * e[23] * e[35] + e[25] * e[30] * e[6] + e[25] * e[3] * e[33] + e[25] * e[31] * e[7] + e[25] * e[4] * e[34] + e[25] * e[32] * e[8] + e[25] * e[5] * e[35] + e[34] * e[21] * e[6] + e[34] * e[3] * e[24] + e[34] * e[22] * e[7] + e[34] * e[23] * e[8] + e[34] * e[5] * e[26] + e[1] * e[27] * e[21] + e[1] * e[18] * e[30] + e[1] * e[28] * e[22] + e[1] * e[19] * e[31] + e[1] * e[29] * e[23] + e[1] * e[20] * e[32] + e[19] * e[27] * e[3] + e[19] * e[0] * e[30] + e[19] * e[28] * e[4] + e[19] * e[29] * e[5] + e[19] * e[2] * e[32] + e[28] * e[18] * e[3] + e[28] * e[0] * e[21] + e[28] * e[20] * e[5] + e[28] * e[2] * e[23] + e[4] * e[30] * e[21] + 3.*e[4] * e[31] * e[22] + e[4] * e[32] * e[23] - 1.*e[4] * e[27] * e[18] - 1.*e[4] * e[33] * e[24] - 1.*e[4] * e[29] * e[20] - 1.*e[4] * e[35] * e[26] - 1.*e[22] * e[27] * e[0] + e[22] * e[32] * e[5] - 1.*e[22] * e[33] * e[6] + e[22] * e[30] * e[3] - 1.*e[22] * e[35] * e[8] - 1.*e[22] * e[29] * e[2] + e[31] * e[21] * e[3] - 1.*e[31] * e[26] * e[8];

		int perm[20] = { 6, 8, 18, 15, 12, 5, 14, 7, 4, 11, 19, 13, 1, 16, 17, 3, 10, 9, 2, 0 };
		double AA[200];
		for (int i = 0; i < 20; i++)
		{
			for (int j = 0; j < 10; j++) AA[i + j * 20] = A[perm[i] + j * 20];
		}

		for (int i = 0; i < 200; i++)
		{
			A[i] = AA[i];
		}
	}
	virtual void computeReprojError(const CvMat* m1, const CvMat* m2, const CvMat* model, CvMat* error)
	{
		// Same as the runKernel (run5Point), m1 and m2 should be 1 row x n col x 2 channels. And also, error has to be of CV_32FC1.
		Mat X1 = cvarrToMat(m1), X2 = cvarrToMat(m2);
		int n = X1.cols;
		X1 = X1.reshape(1, n);
		X2 = X2.reshape(1, n);

		X1.convertTo(X1, CV_64F);
		X2.convertTo(X2, CV_64F);

		Mat E = cvarrToMat(model);
		for (int i = 0; i < n; i++)
		{
			Mat x1 = (Mat_<double>(3, 1) << X1.at<double>(i, 0), X1.at<double>(i, 1), 1.0);
			Mat x2 = (Mat_<double>(3, 1) << X2.at<double>(i, 0), X2.at<double>(i, 1), 1.0);
			double x2tEx1 = x2.dot(E * x1);
			Mat Ex1 = E * x1;
			Mat Etx2 = E * x2;
			double a = Ex1.at<double>(0) * Ex1.at<double>(0);
			double b = Ex1.at<double>(1) * Ex1.at<double>(1);
			double c = Etx2.at<double>(0) * Etx2.at<double>(0);
			double d = Etx2.at<double>(0) * Etx2.at<double>(0);

			error->data.fl[i] = x2tEx1 * x2tEx1 / (a + b + c + d);
		}
	}
};*/


// Input should be a vector of n 2D points or a Nx2 matrix
/*cv::Mat findEssentialMat(InputArray _points1, InputArray _points2, cv::Mat K1, cv::Mat K2, int method, double prob, double threshold, int maxIters, OutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);

	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 5);
	CV_Assert(points2.checkVector(2) == npoints);
	CV_Assert(points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	double f1 = K1.at<double>(0), f2 = K2.at<double>(0), u1 = K1.at<double>(2), v1 = K1.at<double>(4);
	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	// Reshape data to fit opencv ransac function
	points1 = points1.reshape(2, 1);
	points2 = points2.reshape(2, 1);

	Mat E(3, 3, CV_64F);
	//CvEMEstimator estimator;

	CvMat p1 = points1;
	CvMat p2 = points2;
	CvMat _E = E;
	CvMat* tempMask = cvCreateMat(1, npoints, CV_8U);

	assert(npoints >= 5);
	threshold /= 0.25*(K1.at<double>(0) + K1.at<double>(4) + K2.at<double>(0) + K2.at<double>(4));
	int count = 1;
	if (npoints == 5)
	{
		E.create(3 * 10, 3, CV_64F);
		_E = E;
		//Minh: count = estimator.runKernel(&p1, &p2, &_E);
		E = E.rowRange(0, 3 * count) * 1.0;
		Mat mask = cvarrToMat(tempMask).setTo(true);
	}
	else if (method == CV_RANSAC)
		;//Minh:  estimator.runRANSAC(&p1, &p2, &_E, tempMask, threshold, prob, maxIters);
	else
		;//Minh: estimator.runLMeDS(&p1, &p2, &_E, tempMask, prob);

	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		mask = cvarrToMat(tempMask).clone();
	}

	return E;
}*/

cv::Mat findEssentialMat(InputArray _points1, InputArray _points2, InputArray _cameraMatrix1, InputArray _cameraMatrix2, int method, double prob, double threshold, OutputArray _mask)
{
	Mat points1, points2, cameraMatrix1, cameraMatrix2;
	_points1.getMat().convertTo(points1, CV_64F);
	_points2.getMat().convertTo(points2, CV_64F);
	_cameraMatrix1.getMat().convertTo(cameraMatrix1, CV_64F);
	_cameraMatrix2.getMat().convertTo(cameraMatrix2, CV_64F);

	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 0 && points2.checkVector(2) == npoints && points1.type() == points2.type());

	CV_Assert(cameraMatrix1.rows == 3 && cameraMatrix1.cols == 3 && cameraMatrix1.channels() == 1);
	CV_Assert(cameraMatrix2.rows == 3 && cameraMatrix2.cols == 3 && cameraMatrix2.channels() == 1);

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}

	double fx1 = cameraMatrix1.at<double>(0, 0),
		fy1 = cameraMatrix1.at<double>(1, 1),
		cx1 = cameraMatrix1.at<double>(0, 2),
		cy1 = cameraMatrix1.at<double>(1, 2);

	double fx2 = cameraMatrix2.at<double>(0, 0),
		fy2 = cameraMatrix2.at<double>(1, 1),
		cx2 = cameraMatrix2.at<double>(0, 2),
		cy2 = cameraMatrix2.at<double>(1, 2);

	points1.col(0) = (points1.col(0) - cx1) / fx1;
	points1.col(1) = (points1.col(1) - cy1) / fy1;
	points2.col(0) = (points2.col(0) - cx2) / fx2;
	points2.col(1) = (points2.col(1) - cy2) / fy2;

	// Reshape data to fit opencv ransac function
	points1 = points1.reshape(2, npoints);
	points2 = points2.reshape(2, npoints);

	threshold /= (fx1 + fy1+ fx2+fy2) / 4;

	Mat E = cv::findEssentialMat(points1, points2, 1.0, Point2d(0, 0), method, prob, threshold, _mask);

	return E;
}

void decomposeEssentialMat(const Mat & E, Mat & R1, Mat & R2, Mat & t)
{
	assert(E.cols == 3 && E.rows == 3);
	Mat D, U, Vt;
	SVD::compute(E, D, U, Vt);
	if (determinant(U) < 0) U = -U;
	if (determinant(Vt) < 0) Vt = -Vt;
	Mat W = (Mat_<double>(3, 3) << 0, 1, 0, -1, 0, 0, 0, 0, 1);
	W.convertTo(W, E.type());
	R1 = U * W * Vt;
	R2 = U * W.t() * Vt;
	t = U.col(2) * 1.0;
}
int recoverPose(const Mat & E, InputArray _points1, InputArray _points2, Mat & _R, Mat & _t, Mat K1, Mat K2, InputOutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);
	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 0 && points2.checkVector(2) == npoints &&
		points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	points1 = points1.t();
	points2 = points2.t();

	Mat R1, R2, t;
	decomposeEssentialMat(E, R1, R2, t);
	Mat P0 = Mat::eye(3, 4, R1.type());
	Mat P1(3, 4, R1.type()), P2(3, 4, R1.type()), P3(3, 4, R1.type()), P4(3, 4, R1.type());
	P1(Range::all(), Range(0, 3)) = R1 * 1.0; P1.col(3) = t * 1.0;
	P2(Range::all(), Range(0, 3)) = R2 * 1.0; P2.col(3) = t * 1.0;
	P3(Range::all(), Range(0, 3)) = R1 * 1.0; P3.col(3) = -t * 1.0;
	P4(Range::all(), Range(0, 3)) = R2 * 1.0; P4.col(3) = -t * 1.0;

	// Do the cheirality check: Notice here a threshold dist is used to filter out far away points (i.e. infinite points) since there depth may vary between postive and negtive. 
	double dist = 50.0;
	Mat Q;
	triangulatePoints(P0, P1, points1, points2, Q);
	Mat mask1 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3), Q.row(1) /= Q.row(3), Q.row(2) /= Q.row(3), Q.row(3) /= Q.row(3);
	mask1 = (Q.row(2) < dist) & mask1;
	Q = P1 * Q;
	mask1 = (Q.row(2) > 0) & mask1;
	mask1 = (Q.row(2) < dist) & mask1;

	triangulatePoints(P0, P2, points1, points2, Q);
	Mat mask2 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3), Q.row(1) /= Q.row(3), Q.row(2) /= Q.row(3), Q.row(3) /= Q.row(3);
	mask2 = (Q.row(2) < dist) & mask2;
	Q = P2 * Q;
	mask2 = (Q.row(2) > 0) & mask2;
	mask2 = (Q.row(2) < dist) & mask2;

	triangulatePoints(P0, P3, points1, points2, Q);
	Mat mask3 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3), Q.row(1) /= Q.row(3), Q.row(2) /= Q.row(3), Q.row(3) /= Q.row(3);
	mask3 = (Q.row(2) < dist) & mask3;
	Q = P3 * Q;
	mask3 = (Q.row(2) > 0) & mask3;
	mask3 = (Q.row(2) < dist) & mask3;

	triangulatePoints(P0, P4, points1, points2, Q);
	Mat mask4 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3), Q.row(1) /= Q.row(3), Q.row(2) /= Q.row(3), Q.row(3) /= Q.row(3);
	mask4 = (Q.row(2) < dist) & mask4;
	Q = P4 * Q;
	mask4 = (Q.row(2) > 0) & mask4;
	mask4 = (Q.row(2) < dist) & mask4;

	// If _mask is given, then use it to filter outliers. 
	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		bitwise_and(mask, mask1, mask1), bitwise_and(mask, mask2, mask2), bitwise_and(mask, mask3, mask3), bitwise_and(mask, mask4, mask4);
	}

	int good1 = countNonZero(mask1), good2 = countNonZero(mask2), good3 = countNonZero(mask3), good4 = countNonZero(mask4);
	if (max(good1, max(good2, max(good3, good4))) < 5)
		return 0;
	if (good1 >= good2 && good1 >= good3 && good1 >= good4)
	{
		_R = R1; _t = t;
		if (_mask.needed()) mask1.copyTo(_mask.getMat());
		return good1;
	}
	else if (good2 >= good1 && good2 >= good3 && good2 >= good4)
	{
		_R = R2; _t = t;
		if (_mask.needed()) mask2.copyTo(_mask.getMat());
		return good2;
	}
	else if (good3 >= good1 && good3 >= good2 && good3 >= good4)
	{
		_R = R1; _t = -t;
		if (_mask.needed()) mask3.copyTo(_mask.getMat());
		return good3;
	}
	else
	{
		_R = R2; _t = -t;
		if (_mask.needed()) mask4.copyTo(_mask.getMat());
		return good4;
	}

}

int USAC_FindFundamentalMatrix(ConfigParamsFund cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Fmat, vector<int>&InlierIndicator, int &ninlers)
{
	FundMatrixEstimator* fund = new FundMatrixEstimator;
	fund->initParamsUSAC(cfg);

	// set up the fundamental matrix estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (unsigned int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	fund->initDataUSAC(cfg);
	fund->initProblem(cfg, &point_data[0]);
	if (!fund->solve())
		return 1;

	// write out results
	ninlers = fund->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Fmat[3 * i + j] = fund->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(fund->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	fund->cleanupProblem();
	delete fund;

	return 0;
}
int USAC_FindHomography(ConfigParamsHomog cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Hmat, vector<int>&InlierIndicator, int &ninlers)
{
	HomogEstimator* homog = new HomogEstimator;
	homog->initParamsUSAC(cfg);

	// set up the homography estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	homog->initDataUSAC(cfg);
	homog->initProblem(cfg, &point_data[0]);
	if (!homog->solve())
		return 1;

	// write out results
	ninlers = homog->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Hmat[3 * i + j] = homog->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(homog->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	homog->cleanupProblem();
	delete homog;

	return 0;
}

/*int P4Pf_RANSAC(CameraData &camera, vector<int> &BestInliers, vector<Point3d> &Vxyz, vector<Point2d> &Vuv, int width, int height, int LensModel, int MaxIter, int nInlierThresh, double thresh)
{
int npts = (int)Vxyz.size();
if (npts < 4)
return 0; //failure

double thresh2 = thresh*thresh;
camera.threshold = thresh;
camera.LensModel = 0;

vector<bool> Good;
vector<int>ids(npts);
vector<double> Vscale(npts);
for (int ii = 0; ii < npts; ii++)
ids[ii] = ii, Vscale[ii] = 1.0;

//compute normalized image coord
Point2d *iP2d = new Point2d[npts];
Point3d *iP3d = new Point3d[npts];

vector<double> focal_length;
vector<Matrix<double, 3, 3> > soln_rotation;
vector<Vector3d > soln_translation;
vector<Vector3d> world_points_vector(4);
vector<Eigen::Vector2d> image_points_vector(4);

int nBestInliers = 0;
vector<int> Inliers;
double _intrinisc[5], _rt[6];

int iter = 0;
while (iter < MaxIter)
{
iter++;
std::random_shuffle(ids.begin(), ids.end());

for (int ii = 0; ii < 4; ii++)
image_points_vector[ii] = Vector2d(Vuv[ids[ii]].x - width / 2, Vuv[ids[ii]].y - height / 2), world_points_vector[ii] = Vector3d(Vxyz[ids[ii]].x, Vxyz[ids[ii]].y, Vxyz[ids[ii]].z); //p4pf is build for K = diag(f,f, 1);

focal_length.clear(), soln_rotation.clear(), soln_translation.clear();
int nresults = FourPointPoseAndFocalLength(image_points_vector, world_points_vector, focal_length, &soln_rotation, &soln_translation);
for (int jj = 0; jj < nresults; jj++)
{
//eliminate solutions that do not even project to the input
camera.K[0] = focal_length[jj], camera.K[1] = 0, camera.K[2] = 0,
camera.K[3] = 0, camera.K[4] = focal_length[jj], camera.K[5] = 0,
camera.K[6] = 0, camera.K[7] = 0, camera.K[8] = 1;

camera.R[0] = soln_rotation[jj].coeff(0, 0), camera.R[1] = soln_rotation[jj].coeff(0, 1), camera.R[2] = soln_rotation[jj].coeff(0, 2),
camera.R[3] = soln_rotation[jj].coeff(1, 0), camera.R[4] = soln_rotation[jj].coeff(1, 1), camera.R[5] = soln_rotation[jj].coeff(1, 2),
camera.R[6] = soln_rotation[jj].coeff(2, 0), camera.R[7] = soln_rotation[jj].coeff(2, 1), camera.R[8] = soln_rotation[jj].coeff(2, 2);
camera.T[0] = soln_translation[jj].coeff(0), camera.T[1] = soln_translation[jj].coeff(1), camera.T[2] = soln_translation[jj].coeff(2);

AssembleP(camera.K, camera.R, camera.T, camera.P);

bool good = true;
for (int n = 0; n < 4; n++)
{
double numx = camera.P[0] * Vxyz[ids[n]].x + camera.P[1] * Vxyz[ids[n]].y + camera.P[2] * Vxyz[ids[n]].z + camera.P[3];
double numy = camera.P[4] * Vxyz[ids[n]].x + camera.P[5] * Vxyz[ids[n]].y + camera.P[6] * Vxyz[ids[n]].z + camera.P[7];
double denum = camera.P[8] * Vxyz[ids[n]].x + camera.P[9] * Vxyz[ids[n]].y + camera.P[10] * Vxyz[ids[n]].z + camera.P[11];
double errx = numx / denum - Vuv[ids[n]].x + width / 2, erry = numy / denum - Vuv[ids[n]].y + height / 2; //p4pf is build for K = diag(f,f, 1);
if (errx*errx + erry *erry > thresh2)
{
good = false;
break;
}
}
if (!good)
continue;

Inliers.clear();
for (int kk = 0; kk < npts; kk++)
{
double numx = camera.P[0] * Vxyz[kk].x + camera.P[1] * Vxyz[kk].y + camera.P[2] * Vxyz[kk].z + camera.P[3];
double numy = camera.P[4] * Vxyz[kk].x + camera.P[5] * Vxyz[kk].y + camera.P[6] * Vxyz[kk].z + camera.P[7];
double denum = camera.P[8] * Vxyz[kk].x + camera.P[9] * Vxyz[kk].y + camera.P[10] * Vxyz[kk].z + camera.P[11];
double errx = numx / denum - Vuv[kk].x + width / 2, erry = numy / denum - Vuv[kk].y + height / 2; //p4pf is build for K = diag(f,f, 1);
if (errx*errx + erry *erry < thresh2)
Inliers.push_back(kk);
}

if (nBestInliers < (int)Inliers.size())
{
//Local optimize
for (int kk = 0; kk < (int)Inliers.size(); kk++)
iP2d[kk] = Vuv[Inliers[kk]], iP3d[kk] = Vxyz[Inliers[kk]];

camera.K[2] = width / 2, camera.K[5] = height / 2;
GetIntrinsicFromK(camera);
GetrtFromRT(camera);
for (int kk = 0; kk < 7; kk++)
camera.distortion[kk] = 0;

CameraPose1FrameBA(NULL, camera, Vxyz, Vuv, Vscale, Good, 0, 1, 0, 0, false); //fake the distortion, not robusifier used within RANSAC refinement loop

GetKFromIntrinsic(camera);
GetRTFromrt(camera);
AssembleP(camera.K, camera.R, camera.rt + 3, camera.P);

Inliers.clear();
for (int kk = 0; kk < npts; kk++)
{
double numx = camera.P[0] * Vxyz[kk].x + camera.P[1] * Vxyz[kk].y + camera.P[2] * Vxyz[kk].z + camera.P[3];
double numy = camera.P[4] * Vxyz[kk].x + camera.P[5] * Vxyz[kk].y + camera.P[6] * Vxyz[kk].z + camera.P[7];
double denum = camera.P[8] * Vxyz[kk].x + camera.P[9] * Vxyz[kk].y + camera.P[10] * Vxyz[kk].z + camera.P[11];
double errx = numx / denum - Vuv[kk].x, erry = numy / denum - Vuv[kk].y; //p4pf is build for K = diag(f,f, 1) but its K has been modified
if (errx*errx + erry *erry < thresh2)
Inliers.push_back(kk);
}

for (int kk = 0; kk < 5; kk++)
_intrinisc[kk] = camera.intrinsic[kk];
for (int kk = 0; kk < 6; kk++)
_rt[kk] = camera.rt[kk];

nBestInliers = (int)Inliers.size();
BestInliers = Inliers;
}
}
if (nBestInliers > 0.8*npts)
break;
}

for (int kk = 0; kk < 5; kk++)
camera.intrinsic[kk] = _intrinisc[kk];
for (int kk = 0; kk < 6; kk++)
camera.rt[kk] = _rt[kk];
GetKFromIntrinsic(camera);

delete[]iP2d, delete[]iP3d;

return nBestInliers > nInlierThresh ? 1 : 0;
}*/
//note thate Vuv will be distorted to the raw detection
int PnP_RANSAC(CameraData &camera, vector<int> &BestInliers, vector<Point3d> &Vxyz, vector<Point2d> &Vuv, int width, int height, int LensModel, int MaxIter, int nInlierThresh, double thresh, int fixIntrinsic, int distortionCorrectedMode, int method)
{
	int npts = (int)Vxyz.size();
	int minNpts = 3; //P3P
	if (method == PnP::EPNP)
		minNpts = 4;
	else if (method == PnP::DLS)
		minNpts = 6;
	else if (method == PnP::P4Pf)
		minNpts = 4;

	if (npts < minNpts)
		return 0; //failure

	double thresh2 = thresh * thresh;
	camera.threshold = thresh;

	vector<int> GlobalAnchor; int useGlobalAnchor = 0;
	vector<int>ids(npts);
	vector<double> Vscale(npts);
	for (int ii = 0; ii < npts; ii++)
		ids[ii] = ii, Vscale[ii] = 1.0;

	epnp myPnP;
	if (method == PnP::EPNP)
	{
		myPnP.set_internal_parameters(0.0, 0.0, 1.0, 1.0); //inputs have been normalized
		myPnP.set_maximum_number_of_correspondences(minNpts);
	}

	vector<double> focal_length;
	vector<Matrix<double, 3, 3> > soln_rotation;
	std::vector<Quaterniond> qsoln_rotation;
	vector<Vector3d > soln_translation;
	vector<Vector3d> world_points_vector(minNpts);
	vector<Eigen::Vector2d> image_points_vector(minNpts);

	int nBestInliers = 0;
	vector<int> Inliers;
	Point2d _p2d;
	double R_est[3][3], t_est[3], _intrinisc[5], _rt[6], org_intrinsic[5], org_K[9];
	vector<bool> Good; Good.reserve(npts);
	vector<Point2d> Vuv_raw, Vuv_corrected; Vuv_raw.reserve(npts), Vuv_corrected.reserve(npts);
	vector<double> ReProjectionErrorX, ReProjectionErrorY;

	for (int ii = 0; ii < 5; ii++)
		org_intrinsic[ii] = camera.intrinsic[ii];

	Vuv_raw = Vuv, Vuv_corrected = Vuv;
	org_K[0] = org_intrinsic[0], org_K[1] = org_intrinsic[2], org_K[2] = org_intrinsic[3];
	org_K[3] = 0, org_K[4] = org_intrinsic[1], org_K[5] = org_intrinsic[4];
	org_K[6] = 0, org_K[7] = 0, org_K[8] = 1;
	if (distortionCorrectedMode == 0)
	{
		if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			LensDistortionPoint(Vuv_raw, org_K, camera.distortion);
		else
			FishEyeDistortionPoint(Vuv_raw, org_K, camera.distortion[0]);
	}

	int verbose = 0;
	int iter = 0;
	while (iter < MaxIter)
	{
		iter++;
		std::random_shuffle(ids.begin(), ids.end());

		for (int ii = 0; ii < minNpts; ii++) //compute normalized image cord. Use the very org corrected points here in case the current corrected points are computed from few inliers (inferior model)
		{
			if (method != PnP::P4Pf)
			{
				double ycn = (Vuv[ids[ii]].y - camera.K[5]) / camera.K[4];
				double xcn = (Vuv[ids[ii]].x - camera.K[1] * ycn - camera.K[2]) / camera.K[0];
				image_points_vector[ii] = Vector2d(xcn, ycn), world_points_vector[ii] = Vector3d(Vxyz[ids[ii]].x, Vxyz[ids[ii]].y, Vxyz[ids[ii]].z);
			}
			else
				image_points_vector[ii] = Vector2d(Vuv[ids[ii]].x - width / 2, Vuv[ids[ii]].y - height / 2), world_points_vector[ii] = Vector3d(Vxyz[ids[ii]].x, Vxyz[ids[ii]].y, Vxyz[ids[ii]].z); //p4pf is build for K = diag(f,f, 1);
		}

		focal_length.clear(), soln_rotation.clear(), soln_translation.clear(), qsoln_rotation.clear();
		if (method == PnP::P3P)
			PoseFromThreePoints(&image_points_vector[0], &world_points_vector[0], &soln_rotation, &soln_translation);
		else if (method == PnP::EPNP)
		{
			myPnP.reset_correspondences();
			for (int ii = 0; ii < minNpts; ii++) //compute normalized image cord.
				myPnP.add_correspondence(world_points_vector[ii](0), world_points_vector[ii](1), world_points_vector[ii][2], image_points_vector[ii][0], image_points_vector[ii][1]);

			myPnP.compute_pose(R_est, t_est);

			soln_rotation.resize(1), soln_translation.resize(1);
			for (int ii = 0; ii < 3; ii++)
			{
				for (int jj = 0; jj < 3; jj++)
					soln_rotation[0](jj, ii) = R_est[jj][ii];
				soln_translation[0][ii] = t_est[ii];
			}
		}
		else if (method == PnP::DLS)
		{
			DlsPnp(image_points_vector, world_points_vector, &qsoln_rotation, &soln_translation);
			for (int ii = 0; ii < qsoln_rotation.size(); ii++)
				soln_rotation.push_back(qsoln_rotation[ii].toRotationMatrix());
		}
		else if (method == PnP::P4Pf)
			FourPointPoseAndFocalLength(image_points_vector, world_points_vector, focal_length, &soln_rotation, &soln_translation);

		for (int jj = 0; jj < max(max(soln_translation.size(), soln_rotation.size()), qsoln_rotation.size()); jj++)
		{
			//eliminate solutions that do not even project to the input
			if (method != PnP::P4Pf)
			{
				camera.R[0] = soln_rotation[jj](0, 0), camera.R[1] = soln_rotation[jj](0, 1), camera.R[2] = soln_rotation[jj](0, 2),
					camera.R[3] = soln_rotation[jj](1, 0), camera.R[4] = soln_rotation[jj](1, 1), camera.R[5] = soln_rotation[jj](1, 2),
					camera.R[6] = soln_rotation[jj](2, 0), camera.R[7] = soln_rotation[jj](2, 1), camera.R[8] = soln_rotation[jj](2, 2);
				camera.T[0] = soln_translation[jj](0), camera.T[1] = soln_translation[jj](1), camera.T[2] = soln_translation[jj](2);
			}
			else
			{
				camera.K[0] = focal_length[jj], camera.K[1] = 0, camera.K[2] = 0,
					camera.K[3] = 0, camera.K[4] = focal_length[jj], camera.K[5] = 0,
					camera.K[6] = 0, camera.K[7] = 0, camera.K[8] = 1;

				camera.R[0] = soln_rotation[jj].coeff(0, 0), camera.R[1] = soln_rotation[jj].coeff(0, 1), camera.R[2] = soln_rotation[jj].coeff(0, 2),
					camera.R[3] = soln_rotation[jj].coeff(1, 0), camera.R[4] = soln_rotation[jj].coeff(1, 1), camera.R[5] = soln_rotation[jj].coeff(1, 2),
					camera.R[6] = soln_rotation[jj].coeff(2, 0), camera.R[7] = soln_rotation[jj].coeff(2, 1), camera.R[8] = soln_rotation[jj].coeff(2, 2);
				camera.T[0] = soln_translation[jj].coeff(0), camera.T[1] = soln_translation[jj].coeff(1), camera.T[2] = soln_translation[jj].coeff(2);
			}

			AssembleP(camera.K, camera.R, camera.T, camera.P);

			bool good = true;
			double errx, erry;
			for (int n = 0; n < minNpts; n++)
			{
				ProjectandDistort(Vxyz[ids[n]], &_p2d, camera.P);
				if (method != PnP::P4Pf)
					errx = _p2d.x - Vuv[ids[n]].x, erry = _p2d.y - Vuv[ids[n]].y;
				else
					errx = _p2d.x - Vuv[ids[n]].x + width / 2, erry = _p2d.y - Vuv[ids[n]].y + height / 2; //p4pf is build for K = diag(f,f, 1);
				if (errx*errx + erry * erry > thresh2)
				{
					good = false;
					break;
				}
			}
			if (!good)
				continue;

			Inliers.clear();
			for (int kk = 0; kk < npts; kk++)
			{
				ProjectandDistort(Vxyz[kk], &_p2d, camera.P);
				if (method != PnP::P4Pf)
					errx = _p2d.x - Vuv[kk].x, erry = _p2d.y - Vuv[kk].y;
				else
					errx = _p2d.x - Vuv[kk].x + width / 2, erry = _p2d.y - Vuv[kk].y + height / 2; //p4pf is build for K = diag(f,f, 1);
				if (errx*errx + erry * erry < thresh2)
					Inliers.push_back(kk);
			}

			if (nBestInliers < (int)Inliers.size()) 	//Local optimize
			{
				if (method == PnP::P4Pf)
				{
					if (distortionCorrectedMode == 1)
					{
						printLOG("Error. Using P4Pf with undistorted images (which requires known intrinsics)!");
						exit(1);
					}
					camera.K[2] = width / 2, camera.K[5] = height / 2; //NOTE: p4pf is build for K = diag(f,f, 1)
				}

				GetIntrinsicFromK(camera);
				GetrtFromRT(camera);

				//let optimize focal length using init rt from ransac based on corrected points	
				int orgShutterModel = camera.ShutterModel;
				camera.ShutterModel = GLOBAL_SHUTTER;
				if (distortionCorrectedMode == 0) //Need use the raw 2D points so that the new f makes sense.Just need to fix the distortion
					CameraPose1FrameBA(NULL, camera, Vxyz, Vuv_raw, Vscale, GlobalAnchor, Good, fixIntrinsic, 1, distortionCorrectedMode, useGlobalAnchor, 0, verbose);
				else
					CameraPose1FrameBA(NULL, camera, Vxyz, Vuv, Vscale, GlobalAnchor, Good, 1, 1, distortionCorrectedMode, useGlobalAnchor, 0, verbose); //distortion/image has been corrected
				camera.ShutterModel = orgShutterModel;

				GetRTFromrt(camera);
				AssembleP(camera.K, camera.R, camera.rt + 3, camera.P);

				//now, get back the corrected points under this new f
				if (distortionCorrectedMode == 0)
				{
					Vuv_corrected = Vuv_raw;
					if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
						LensCorrectionPoint(Vuv_corrected, camera.K, camera.distortion);
					else
						FishEyeCorrectionPoint(Vuv_corrected, camera.K, camera.distortion[0]);
				}

				Inliers.clear(), ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
				for (int kk = 0; kk < npts; kk++)
				{
					ProjectandDistort(Vxyz[kk], &_p2d, camera.P);
					if (distortionCorrectedMode == 0) //compare with newly corrected points
						errx = _p2d.x - Vuv_corrected[kk].x, erry = _p2d.y - Vuv_corrected[kk].y;
					else
						errx = _p2d.x - Vuv[kk].x, erry = _p2d.y - Vuv[kk].y;

					if (errx*errx + erry * erry < thresh2)
					{
						Inliers.push_back(kk);
						ReProjectionErrorX.push_back(abs(errx)), ReProjectionErrorY.push_back(abs(erry));
					}
				}

				for (int kk = 0; kk < 5; kk++)
					_intrinisc[kk] = camera.intrinsic[kk];
				for (int kk = 0; kk < 6; kk++)
					_rt[kk] = camera.rt[kk];
				for (int kk = 0; kk < 5; kk++)
					camera.intrinsic[kk] = org_intrinsic[kk]; //let undo the update for other iterations

				nBestInliers = (int)Inliers.size();
				BestInliers = Inliers;
			}
		}
		if (nBestInliers > 0.97*npts && iter > MaxIter / 40)
			break;
		else if (nBestInliers > 0.95*npts && iter > MaxIter / 30)
			break;
		else if (nBestInliers > 0.9*npts && iter > MaxIter / 20)
			break;
		else if (nBestInliers > 0.85*npts && iter > MaxIter / 10)
			break;
		else if (nBestInliers > 0.8*npts && iter > MaxIter / 5)
			break;
	}

	if (ReProjectionErrorX.size() > 0 && ReProjectionErrorY.size() > 0)
	{
		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX);
		double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY);
		double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printLOG("PnP stats --- Inliers: (%d/%d) Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", nBestInliers, npts, miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	for (int kk = 0; kk < 5; kk++)
		camera.intrinsic[kk] = _intrinisc[kk];
	for (int kk = 0; kk < 6; kk++)
		camera.rt[kk] = _rt[kk];
	GetKFromIntrinsic(camera);

	if (nBestInliers > nInlierThresh  &&distortionCorrectedMode == 0)
		Vuv = Vuv_raw;  //let return the raw points for further BA

	return nBestInliers > nInlierThresh ? 1 : 0;
}

int ComputeTrifocalTensorDLT(vector<Point2d> pts1, vector<Point2d> pts2, vector<Point2d> pts3, double *T)
{
	if (pts1.size() != pts2.size() || pts1.size() != pts3.size() || pts2.size() != pts3.size())
		return 1;

	int npts = (int)pts1.size();
	if (npts < 7)
		return 2;

	//Normalize points
	double h1[9], h2[9], h3[9];
	NormalizePointsForDLT(pts1, h1);
	NormalizePointsForDLT(pts2, h2);
	NormalizePointsForDLT(pts3, h3);

	//Solve DLT system
	MatrixXd A;
	A.setZero(4 * npts, 27);
	for (int ii = 0; ii < npts; ii++)
	{
		int i4 = 4 * ii;
		double u0 = pts1[ii].x, v0 = pts1[ii].y, u1 = pts2[ii].x, v1 = pts2[ii].y, u2 = pts3[ii].x, v2 = pts3[ii].y;

		A(i4, 0) = u0;
		A(i4, 1) = 0;
		A(i4, 2) = -u0 * u2;
		A(i4, 3) = 0;
		A(i4, 4) = 0;
		A(i4, 5) = 0;
		A(i4, 6) = -u0 * u1;
		A(i4, 7) = 0;
		A(i4, 8) = u0 * u1 * u2;
		A(i4, 9) = v0;
		A(i4, 10) = 0;
		A(i4, 11) = -u2 * v0;
		A(i4, 12) = 0;
		A(i4, 13) = 0;
		A(i4, 14) = 0;
		A(i4, 15) = -u1 * v0;
		A(i4, 16) = 0;
		A(i4, 17) = u1 * u2 * v0;
		A(i4, 18) = 1;
		A(i4, 19) = 0;
		A(i4, 20) = -u2;
		A(i4, 21) = 0;
		A(i4, 22) = 0;
		A(i4, 23) = 0;
		A(i4, 24) = -u1;
		A(i4, 25) = 0;
		A(i4, 26) = u1 * u2;
		A(i4 + 1, 0) = 0;
		A(i4 + 1, 1) = u0;
		A(i4 + 1, 2) = -u0 * v2;
		A(i4 + 1, 3) = 0;
		A(i4 + 1, 4) = 0;
		A(i4 + 1, 5) = 0;
		A(i4 + 1, 6) = 0;
		A(i4 + 1, 7) = -u0 * u1;
		A(i4 + 1, 8) = u0 * u1 * v2;
		A(i4 + 1, 9) = 0;
		A(i4 + 1, 10) = v0;
		A(i4 + 1, 11) = -v0 * v2;
		A(i4 + 1, 12) = 0;
		A(i4 + 1, 13) = 0;
		A(i4 + 1, 14) = 0;
		A(i4 + 1, 15) = 0;
		A(i4 + 1, 16) = -u1 * v0;
		A(i4 + 1, 17) = u1 * v0 * v2;
		A(i4 + 1, 18) = 0;
		A(i4 + 1, 19) = 1;
		A(i4 + 1, 20) = -v2;
		A(i4 + 1, 21) = 0;
		A(i4 + 1, 22) = 0;
		A(i4 + 1, 23) = 0;
		A(i4 + 1, 24) = 0;
		A(i4 + 1, 25) = -u1;
		A(i4 + 1, 26) = u1 * v2;
		A(i4 + 2, 0) = 0;
		A(i4 + 2, 1) = 0;
		A(i4 + 2, 2) = 0;
		A(i4 + 2, 3) = u0;
		A(i4 + 2, 4) = 0;
		A(i4 + 2, 5) = -u0 * u2;
		A(i4 + 2, 6) = -u0 * v1;
		A(i4 + 2, 7) = 0;
		A(i4 + 2, 8) = u0 * u2 * v1;
		A(i4 + 2, 9) = 0;
		A(i4 + 2, 10) = 0;
		A(i4 + 2, 11) = 0;
		A(i4 + 2, 12) = v0;
		A(i4 + 2, 13) = 0;
		A(i4 + 2, 14) = -u2 * v0;
		A(i4 + 2, 15) = -v0 * v1;
		A(i4 + 2, 16) = 0;
		A(i4 + 2, 17) = u2 * v0 * v1;
		A(i4 + 2, 18) = 0;
		A(i4 + 2, 19) = 0;
		A(i4 + 2, 20) = 0;
		A(i4 + 2, 21) = 1;
		A(i4 + 2, 22) = 0;
		A(i4 + 2, 23) = -u2;
		A(i4 + 2, 24) = -v1;
		A(i4 + 2, 25) = 0;
		A(i4 + 2, 26) = u2 * v1;
		A(i4 + 3, 0) = 0;
		A(i4 + 3, 1) = 0;
		A(i4 + 3, 2) = 0;
		A(i4 + 3, 3) = 0;
		A(i4 + 3, 4) = u0;
		A(i4 + 3, 5) = -u0 * v2;
		A(i4 + 3, 6) = 0;
		A(i4 + 3, 7) = -u0 * v1;
		A(i4 + 3, 8) = u0 * v1 * v2;
		A(i4 + 3, 9) = 0;
		A(i4 + 3, 10) = 0;
		A(i4 + 3, 11) = 0;
		A(i4 + 3, 12) = 0;
		A(i4 + 3, 13) = v0;
		A(i4 + 3, 14) = -v2 * v0;
		A(i4 + 3, 15) = 0;
		A(i4 + 3, 16) = -v0 * v1;
		A(i4 + 3, 17) = v0 * v1 * v2;
		A(i4 + 3, 18) = 0;
		A(i4 + 3, 19) = 0;
		A(i4 + 3, 20) = 0;
		A(i4 + 3, 21) = 0;
		A(i4 + 3, 22) = 1;
		A(i4 + 3, 23) = -v2;
		A(i4 + 3, 24) = 0;
		A(i4 + 3, 25) = -v1;
		A(i4 + 3, 26) = v1 * v2;
	}

	JacobiSVD<MatrixXd> svd(A, ComputeThinV);
	MatrixXd V = svd.matrixV();

	VectorXd tensorVector;
	tensorVector.Zero(27);
	tensorVector = V.col(26);

	//De-normalization
	Matrix3d T0, T1, T2, To0, To1, To2, *Ttemp, *Ttempo;
	int i, j, k, idx;
	idx = 0;
	for (i = 0; i < 3; i++)
	{
		switch (i)
		{
		case 0:
			Ttemp = &T0;
			break;
		case 1:
			Ttemp = &T1;
			break;
		case 2:
			Ttemp = &T2;
			break;
		}
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				(*Ttemp)(j, k) = tensorVector(idx);
				idx++;
			}
		}
	}

	Matrix3d H1; H1 << h1[0], 0, h1[2], 0, h1[4], h1[5], 0, 0, 1;
	Matrix3d iH2; iH2 << 1.0 / h2[0], 0, -h2[2] / h2[0], 0, 1.0 / h2[4], -h2[5] / h2[0], 0, 0, 1;
	Matrix3d iH3; iH3 << 1.0 / h3[0], 0, -h3[2] / h3[0], 0, 1.0 / h3[4], -h3[5] / h3[0], 0, 0, 1;

	int r, s, t;
	for (i = 0; i < 3; i++)
	{
		switch (i)
		{
		case 0:
			Ttempo = &To0;
			break;
		case 1:
			Ttempo = &To1;
			break;
		case 2:
			Ttempo = &To2;
			break;
		}

		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				(*Ttempo)(j, k) = 0;
				for (r = 0; r < 3; r++)
				{
					switch (r)
					{
					case 0:
						Ttemp = &T0;
						break;
					case 1:
						Ttemp = &T1;
						break;
					case 2:
						Ttemp = &T2;
						break;
					}
					for (s = 0; s < 3; s++)
					{
						for (t = 0; t < 3; t++)
						{
							(*Ttempo)(j, k) += H1(r, i)*iH2(j, s)*iH3(k, t)*((*Ttemp)(s, t));
						}
					}
				}
			}
		}
	}

	idx = 0;
	for (i = 0; i < 3; i++)
	{
		switch (i)
		{
		case 0:
			Ttemp = &To0;
			break;
		case 1:
			Ttemp = &To1;
			break;
		case 2:
			Ttemp = &To2;
			break;
		}
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				T[idx] = (*Ttemp)(j, k);
				idx++;
			}
		}
	}

	//matrix normalization
	double L2 = L2norm(T, 27);
	for (int i = 0; i < 27; i++)
		T[i] /= L2;

	return 0;
}
void TrifocalTensorPointTransfer(double *T, Point2d &pt1, Point2d &pt2, Point2d &pt3)
{
	MatrixXd A(2, 1), B(2, 1);
	double T111 = T[0], T121 = T[1], T131 = T[2], T211 = T[3], T221 = T[4], T231 = T[5], T311 = T[6], T321 = T[7], T331 = T[8];
	double T112 = T[9], T122 = T[10], T132 = T[11], T212 = T[12], T222 = T[13], T232 = T[14], T312 = T[15], T322 = T[16], T332 = T[17];
	double T113 = T[18], T123 = T[19], T133 = T[20], T213 = T[21], T223 = T[22], T233 = T[23], T313 = T[24], T323 = T[25], T333 = T[26];

	A(0, 0) = pt1.x*(pt2.x*T331 - T131) +
		pt1.y*(pt2.x*T332 - T132) +
		(pt2.x*T333 - T133);
	B(0, 0) = pt1.x*(pt2.x*T311 - T111) +
		pt1.y*(pt2.x*T312 - T112) +
		(pt2.x*T313 - T113);
	A(1, 0) = pt1.x*(pt2.y*T331 - T231) +
		pt1.y*(pt2.y*T332 - T232) +
		(pt2.y*T333 - T233);
	B(1, 0) = pt1.x*(pt2.y*T311 - T211) +
		pt1.y*(pt2.y*T312 - T212) +
		(pt2.y*T313 - T213);

	VectorXd x3_1 = A.colPivHouseholderQr().solve(B);

	A(0, 0) = pt1.x*(pt2.x*T331 - T131) +
		pt1.y*(pt2.x*T332 - T132) +
		(pt2.x*T333 - T133);
	B(0, 0) = pt1.x*(pt2.x*T321 - T121) +
		pt1.y*(pt2.x*T322 - T122) +
		(pt2.x*T323 - T123);

	A(1, 0) = pt1.x*(pt2.y*T331 - T231) +
		pt1.y*(pt2.y*T332 - T232) +
		(pt2.y*T333 - T233);
	B(1, 0) = pt1.x*(pt2.y*T321 - T221) +
		pt1.y*(pt2.y*T322 - T222) +
		(pt2.y*T323 - T223);
	VectorXd x3_2 = A.colPivHouseholderQr().solve(B);

	pt3.x = x3_1(0), pt3.y = x3_2(0);

	return;
}
int EvaluteTfocal(vector<Point2d> &pts1, vector<Point2d> &pts2, vector<Point2d> &pts3, double *T, vector<int>  &vinliers, double &meanErr, double thresh)
{
	int ninliers = 0;
	double error, thresh2 = thresh * thresh;  Point2d pt3;

	meanErr = 0.0;
	for (int ii = 0; ii < (int)pts1.size(); ii++)
	{
		if (pts1[ii].x == 0 || pts2[ii].x == 0 || pts3[ii].x == 0)
			continue;

		TrifocalTensorPointTransfer(T, pts1[ii], pts2[ii], pt3);
		error = pow(pts3[ii].x - pt3.x, 2) + pow(pts3[ii].y - pt3.y, 2);
		if (error > thresh2)
			vinliers.push_back(0);
		else
		{
			vinliers.push_back(1);

			meanErr += sqrt(error);
			ninliers++;
		}
	}
	meanErr /= (1e-9 + ninliers);

	return ninliers;
}
void GetEpipoleFromTrifocalTensor(double *T, double *e2, double *e3)
{
	Matrix3d T1, T2, T3, *Ttemp, U, V;
	int i, j, k, idx;
	idx = 0;
	for (i = 0; i < 3; i++)
	{
		switch (i)
		{
		case 0:
			Ttemp = &T1;
			break;
		case 1:
			Ttemp = &T2;
			break;
		case 2:
			Ttemp = &T3;
			break;
		}
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				(*Ttemp)(j, k) = T[idx];
				idx++;
			}
		}
	}

	Vector3d u1, u2, u3, v1, v2, v3;

	{
		JacobiSVD<Matrix3d> svd1(T1, ComputeThinU | ComputeThinV);
		U = svd1.matrixU(), V = svd1.matrixV();
		u1 = U.col(2), v1 = V.col(2);
	}

	{
		JacobiSVD<Matrix3d> svd(T2, ComputeThinU | ComputeThinV);
		U = svd.matrixU(), V = svd.matrixV();
		u2 = U.col(2), v2 = V.col(2);
	}

	{
		JacobiSVD<Matrix3d> svd(T3, ComputeThinU | ComputeThinV);
		U = svd.matrixU(), V = svd.matrixV();
		u3 = U.col(2), v3 = V.col(2);
	}

	Matrix3d uu, vv;
	uu.col(0) = u1, uu.col(1) = u2, uu.col(2) = u3;
	vv.col(0) = v1, vv.col(1) = v2, vv.col(2) = v3;

	{
		JacobiSVD<Matrix3d> svd(uu.transpose(), ComputeThinV);
		V = svd.matrixV();
		e2[0] = V(0, 2) / V(2, 2), e2[1] = V(1, 2) / V(2, 2); e2[2] = 1.0;
	}

	{
		JacobiSVD<Matrix3d> svd(vv.transpose(), ComputeThinV);
		V = svd.matrixV();
		e3[0] = V(0, 2) / V(2, 2), e3[1] = V(1, 2) / V(2, 2); e3[2] = 1.0;
	}


	return;
}
void GetProjFromTrifocalTensor(double *T, MatrixXd &P1, MatrixXd &P2)
{
	Matrix3d T1, T2, T3, *Ttemp, U, V;
	int i, j, k, idx;
	idx = 0;
	for (i = 0; i < 3; i++)
	{
		switch (i)
		{
		case 0:
			Ttemp = &T1;
			break;
		case 1:
			Ttemp = &T2;
			break;
		case 2:
			Ttemp = &T3;
			break;
		}
		for (j = 0; j < 3; j++)
		{
			for (k = 0; k < 3; k++)
			{
				(*Ttemp)(j, k) = T[idx];
				idx++;
			}
		}
	}

	double e2[3], e3[3];
	GetEpipoleFromTrifocalTensor(T, e2, e3);
	Vector3d e21; e21 << e2[0], e2[1], e2[2];
	Vector3d e31; e31 << e3[0], e3[1], e3[2];

	P1.col(0) = T1 * e31, P1.col(1) = T2 * e31, P1.col(2) = T3 * e31, P1.col(3) = e21;

	Matrix3d Temp = e31 * e31.transpose() - Matrix3d::Identity();
	P2.col(0) = Temp * T1.transpose()*e21;
	P2.col(1) = Temp * T2.transpose()*e21;
	P2.col(2) = Temp * T3.transpose()*e21;
	P2.col(3) = e31;


	return;
}
void GetTensorFromProj(MatrixXd& P1, MatrixXd& P2, double* T)
{
	//P0 = [ I | 0]
	for (int i = 0; i < 27; i++)
		T[i] = 0;

	int idx = 0;
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 3; k++)
			{
				T[idx] = P1(j, i)*P2(k, 3) - P1(j, 3)*P2(k, i);
				idx++;
			}
		}
	}
	//matrix normalization
	double L2 = L2norm(T, 27);
	for (int i = 0; i < 27; i++)
		T[i] /= L2;

	return;
}

int DoubleLinearReprojection(double *K, double *w, double *v, double *T, double *t, Point3d &p3d, Point2d &predicted)
{
	//Form R can T matrix
	double c = (predicted.y - K[5]) / K[4];
	double r = (predicted.x - K[2] - K[1] * c) / K[0];
	double nr, nc;
	for (int iter = 0; iter < 40; iter++)
	{
		double rw[3] = { r*w[0], r*w[1], r*w[2] };
		double Rw[] = { 1.0, -rw[2], rw[1], rw[2], 1.0, -rw[0], -rw[1], rw[0], 1.0 }; //eye + X_(rw)
		double Rv[] = { 1.0, -v[2], v[1], v[2], 1.0, -v[0], -v[1], v[0], 1.0 };

		double Rres[9];	mat_mul(Rw, Rv, Rres, 3, 3, 3);
		double Tres[3] = { T[0] + r * t[0], T[1] + r * t[1], T[2] + r * t[2] };

		double RT[12] = { Rres[0], Rres[1], Rres[2], Tres[0],
			Rres[3], Rres[4], Rres[5], Tres[1],
			Rres[6], Rres[7], Rres[8], Tres[2] };
		double P[12]; mat_mul(K, RT, P, 3, 3, 4);

		//compute reprojection error
		double numx = Rres[0] * p3d.x + Rres[1] * p3d.y + Rres[2] * p3d.z + Tres[0];
		double numy = Rres[3] * p3d.x + Rres[4] * p3d.y + Rres[5] * p3d.z + Tres[1];
		double denum = Rres[6] * p3d.x + Rres[7] * p3d.y + Rres[8] * p3d.z + Tres[2];

		nr = numx / denum;
		if (abs((nr - r) / r) < 1e-6)
		{
			nc = numy / denum;
			predicted.x = K[0] * nr + K[1] * nc + K[2];
			predicted.y = nc * K[4] + K[5];

			break;
		}
		else
			r = nr;
	}

	return 0;
}
struct DoubleLinearReprojectionError {
	DoubleLinearReprojectionError(double *Kin, Point2d uv, Point3d xyz) : uv(uv), xyz(xyz)
	{
		K = Kin;
	}

	template <typename T>	bool operator()(const double* const w, const double* const v, const double* const C, const double* const t, T* residuals) const
	{
		Point2d predicted = uv;
		Point3d p3d = xyz;
		double w_[] = { w[0], w[1], w[2] };
		double v_[] = { v[0], v[1], v[2] };
		double C_[] = { C[0], C[1], C[2] };
		double t_[] = { t[0], t[1], t[2] };

		DoubleLinearReprojection(K, w_, v_, C_, t_, p3d, predicted);

		residuals[0] = predicted.x - uv.x, residuals[1] = predicted.y - uv.y;

		return true;
	}

	static ceres::CostFunction* Create(double *K, Point2d xycn, Point3d xyz)
	{
		return (new ceres::NumericDiffCostFunction<DoubleLinearReprojectionError, ceres::CENTRAL, 2, 3, 3, 3, 3>(new DoubleLinearReprojectionError(K, xycn, xyz)));
	}

	double *K;
	Point2d uv; Point3d xyz;
};
void DoubleLinearRP6PRefinement(double *K, double *w, double *v, double *T, double *t, Point2d *p2d, Point3d *p3d, int npts)
{
	ceres::Problem problem;

	//double err = 0.0;
	//Point2d predicted;
	for (int ii = 0; ii < npts; ii++)
	{
		//predicted = p2d[ii];
		//DoubleLinearReprojection(K, w, v, T, t, p3d[ii], predicted);
		//Point2d e2 = p2d[ii] - predicted;
		//err += e2.x*e2.x + e2.y*e2.y;
		ceres::CostFunction* cost_function = DoubleLinearReprojectionError::Create(K, p2d[ii], p3d[ii]);
		problem.AddResidualBlock(cost_function, NULL, w, v, T, t);
	}
	//err /= npts;

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 50;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.BriefReport() << "\n";

	//err = 0.0;
	for (int ii = 0; ii < npts; ii++)
	{
		//predicted = p2d[ii];
		//DoubleLinearReprojection(K, w, v, T, t, p3d[ii], predicted);
		//Point2d e2 = p2d[ii] - predicted;
		//err += e2.x*e2.x + e2.y*e2.y;
		ceres::CostFunction* cost_function = DoubleLinearReprojectionError::Create(K, p2d[ii], p3d[ii]);
		problem.AddResidualBlock(cost_function, NULL, w, v, T, t);
	}
	//err /= npts;

	return;
}
int RP6P_RANSAC(double *R, double *T, vector<int> &BestInliers, double *K, double *distortion, int LensModel, Point2d *P2d, Point3d *P3d, int npts, int distortionCorrected, int MaxIter, int nInlierThresh, double thresh)
{
	vector<int>ids(npts);
	for (int ii = 0; ii < npts; ii++)
		ids[ii] = ii;

	//compute normalized image coord
	Point2d *nP2d = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		if (distortionCorrected == 0)
		{
			Point2d uv = P2d[ii];
			LensCorrectionPoint(&uv, K, distortion);
			double v = (uv.y - K[5]) / K[4], u = (uv.x - K[2] - K[1] * v) / K[0];
			nP2d[ii].x = u; nP2d[ii].y = v;
		}
		else
		{
			double v = (P2d[ii].y - K[5]) / K[4], u = (P2d[ii].x - K[2] - K[1] * v) / K[0];
			nP2d[ii].x = u; nP2d[ii].y = v;
		}
	}

	Point2d *tp2d = new Point2d[npts];
	Point3d *tp3d = new Point3d[npts];
	double thresh2 = thresh * thresh;
	int nBestInliers = 0;
	vector<int> Inliers;
	double Rres[9], Tres[3], resT[60], rest[60], resw[60], resv[60];

	int iter = 0;
	while (iter < MaxIter)
	{
		iter++;
		std::random_shuffle(ids.begin(), ids.end());

		double X[18], x[12];
		for (int ii = 0; ii < 6; ii++)
			x[2 * ii] = nP2d[ids[ii]].x, x[2 * ii + 1] = nP2d[ids[ii]].y;
		for (int ii = 0; ii < 6; ii++)
			X[3 * ii] = P3d[ids[ii]].x, X[3 * ii + 1] = P3d[ids[ii]].y, X[3 * ii + 2] = P3d[ids[ii]].z;

		//Check for same 2D points: sounds stupid but needed due to matching problem
		bool duplicated = false;
		for (int ii = 0; ii < 5 && !duplicated; ii++)
			if (x[2 * ii] == x[2 * (ii + 1)])
				duplicated = true;
		if (duplicated)
			continue;

		int nresults = r6p(X, x, (double)0, resT, rest, resv, resw);
		for (int jj = 0; jj < nresults; jj++)
		{
			//eliminate solutions with unreasonably high camera movement
			if (pow(resw[jj * 3], 2) + pow(resw[jj * 3 + 1], 2) + pow(resw[jj * 3 + 2], 2) > 1)
				continue;

			Inliers.clear();
			for (int kk = 0; kk < npts; kk++)
			{
				//Form R can T matrix
				double r = nP2d[kk].x; //R6P is built for a HORIZONTAL rolling shutter direction % i.e.lines are read from left to right(along x axis)
				double rw[3] = { r*resw[jj * 3], r*resw[jj * 3 + 1], r*resw[jj * 3 + 2] };
				double Rw[] = { 1.0, -rw[2], rw[1], rw[2], 1.0, -rw[0], -rw[1], rw[0], 1.0 }; //eye + X_(rw)
				double Rv[] = { 1.0, -resv[3 * jj + 2], resv[3 * jj + 1], resv[3 * jj + 2], 1.0, -resv[3 * jj + 0], -resv[3 * jj + 1], resv[3 * jj + 0], 1.0 };

				mat_mul(Rw, Rv, Rres, 3, 3, 3);
				Tres[0] = resT[3 * jj] + r * rest[3 * jj], Tres[1] = resT[3 * jj + 1] + r * rest[3 * jj + 1], Tres[2] = resT[3 * jj + 2] + r * rest[3 * jj + 2];

				//compute reprojection error
				double numx = Rres[0] * P3d[kk].x + Rres[1] * P3d[kk].y + Rres[2] * P3d[kk].z + Tres[0];
				double numy = Rres[3] * P3d[kk].x + Rres[4] * P3d[kk].y + Rres[5] * P3d[kk].z + Tres[1];
				double denum = Rres[6] * P3d[kk].x + Rres[7] * P3d[kk].y + Rres[8] * P3d[kk].z + Tres[2];
				double errx = numx / denum - nP2d[kk].x, erry = numy / denum - nP2d[kk].y;
				if (errx*errx + erry * erry < thresh2)
					Inliers.push_back(kk);
			}

			if (nBestInliers < (int)Inliers.size())
			{
				//Local optimize
				for (int kk = 0; kk < (int)Inliers.size(); kk++)
					tp2d[kk] = P2d[Inliers[kk]], tp3d[kk] = P3d[Inliers[kk]];

				DoubleLinearRP6PRefinement(K, resw + 3 * jj, resv + 3 * jj, resT + 3 * jj, rest + 3 * jj, tp2d, tp3d, (int)Inliers.size());
				//printLOG("Local optim: %d->", (int)Inliers.size());
				Inliers.clear();
				for (int kk = 0; kk < npts; kk++)
				{
					//Form R can T matrix
					double r = nP2d[kk].x; //R6P is built for a HORIZONTAL rolling shutter direction % i.e.lines are read from left to right(along x axis)
					double rw[3] = { r*resw[jj * 3], r*resw[jj * 3 + 1], r*resw[jj * 3 + 2] };
					double Rw[] = { 1.0, -rw[2], rw[1], rw[2], 1.0, -rw[0], -rw[1], rw[0], 1.0 }; //eye + X_(rw)
					double Rv[] = { 1.0, -resv[3 * jj + 2], resv[3 * jj + 1], resv[3 * jj + 2], 1.0, -resv[3 * jj + 0], -resv[3 * jj + 1], resv[3 * jj + 0], 1.0 };

					mat_mul(Rw, Rv, Rres, 3, 3, 3);
					Tres[0] = resT[3 * jj] + r * rest[3 * jj], Tres[1] = resT[3 * jj + 1] + r * rest[3 * jj + 1], Tres[2] = resT[3 * jj + 2] + r * rest[3 * jj + 2];

					//compute reprojection error
					double numx = Rres[0] * P3d[kk].x + Rres[1] * P3d[kk].y + Rres[2] * P3d[kk].z + Tres[0];
					double numy = Rres[3] * P3d[kk].x + Rres[4] * P3d[kk].y + Rres[5] * P3d[kk].z + Tres[1];
					double denum = Rres[6] * P3d[kk].x + Rres[7] * P3d[kk].y + Rres[8] * P3d[kk].z + Tres[2];
					double errx = numx / denum - nP2d[kk].x, erry = numy / denum - nP2d[kk].y;
					if (errx*errx + erry * erry < thresh2)
						Inliers.push_back(kk);
				}
				//printLOG("%d\n", (int)Inliers.size());

				nBestInliers = (int)Inliers.size();
				BestInliers = Inliers;
			}
		}
		if (nBestInliers > 0.8*npts)
			break;
	}

	delete[]nP2d;
	return nBestInliers;
}
//the 2D points will be distorted to its raw detection
int EstimatePoseAndInliers(double *K, double *distortion, int LensModel, int ShutterModel, double *R, double *T, double *wt, vector<Point2d> &pts, vector<Point3d> &ThreeD, vector<int>  &Inliers, double thresh, int fixIntrinsic, int distortionCorrected, double minFRatio, double maxFRatio, int width, int height, int PnPAlgo)
{
	int npts = (int)pts.size();
	double ProThresh = 0.995, PercentInlier = 0.2;

	CameraData cameraParas;
	cameraParas.threshold = thresh;
	cameraParas.ShutterModel = ShutterModel;
	cameraParas.LensModel = LensModel;
	cameraParas.width = width, cameraParas.height = height;
	cameraParas.nInlierThresh = pts.size()*PercentInlier;
	cameraParas.intrinsic[0] = K[0], cameraParas.intrinsic[1] = K[4], cameraParas.intrinsic[2] = K[1], cameraParas.intrinsic[3] = K[2], cameraParas.intrinsic[4] = K[5];
	for (int ii = 0; ii < 7; ii++)
		cameraParas.distortion[ii] = distortion[ii];
	GetKFromIntrinsic(cameraParas);

	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 3)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires); //P3P
	if (PnPAlgo == PnP::EPNP)
		iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires); 
	else if (PnPAlgo == PnP::DLS)
		iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 6)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires); 
	else if (PnPAlgo == PnP::P4Pf)
		iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires); 

	if (ShutterModel == ROLLING_SHUTTER)
	{
		if (PnP_RANSAC(cameraParas, Inliers, ThreeD, pts, cameraParas.width, cameraParas.height, cameraParas.LensModel, iterMax, cameraParas.nInlierThresh, 2.0*cameraParas.threshold, fixIntrinsic, distortionCorrected, PnPAlgo) == 0)
			return -1;
		if (cameraParas.intrinsic[0] / max(width, height) < minFRatio || cameraParas.intrinsic[0] / max(width, height) > maxFRatio)
			return -1;

		if (distortionCorrected == 0) //Let's try to undistort so that PnP is easy. 
		{
			if (LensModel == RADIAL_TANGENTIAL_PRISM)
				LensCorrectionPoint(pts, K, distortion);
			else
				FishEyeCorrectionPoint(pts, K, distortion[0]); //FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2], npts);
		}

		GetRTFromrt(cameraParas.rt, R, T);
		int norgInliers = Inliers.size();

		printLOG("Run R6P-RANSAC...");
		double startTime = omp_get_wtime();

		//Need to rotate the 3D points using the camera rotation matrix found by P3P. 
		//R6P is built for a HORIZONTAL rolling shutter direction % i.e.lines are read from left to right(along x axis). In order to use it for images where RS was in VERTICAL direction, simply transform the scene to interchange x and y axes
		vector<int> inliers;
		int npts = ThreeD.size();
		Point2d *P2d = new Point2d[npts];
		Point3d *P3d = new Point3d[npts];
		for (int ii = 0; ii < npts; ii++)
		{
			P2d[ii].x = pts[ii].y, P2d[ii].y = pts[ii].x;

			double x = ThreeD[ii].x * cameraParas.R[0] + ThreeD[ii].y * cameraParas.R[1] + ThreeD[ii].z * cameraParas.R[2];
			double y = ThreeD[ii].x * cameraParas.R[3] + ThreeD[ii].y * cameraParas.R[4] + ThreeD[ii].z * cameraParas.R[5];
			double z = ThreeD[ii].x * cameraParas.R[6] + ThreeD[ii].y * cameraParas.R[7] + ThreeD[ii].z * cameraParas.R[8];
			P3d[ii] = Point3d(y, x, z);
		}
		int iterMax2 = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 6)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
		RP6P_RANSAC(cameraParas.R, cameraParas.T, inliers, cameraParas.K, cameraParas.distortion, cameraParas.LensModel, P2d, P3d, ThreeD.size(), 1, iterMax2, ThreeD.size()*PercentInlier, 1.5*cameraParas.threshold / cameraParas.K[0]);
		delete[]P2d, delete[]P3d;

		//merge pnp and r6p inliers
		for (int ii = 0; ii < (int)inliers.size(); ii++)
			Inliers.push_back(inliers[ii]);
		sort(Inliers.begin(), Inliers.end());
		std::vector<int>::iterator it = unique(Inliers.begin(), Inliers.end());
		Inliers.resize(std::distance(Inliers.begin(), it));
		int ninliers = (int)Inliers.size();

		printLOG("found %d more inliers. Takes %.2fs\n\n", ninliers - norgInliers, omp_get_wtime() - startTime);
		if (ninliers < npts*PercentInlier)
			return 0;
		else
		{
			if (distortionCorrected == 0) //Let's get the org feat back for optimizing f
			{
				if (LensModel == RADIAL_TANGENTIAL_PRISM)
					LensDistortionPoint(pts, K, distortion);
				else
					FishEyeDistortionPoint(pts, K, distortion[0]); //FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2], npts);
			}

			int nBadCounts = 0;
			double residuals[2];
			vector<bool> badPoints; badPoints.reserve(Inliers.size());
			vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(Inliers.size());
			vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(Inliers.size());
			double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;

			ceres::Problem problem;
#pragma omp critical
			printLOG("Refine Cayley-PnP\n");

			startTime = omp_get_wtime();
			for (auto ii : Inliers)
			{
				if (distortionCorrected == 1)
					CayleyReprojectionDebug(cameraParas.intrinsic, cameraParas.rt, cameraParas.wt, pts[ii], ThreeD[ii], width, height, residuals);
				else
					CayleyDistortionReprojectionDebug(cameraParas.intrinsic, cameraParas.distortion, cameraParas.rt, cameraParas.wt, pts[ii], ThreeD[ii], width, height, residuals);
				if (abs(residuals[0]) > 2.0*thresh || abs(residuals[1]) > 2.0*thresh)
				{
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					badPoints.push_back(true);
					nBadCounts++;
				}
				else
				{
					if (distortionCorrected == 0)
					{
						ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(pts[ii].x, pts[ii].y, 1, width, height);
						problem.AddResidualBlock(cost_function, NULL, cameraParas.intrinsic, cameraParas.distortion, cameraParas.rt, cameraParas.wt, &ThreeD[ii].x);
						problem.SetParameterBlockConstant(cameraParas.distortion); //disortion is fixed
					}
					else
					{
						ceres::CostFunction* cost_function = CayleyReprojectionError::Create(cameraParas.intrinsic, pts[ii].x, pts[ii].y, 1, width, height);
						problem.AddResidualBlock(cost_function, NULL, cameraParas.rt, cameraParas.wt, &ThreeD[ii].x);
					}
					problem.SetParameterBlockConstant(&ThreeD[ii].x);

					ReProjectionErrorX.push_back(residuals[0]), ReProjectionErrorY.push_back(residuals[1]);
					badPoints.push_back(false);
				}
			}

			if (distortionCorrected == 0)
			{
				std::vector<int> constant_parameters;
				constant_parameters.push_back(2), constant_parameters.push_back(3), constant_parameters.push_back(4); //fix skew and principal points
				problem.SetParameterization(cameraParas.intrinsic, new ceres::SubsetParameterization(5, constant_parameters));
			}

#pragma omp critical
			printLOG("(%d/%d) bad points detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, Inliers.size(), maxOutlierX, maxOutlierY);

			if (ReProjectionErrorX.size() > 0 && ReProjectionErrorY.size() > 0)
			{
				double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
				double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
				double avgX = MeanArray(ReProjectionErrorX);
				double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
				double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
				double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
				double avgY = MeanArray(ReProjectionErrorY);
				double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
				printLOG("Before BA: Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
			}

			ceres::Solver::Options options;
			options.num_threads = omp_get_max_threads();
			options.num_linear_solver_threads = omp_get_max_threads();
			options.max_num_iterations = 50;
			options.linear_solver_type = ceres::SPARSE_SCHUR;
			options.minimizer_progress_to_stdout = false;
			options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
			options.use_nonmonotonic_steps = false;

			ceres::Solver::Summary summary;
			ceres::Solve(options, &problem, &summary);

			ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
			pointErrX = 0.0, pointErrY = 0.0;

			int cnt = 0;
			for (auto ii : Inliers)
			{
				if (abs(ThreeD[ii].x) + abs(ThreeD[ii].y) + abs(ThreeD[ii].z) > LIMIT3D && !badPoints[cnt])
				{
					if (distortionCorrected == 0)
						CayleyDistortionReprojectionDebug(cameraParas.intrinsic, cameraParas.distortion, cameraParas.rt, cameraParas.wt, pts[ii], ThreeD[ii], width, height, residuals);
					else
						CayleyReprojectionDebug(cameraParas.intrinsic, cameraParas.rt, cameraParas.wt, pts[ii], ThreeD[ii], width, height, residuals);
					ReProjectionErrorX.push_back(residuals[0]), ReProjectionErrorY.push_back(residuals[1]);
				}
				cnt++;
			}
			if (ReProjectionErrorX.size() > 0 && ReProjectionErrorY.size() > 0)
			{
				double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
				double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
				double avgX = MeanArray(ReProjectionErrorX);
				double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
				double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
				double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
				double avgY = MeanArray(ReProjectionErrorY);
				double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
				printLOG("After BA: Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
			}
			printLOG("Take %.2fs\n\n", omp_get_wtime() - startTime);

			if (cameraParas.intrinsic[0] / max(width, height) < minFRatio || cameraParas.intrinsic[0] / max(width, height) > maxFRatio)
			{
				printLOG("Range constrains violated\n");
				return -1;
			}

			K[0] = cameraParas.intrinsic[0], K[1] = cameraParas.intrinsic[2], K[2] = cameraParas.intrinsic[3];
			K[3] = 0.0, K[4] = cameraParas.intrinsic[1], K[5] = cameraParas.intrinsic[4];
			K[6] = 0, K[7] = 0, K[8] = 1;

			GetRTFromrt(cameraParas.rt, R, T);
			for (int ii = 0; ii < 6; ii++)
				wt[ii] = cameraParas.wt[ii];

			return Inliers.size();
		}
	}
	else
	{
		if (PnP_RANSAC(cameraParas, Inliers, ThreeD, pts, cameraParas.width, cameraParas.height, cameraParas.LensModel, iterMax, cameraParas.nInlierThresh, cameraParas.threshold, fixIntrinsic, distortionCorrected, PnPAlgo) == 0)
			return -1;
		if (cameraParas.intrinsic[0] / max(width, height) < minFRatio || cameraParas.intrinsic[0] / max(width, height) > maxFRatio)
		{
			printLOG("Range constrains violated\n");
			return -1;
		}

		K[0] = cameraParas.intrinsic[0], K[1] = cameraParas.intrinsic[2], K[2] = cameraParas.intrinsic[3];
		K[3] = 0.0, K[4] = cameraParas.intrinsic[1], K[5] = cameraParas.intrinsic[4];
		K[6] = 0, K[7] = 0, K[8] = 1;

		GetRTFromrt(cameraParas.rt, R, T);

		return (int)Inliers.size();
	}

	return 0;
}

void UndistortAndRectifyPoint(double *K, double *distortion, double *R, double *nK, Point2d &uv)
{
	//R, nK are openCV R matrices
	double A[] = { K[0], K[4], K[1], K[2], K[5] }, xcn, ycn;

	CC_Calculate_xcn_ycn_from_i_j(uv.x, uv.y, xcn, ycn, A, distortion, 0);

	double denum = R[6] * xcn + R[7] * ycn + R[8];
	double rxcn = (R[0] * xcn + R[1] * ycn + R[2]) / denum;
	double rycn = (R[3] * xcn + R[4] * ycn + R[5]) / denum;

	uv.x = rxcn * nK[0] + rycn * nK[1] + nK[2]; //nK: 3x4
	uv.y = rycn * nK[5] + nK[6];

	return;
}
void UndistortAndRectifyPoint(double *K, double *distortion, double *R, double *nK, Point2f &uv)
{
	//R, nK are openCV R matrices
	double A[] = { K[0], K[4], K[1], K[2], K[5] }, xcn, ycn;

	CC_Calculate_xcn_ycn_from_i_j((double)uv.x, (double)uv.y, xcn, ycn, A, distortion, 0);

	double denum = R[6] * xcn + R[7] * ycn + R[8];
	double rxcn = (R[0] * xcn + R[1] * ycn + R[2]) / denum;
	double rycn = (R[3] * xcn + R[4] * ycn + R[5]) / denum;

	uv.x = (float)(rxcn*nK[0] + rycn * nK[1] + nK[2]); //nK: 3x4
	uv.y = (float)(rycn*nK[5] + nK[6]);

	return;
}


// Return 3-point in the image plane.
Vector3d unproject(const Point2d& uv, const Eigen::VectorXd & params)
{
	static constexpr int kUnprojectNewtonIterations = 100;
	static constexpr double kUnprojectNewtonDeltaMin = 1E-10;

	// Unprojection
	double fu = params(0);
	double fv = params(1);
	double u0 = params(2);
	double v0 = params(3);

	double k0 = params(4);
	double k1 = params(5);
	double k2 = params(6);
	double k3 = params(7);

	double un = (uv.x - u0) / fu;
	double vn = (uv.y - v0) / fv;
	double rth2 = un * un + vn * vn;

	if (rth2 < 0.001) {
		return Vector3d(un, vn, (double)1);
	}

	double rth = sqrt(rth2);

	// Use Newtons method to solve for theta.
	double th = rth;
	double delta;
	size_t its = 0;
	do {
		// f = (th + k0*th**3 + k1*th**5 + k2*th**7 + k3*th**9 - rth)^2
		double th2 = th * th;
		double th3 = th2 * th;
		double th4 = th2 * th2;
		double th6 = th4 * th2;
		// residual
		double x0 = k0 * th3 + k1 * th4 * th + k2 * th6 * th + k3 * th6 * th3 - rth + th;
		// derivative of x0
		double x1 =
			(double)3 * k0 * th2 + (double)5 * k1 * th4 + (double)7 * k2 * th6 + (double)9 * k3 * th6 * th2 + (double)1;
		// derivative of f
		double d = (double)2 * x0 * x1;
		// 2nd derivative of f
		double d2 =
			(double)(-2) * th * x0 * ((double)3 * k0 + (double)10 * k1 * th2 + (double)21 * k2 * th4 + (double)36 * k3 * th6) +
			(double)2 * x1 * x1;
		// Newton update
		delta = d / d2;
		th -= delta;
		++its;
	} while (its < kUnprojectNewtonIterations &&
		std::abs(delta) > kUnprojectNewtonDeltaMin);

	return Vector3d(sin(th) * un / rth, sin(th) * vn / rth, cos(th));
}
void LensCorrectionPoint_KB3(Point2d &uv, double *intrinsic, double *distortion)
{
	Eigen::VectorXd params0(8); params0 << intrinsic[0], intrinsic[1], intrinsic[3], intrinsic[4], distortion[0], distortion[1], distortion[2], distortion[3];
	Vector3d ray = unproject(uv, params0);

	//convert from normalized coord to pixels
	ray = ray / ray(2);
	uv.x = ray(0) * intrinsic[0] + intrinsic[3];
	uv.y = ray(1) * intrinsic[1] + intrinsic[4];

	return;
}
void LensDistortionPoint_KB3(Point2d &img_point, double *intrinsic, double *distortion)
{
	using std::atan2;
	using std::sqrt;

	const double fx = intrinsic[0], fy = intrinsic[1], u0 = intrinsic[3], v0 = intrinsic[4],
		k0 = distortion[0], k1 = distortion[1], k2 = distortion[2], k3 = distortion[3];

	double pointOptical_x = (img_point.x - u0) / fx;
	double pointOptical_y = (img_point.y - v0) / fy;

	const double XsqPlusYsq = pointOptical_x * pointOptical_x + pointOptical_y * pointOptical_y;
	const double sqrtXsqYsq = sqrt(XsqPlusYsq);

	if (sqrtXsqYsq > 1.0e-16)
	{
		const double theta = atan2(sqrtXsqYsq, 1.0);
		const double theta2 = theta * theta;
		const double theta4 = theta2 * theta2;
		const double theta6 = theta4 * theta2;
		const double theta8 = theta4 * theta4;
		const double r = theta * (1.0 + k0 * theta2 + k1 * theta4 + k2 * theta6 + k3 * theta8) / sqrtXsqYsq;

		pointOptical_x = pointOptical_x * r, pointOptical_y = pointOptical_y * r;
		img_point.x = pointOptical_x * fx + u0, img_point.y = pointOptical_y * fy + v0;
	}
	else
		;//no distortion correction then
	return;
}

//The fisheye camera is parameterized using 12 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, 2 for distortion center, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(Point2f *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2f> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2d> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(vector<Point2d>&Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(vector<Point2f>&Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double omega, double DistCtrX, double DistCtrY, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int length = width * height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth * Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (int kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk * length, Para + kk * length, width, height, intepAlgo);
	}



	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int jj = 0; jj < Mheight; jj++)
	{
		for (int ii = 0; ii < Mwidth; ii++)
		{
			double S[3];
			Point2d ImgPt(H[0] * ii + H[1] * jj + H[2], H[3] * ii + H[4] * jj + H[5]);

			FishEyeDistortionPoint(&ImgPt, omega, DistCtrX, DistCtrY, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (int kk = 0; kk < nchannels; kk++)
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)0;
			}
			else
			{
				for (int kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk * length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The fisheye camera is parameterized using 10 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double *K, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;

		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeCorrectionPoint(Point2f *Points, double *K, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//	x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeCorrectionPoint(vector<Point2f> &Points, double *K, double omega)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	int npts = (int)Points.size();

	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeCorrectionPoint(vector<Point2d> &Points, double *K, double omega)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double *K, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeDistortionPoint(Point2f *Points, double *K, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = (float)(alpha*x_u + gamma * y_u + u0);
		Points[iPoint].y = (float)(beta*y_u + v0);
	}
}
void FishEyeDistortionPoint(vector<Point2d>&Points, double *K, double omega)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeDistortionPoint(vector<Point2f>&Points, double *K, double omega)
{
	double x, y, ru, rd, x_u, y_u, t;
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];
	int npts = (int)Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		//x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		y = (Points[iPoint].y - v0) / beta;
		x = (Points[iPoint].x - u0 - gamma * y) / alpha;
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		//Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
		Points[iPoint].x = alpha * x_u + gamma * y_u + u0;
		Points[iPoint].y = beta * y_u + v0;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double *K, double omega, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int length = width * height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth * Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (int kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk * length, Para + kk * length, width, height, intepAlgo);
	}

	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int jj = 0; jj < Mheight; jj++)
	{
		for (int ii = 0; ii < Mwidth; ii++)
		{
			double S[3];
			Point2d ImgPt(H[0] * ii + H[1] * jj + H[2], H[3] * ii + H[4] * jj + H[5]);

			FishEyeDistortionPoint(&ImgPt, K, omega, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (int kk = 0; kk < nchannels; kk++)
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)0;
			}
			else
			{
				for (int kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk * length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The fisheye camera is parameterized using 10 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x_n, y_n, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x_n = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y_n = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x_n*x_n + y_n * y_n), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t * x_n, y_u = t * y_n;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t * x, y_u = t * y;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double *K, double* invK, double omega, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width * height, Mwidth = width * ImgMag, Mheight = height * ImgMag, Mlength = Mwidth * Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk * length, Para + kk * length, width, height, intepAlgo);
	}


	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			FishEyeDistortionPoint(&ImgPt, K, invK, omega, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk * length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The camera is parameterized using 16 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 3 for radial distortion, 2 for tangential distortion, 2 for prism, and 6 for rotation translation.
void CC_Calculate_xcn_ycn_from_i_j(double i, double j, double &xcn, double &ycn, double *A, double *distortion, int Method)
{
	int k;
	double Xcn, Ycn, r2, r4, r6, x2, y2, xy, x0, y0;
	double radial, tangential_x, tangential_y, prism_x, prism_y;
	double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
	double p0 = distortion[3], p1 = distortion[4];
	double s0 = distortion[5], s1 = distortion[6];

	Ycn = (j - A[4]) / A[1];
	Xcn = (i - A[3] - A[2] * Ycn) / A[0];

	xcn = Xcn;
	ycn = Ycn;
	for (k = 0; k < 20; k++)
	{
		x0 = xcn;
		y0 = ycn;
		r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, x2 = xcn * xcn, y2 = ycn * ycn, xy = xcn * ycn;

		radial = 1.0 + a0 * r2 + a1 * r4 + a2 * r6;
		tangential_x = 2.0*p1*xy + p0 * (r2 + 2.0*x2);
		tangential_y = p1 * (r2 + 2.0*y2) + 2.0*p0*xy;

		prism_x = s0 * r2;
		prism_y = s1 * r2;

		xcn = (Xcn - tangential_x - prism_x) / radial;
		ycn = (Ycn - tangential_y - prism_y) / radial;

		if (abs((xcn - x0) / xcn) < 1.0e-9 && abs((ycn - y0) / ycn) < 1.0e-9)
			break;
	}
	return;
}

void LensDistortionPoint(Point2f *img_point, double *K, double *distortion, int npts)
{
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma * ycn) / alpha;

		double r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, X2 = xcn * xcn, Y2 = ycn * ycn, XY = xcn * ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0 * r2 + a1 * r4 + a2 * r6;
		double tangential_x = 2.0*p1*XY + p0 * (r2 + 2.0*X2);
		double tangential_y = p1 * (r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0 * r2;
		double prism_y = s1 * r2;

		double xcn_ = radial * xcn + tangential_x + prism_x;
		double ycn_ = radial * ycn + tangential_y + prism_y;

		img_point[ii].x = (float)(alpha*xcn_ + gamma * ycn_ + u0);
		img_point[ii].y = (float)(beta*ycn_ + v0);
	}

	return;
}
void LensDistortionPoint(Point2d *img_point, double *K, double *distortion, int npts)
{
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma * ycn) / alpha;

		double r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, X2 = xcn * xcn, Y2 = ycn * ycn, XY = xcn * ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0 * r2 + a1 * r4 + a2 * r6;
		double tangential_x = 2.0*p1*XY + p0 * (r2 + 2.0*X2);
		double tangential_y = p1 * (r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0 * r2;
		double prism_y = s1 * r2;

		double xcn_ = radial * xcn + tangential_x + prism_x;
		double ycn_ = radial * ycn + tangential_y + prism_y;

		img_point[ii].x = alpha * xcn_ + gamma * ycn_ + u0;
		img_point[ii].y = beta * ycn_ + v0;
	}

	return;
}
void LensDistortionPoint2(Point2d *img_point, double *Intrinsic, double *distortion, int npts)
{
	double alpha = Intrinsic[0], beta = Intrinsic[1], gamma = Intrinsic[2], u0 = Intrinsic[3], v0 = Intrinsic[4];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma * ycn) / alpha;

		double r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, X2 = xcn * xcn, Y2 = ycn * ycn, XY = xcn * ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0 * r2 + a1 * r4 + a2 * r6;
		double tangential_x = 2.0*p1*XY + p0 * (r2 + 2.0*X2);
		double tangential_y = p1 * (r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0 * r2;
		double prism_y = s1 * r2;

		double xcn_ = radial * xcn + tangential_x + prism_x;
		double ycn_ = radial * ycn + tangential_y + prism_y;

		img_point[ii].x = alpha * xcn_ + gamma * ycn_ + u0;
		img_point[ii].y = beta * ycn_ + v0;
	}

	return;
}
void LensDistortionPoint(vector<Point2d> &img_point, double *K, double *distortion)
{
	int npts = (int)img_point.size();
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma * ycn) / alpha;

		double r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, X2 = xcn * xcn, Y2 = ycn * ycn, XY = xcn * ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0 * r2 + a1 * r4 + a2 * r6;
		double tangential_x = 2.0*p1*XY + p0 * (r2 + 2.0*X2);
		double tangential_y = p1 * (r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0 * r2;
		double prism_y = s1 * r2;

		double xcn_ = radial * xcn + tangential_x + prism_x;
		double ycn_ = radial * ycn + tangential_y + prism_y;

		img_point[ii].x = alpha * xcn_ + gamma * ycn_ + u0;
		img_point[ii].y = beta * ycn_ + v0;
	}

	return;
}
void LensDistortionPoint(vector<Point2f> &img_point, double *K, double *distortion)
{
	int npts = (int)img_point.size();
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma * ycn) / alpha;

		double r2 = xcn * xcn + ycn * ycn, r4 = r2 * r2, r6 = r2 * r4, X2 = xcn * xcn, Y2 = ycn * ycn, XY = xcn * ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0 * r2 + a1 * r4 + a2 * r6;
		double tangential_x = 2.0*p1*XY + p0 * (r2 + 2.0*X2);
		double tangential_y = p1 * (r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0 * r2;
		double prism_y = s1 * r2;

		double xcn_ = radial * xcn + tangential_x + prism_x;
		double ycn_ = radial * ycn + tangential_y + prism_y;

		img_point[ii].x = alpha * xcn_ + gamma * ycn_ + u0;
		img_point[ii].y = beta * ycn_ + v0;
	}

	return;
}

void LensCorrectionPoint(Point2d *uv, double *K, double *distortion, int npts)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(Point2f *uv, double *K, double *distortion, int npts)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2f> &uv, double *K, double *distortion)
{
	double u, v, xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = (int)uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		u = uv[ii].x, v = uv[ii].y;
		CC_Calculate_xcn_ycn_from_i_j(u, v, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2d> &uv, double *K, double *distortion)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = (int)uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensUndistortion(unsigned char *Img, int width, int height, int nchannels, double *K, double *distortion, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width * height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth * Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk * length, Para + kk * length, width, height, intepAlgo);
	}

	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			LensDistortionPoint(&ImgPt, K, distortion, 1);

			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk * length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj * Mwidth + kk * Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

int EssentialMatOutliersRemove(char *Path, int timeID, int id1, int id2, int nCams, int cameraToScan, int ninlierThresh, int distortionCorrected, bool needDuplicateRemove)
{
	CameraData *camera = new CameraData[nCams];
	if (ReadIntrinsicResults(Path, camera) != 0)
		return 1;

	if (distortionCorrected == 1)
		for (int ii = 0; ii < nCams; ii++)
			for (int jj = 0; jj < 7; jj++)
				camera[ii].distortion[jj] = 0.0;

	for (int ii = 0; ii < nCams; ii++)
		camera[ii].threshold = 3.0, camera[ii].nInlierThresh = 50;

	char Fname[512];
	vector<Point2i> RawPairWiseMatchID;
	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/M_%.4d_%.2d_%.2d.txt", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printLOG("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < 40)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/%.4d.kpts", Path, id1);
	else
		sprintf(Fname, "%s/%d/%.4d.kpts", Path, id1, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/%.4d.kpts", Path, id2);
	else
		sprintf(Fname, "%s/%d/%.4d.kpts", Path, id2, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = (int)SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = (int)RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
		else
			sprintf(Fname, "%s/M_%.4d_%.2d_%.2d.txt", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1[ii].x = Keys1[id1].pt.x, pts1[ii].y = Keys1[id1].pt.y;
		pts2[ii].x = Keys2[id2].pt.x, pts2[ii].y = Keys2[id2].pt.y;
	}

	if (cameraToScan != -1)
	{
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
			LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
		}
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == FISHEYE)
		{
			//FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
			//FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
			FishEyeCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion[0], npts);
			FishEyeCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion[0], npts);
		}
	}
	else
	{
		if (distortionCorrected == 0 && camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion, npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion, npts);
		if (distortionCorrected == 0 && camera[id1].LensModel == FISHEYE)
			//FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2], npts);
			FishEyeCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion[0], npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == FISHEYE)
			//FishEyeCorrectionPoint(pts1, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2], npts);
			FishEyeCorrectionPoint(pts1, camera[id2].K, camera[id2].distortion[0], npts);
	}

	Mat x1s(npts, 2, CV_64F), x2s(npts, 2, CV_64F);
	for (int ii = 0; ii < npts; ii++)
	{
		x1s.at<double>(ii, 0) = pts1[ii].x, x1s.at<double>(ii, 1) = pts1[ii].y;
		x2s.at<double>(ii, 0) = pts2[ii].x, x2s.at<double>(ii, 1) = pts2[ii].y;
	}

	double start = omp_get_wtime();
	Mat Inliers, E;
	double ProThresh = 0.95, PercentInlier = 0.2;
	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 5)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	if (cameraToScan != -1)
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold,  Inliers);
	}
	else
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[id1].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[id2].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold,  Inliers);
	}

	int ninliers = 0;
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			ninliers++;

	if (ninliers < camera[0].nInlierThresh)
	{
#pragma omp critical
		printLOG("View (%d, %d) fails....%d inliers\n", id1, id2, ninliers);
		return 0;
	}

	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/M_%.4d_%.2d_%.2d.txt", Path, timeID, id1, id2);
	fp = fopen(Fname, "w+");	fprintf(fp, "%d\n", ninliers);
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
	fclose(fp);

#pragma omp critical
	printLOG("View (%d, %d) of frame %.4d...%d matches... %.2fs\n", id1, id2, timeID, ninliers, omp_get_wtime() - start);
	return 0;
}
int FundamentalMatOutliersRemove(char *Path, int timeID, int id1, int id2, int ninlierThresh, int LensType, int distortionCorrected, bool needDuplicateRemove, int nCams, int cameraToScan, int *frameTimeStamp)
{
	if (frameTimeStamp == NULL)
	{
		frameTimeStamp = new int[nCams];
		for (int ii = 0; ii < nCams; ii++)
			frameTimeStamp[ii] = 0;
	}

	bool noCalibInfo = false;
	CameraData *camera = new CameraData[nCams];
	if (!ReadIntrinsicResults(Path, camera) != 0)
		noCalibInfo = true;
	if (noCalibInfo &&distortionCorrected == 0 && LensType == FISHEYE)
		return 1;

	vector<Point2i> RawPairWiseMatchID;
	char Fname[512];
	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/%.4d/M_%.2d_%.2d.txt", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printLOG("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < ninlierThresh)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/%.4d.kpts", Path, id1);
	else
		sprintf(Fname, "%s/%d/%.4d.kpts", Path, id1, timeID - frameTimeStamp[id1]);
	if (!ReadKPointsBinarySIFT(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/%.4d.kpts", Path, id2);
	else
		sprintf(Fname, "%s/%d/%.4d.kpts", Path, id2, timeID - frameTimeStamp[id2]);
	if (!ReadKPointsBinarySIFT(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = (int)SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = (int)RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
		else
			sprintf(Fname, "%s/Dynamic/%.4d/M_%.2d_%.2d.txt", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	vector<Point2d> pts1, pts2;
	pts1.reserve(npts), pts2.reserve(npts);
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1.push_back(Point2d(Keys1[id1].pt.x, Keys1[id1].pt.y));
		pts2.push_back(Point2d(Keys2[id2].pt.x, Keys2[id2].pt.y));
	}

	if (distortionCorrected == 0 && !noCalibInfo) //only one camera is used to scan the corpus
	{
		if (cameraToScan != -1)
		{
			if (camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion);
				LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion);
			}
			else if (camera[cameraToScan].LensModel == FISHEYE)
			{
				//FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
				FishEyeCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion[0]);
				//FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
				FishEyeCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion[0]);
			}
		}
		else
		{
			if (camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
				LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion);
			else if (camera[id1].LensModel == FISHEYE)
				//FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2]);
				FishEyeCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion[0]);
			if (camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
				LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion);
			else if (camera[id2].LensModel == FISHEYE)
				//FishEyeCorrectionPoint(pts2, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2]);
				FishEyeCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion[0]);
		}
	}
	delete[]camera;

	//USAC config
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	ConfigParamsFund cfg;
	cfg.common.confThreshold = 0.99, cfg.common.minSampleSize = 7, cfg.common.inlierThreshold = noCalibInfo ? 7.5 : 5.0;
	cfg.common.maxHypotheses = 850000, cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true, cfg.common.prevalidateModel = true, cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM, cfg.common.verifMethod = USACConfig::VERIF_SPRT, cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	if (USEPROSAC)
		cfg.prosac.maxSamples, cfg.prosac.beta, cfg.prosac.nonRandConf, cfg.prosac.minStopLen;
	if (USESPRT)
		cfg.sprt.tM = 200.0, cfg.sprt.mS = 2.38, cfg.sprt.delta = 0.05, cfg.sprt.epsilon = 0.15;
	if (USELOSAC)
		cfg.losac.innerSampleSize = 15, cfg.losac.innerRansacRepetitions = 5, cfg.losac.thresholdMultiplier = 2.0, cfg.losac.numStepsIterative = 4;

	int ninliers = 0;
	double Fmat[9];
	vector<int>Inliers; Inliers.reserve(pts1.size());
	cfg.common.numDataPoints = (int)pts1.size();
	USAC_FindFundamentalMatrix(cfg, pts1, pts2, Fmat, Inliers, ninliers);
#pragma omp critical
	if (ninliers < ninlierThresh)
		printLOG("(%d, %d): failed Fundamental matrix test\n\n", id1, id2);

	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%.2d_%.2d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/%.4d/M_%.2d_%.2d.txt", Path, timeID, id1, id2);
#pragma omp critical
	fp = fopen(Fname, "w+");

	if (ninliers < ninlierThresh)
	{
		fprintf(fp, "%d\n", 0);
		fclose(fp);
	}
	else
	{
		fprintf(fp, "%d\n", ninliers);
		for (int ii = 0; ii < Inliers.size(); ii++)
			if (Inliers[ii] == 1)
				fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

#pragma omp critical
	if (timeID > 0)
		printLOG("(%d, %d) to (%d, %d) ...%d matches...\n", id1, timeID - frameTimeStamp[id1], id2, timeID - frameTimeStamp[id2], ninliers);
	else
		printLOG("%d to  %d ...%d matches...\n", id1, id2, ninliers);

	return 0;
}
int TwoViewsClean3DReconstructionFmat(CameraData &View1, CameraData &View2, vector<Point2d>imgpts1, vector<Point2d> imgpts2, vector<Point3d> &P3D)
{
	//Assuming correspondences are perfect. Note that points are not undistorted
	int ii, jj;
	int npts = (int)imgpts1.size();

	if (View1.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts1, View1.K, View1.distortion);
	else
		//FishEyeCorrectionPoint(imgpts1, View1.distortion[0], View1.distortion[1], View1.distortion[2]);
		FishEyeCorrectionPoint(imgpts1, View1.K, View1.distortion[0]);

	if (View2.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts2, View2.K, View2.distortion);
	else
		//FishEyeCorrectionPoint(imgpts2, View2.distortion[0], View2.distortion[1], View2.distortion[2]);
		FishEyeCorrectionPoint(imgpts2, View2.K, View2.distortion[0]);

	//Estimate fundamental matrix
	vector<int> pid;
	Mat cvF = findFundamentalMat(imgpts1, imgpts2, FM_8POINT, 3.0);

	//cout << "Fmat: " << cvF << endl << endl;

	//Extract essential matrix
	Mat cvK1(3, 3, CV_64F, View1.K);
	Mat cvK2(3, 3, CV_64F, View2.K);

	Mat cvE = cvK2.t()*cvF*cvK1;
	//cout << "Emat: " << cvE << endl << endl;

	//Decompose into RT
	SVD svd(cvE, SVD::MODIFY_A);
	double m = (svd.w.at<double>(0) + svd.w.at<double>(1)) / 2;
	double nW[9] = { m, 0, 0, 0, m, 0, 0, 0, 0 };
	Mat cvnW(3, 3, CV_64F, nW);
	Mat cvnE = svd.u*cvnW*svd.vt;
	SVD svd2(cvnE, SVD::MODIFY_A);

	cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = -1.0, cvnW.at<double>(0, 2) = 0.0;
	cvnW.at<double>(1, 0) = 1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
	cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = 1.0;

	//Make sure we return rotation matrices with det(R) == 1
	Mat UWVt = svd2.u*cvnW*svd2.vt;
	if (determinant(UWVt) < 0.0)
	{
		cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = 1.0, cvnW.at<double>(0, 2) = 0.0;
		cvnW.at<double>(1, 0) = -1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
		cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = -1.0;
	}

	UWVt = svd2.u*cvnW*svd2.vt;
	Mat UWtVt = svd2.u*cvnW.t()*svd2.vt;

	double maxU = 0.0;
	for (ii = 0; ii < 3; ii++)
		if (maxU < abs(svd2.u.at<double>(ii, 2)))
			maxU = abs(svd2.u.at<double>(ii, 2));

	//There are 4 possible cases
	double RT2[] = { UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU };

	//Cherality check
	double P1[12], P2[48], RT1[] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };
	mat_mul(View1.K, RT1, P1, 3, 3, 4);
	for (ii = 0; ii < 4; ii++)
		mat_mul(View2.K, RT2 + 12 * ii, P2 + 12 * ii, 3, 3, 4);

	Point3d p3d;
	int positivePoints[4] = { 0, 0, 0, 0 }, RTid[4] = { 0, 1, 2, 3 };
	for (ii = 0; ii < imgpts1.size(); ii++)
	{
		for (jj = 0; jj < 4; jj++)
		{
			TwoViewTriangulation(&imgpts1[ii], &imgpts2[ii], P1, P2 + 12 * jj, &p3d);
			if (p3d.z > 0.0)
				positivePoints[jj] ++;
		}
	}

	Quick_Sort_Int(positivePoints, RTid, 0, 3);
	if (positivePoints[3] < 10)
	{
		cout << "Something wrong. Only a few points have positve z values" << endl;
		return 1;
	}

	//Finalize data
	for (ii = 0; ii < 3; ii++)
		View1.rt[ii] = 0.0, View1.rt[ii + 3] = 0.0;

	Mat rvec, Rmat = (Mat_<double>(3, 3) << RT2[RTid[3] * 12], RT2[RTid[3] * 12 + 1], RT2[RTid[3] * 12 + 2],
		RT2[RTid[3] * 12 + 4], RT2[RTid[3] * 12 + 5], RT2[RTid[3] * 12 + 6],
		RT2[RTid[3] * 12 + 8], RT2[RTid[3] * 12 + 9], RT2[RTid[3] * 12 + 10]);
	Rodrigues(Rmat, rvec);

	for (ii = 0; ii < 3; ii++)
		View2.rt[ii] = rvec.at<double>(ii), View2.rt[ii + 3] = RT2[RTid[3] * 12 + 3 + 4 * ii];

	//Triangulate
	TwoViewTriangulation(imgpts1, imgpts2, P1, P2 + 12 * RTid[3], P3D);

	return 0;
}
double FmatPointError(double *F, Point2d p1, Point2d p2)
{
	Map< Matrix<double, 3, 3, RowMajor> >	Fmat(F, 3, 3);

	Vector3d Fp1 = Fmat * Vector3d(p1.x, p1.y, 1.0);
	Vector3d Ftp2 = Fmat.transpose()*Vector3d(p2.x, p2.y, 1.0);

	//SymmetricEpipolarDistance: x2'*F*x1*(1.0/(...) + 1.0/(...))
	double num = abs((p2.x*Fp1(0) + p2.y*Fp1(1) + Fp1(2)));
	double denum1 = sqrt(Fp1(0)*Fp1(0) + Fp1(1)*Fp1(1));
	double denum2 = sqrt(Ftp2(0)*Ftp2(0) + Ftp2(1)*Ftp2(1));
	return 0.5*num * (1.0 / denum1 + 1.0 / denum2);
}
void computeFmat(double *K1, double *K2, double *R1, double *T1, double *R2, double *T2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];

	double RT1[16], RT2[16];
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}
void computeFmat(CameraData Cam1, CameraData Cam2, double *Fmat)
{
	double K1[9] = { Cam1.K[0], Cam1.K[1], Cam1.K[2], 0, Cam1.K[4], Cam1.K[5], 0, 0, 1.0 };
	double K2[9] = { Cam2.K[0], Cam2.K[1], Cam2.K[2], 0, Cam2.K[4], Cam2.K[5], 0, 0, 1.0 };
	double rt1[6] = { Cam1.rt[0], Cam1.rt[1], Cam1.rt[2], Cam1.rt[3], Cam1.rt[4], Cam1.rt[5] };
	double rt2[6] = { Cam2.rt[0], Cam2.rt[1], Cam2.rt[2], Cam2.rt[3], Cam2.rt[4], Cam2.rt[5] };

	double R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	GetRTFromrt(rt2, R2, T2);

	computeFmat(K1, K2, R1, T1, R2, T2, Fmat);

	return;
}
void computeFmatfromKRT(CameraData *CameraInfo, int nviews, int *selectedIDs, double *Fmat)
{
	double K1[9] = { CameraInfo[selectedIDs[0]].K[0], CameraInfo[selectedIDs[0]].K[1], CameraInfo[selectedIDs[0]].K[2],
		0, CameraInfo[selectedIDs[0]].K[4], CameraInfo[selectedIDs[0]].K[5],
		0, 0, 1.0 };
	double K2[9] = { CameraInfo[selectedIDs[1]].K[0], CameraInfo[selectedIDs[1]].K[1], CameraInfo[selectedIDs[1]].K[2],
		0, CameraInfo[selectedIDs[1]].K[4], CameraInfo[selectedIDs[1]].K[5],
		0, 0, 1.0 };
	double rt1[6] = { CameraInfo[selectedIDs[0]].rt[0], CameraInfo[selectedIDs[0]].rt[1], CameraInfo[selectedIDs[0]].rt[2],
		CameraInfo[selectedIDs[0]].rt[3], CameraInfo[selectedIDs[0]].rt[4], CameraInfo[selectedIDs[0]].rt[5] };
	double rt2[6] = { CameraInfo[selectedIDs[1]].rt[0], CameraInfo[selectedIDs[1]].rt[1], CameraInfo[selectedIDs[1]].rt[2],
		CameraInfo[selectedIDs[1]].rt[3], CameraInfo[selectedIDs[1]].rt[4], CameraInfo[selectedIDs[1]].rt[5] };

	double R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	GetRTFromrt(rt2, R2, T2);

	computeFmat(K1, K2, R1, T1, R2, T2, Fmat);

	return;
}
//if ChooseCorpusView != -1, selectedCams and seletectedTime will be overwritten
void computeFmatfromKRT(CorpusandVideo &CorpusandVideoInfo, int *selectedCams, int *seletectedTime, int ChooseCorpusView1, int ChooseCorpusView2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9], K2[9], rt1[6], rt2[6];

	if (ChooseCorpusView1 != -1)
	{
		K1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[0], K1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[1], K1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[4], K1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[0], rt1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[1], rt1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[2],
			rt1[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[3], rt1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[4], rt1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[5];
	}
	else
	{
		int ID = selectedCams[0] * MaxnFrames + seletectedTime[0];
		K1[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K1[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K1[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K1[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt1[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt1[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt1[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt1[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt1[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}

	if (ChooseCorpusView2 != -1)
	{
		K2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[0], K2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[1], K2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[4], K2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[0], rt2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[1], rt2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[2],
			rt2[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[3], rt2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[4], rt2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[5];
	}
	else
	{
		int ID = selectedCams[1] * MaxnFrames + seletectedTime[1];
		K2[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K2[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K2[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K2[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt2[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt2[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt2[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt2[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt2[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}


	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}

void FisheyeProjectandDistort(Point3d WC, Point2d *pts, double *P, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;
	double x, y, ru, rd, x_u, y_u, t;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;

		x = pts[ii].x - distortion[1], y = pts[ii].y - distortion[2];
		ru = sqrt(x*x + y * y), rd = atan(2.0*ru*tan(0.5*distortion[0])) / distortion[0];
		t = rd / ru;
		x_u = t * x, y_u = t * y;
		pts[ii].x = x_u + distortion[1], pts[ii].y = y_u + distortion[2];
	}

	return;
}

void FisheyeProjectandDistort(Point3d WC, Point2d *pts, double *P, double *K, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum, x, y;
	double omega = distortion[0];

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		x = num1 / denum, y = num2 / denum;


		if (K != NULL)
		{
			double ycn = (y - K[5]) / K[4];
			double xcn = (x - K[2] - K[1] * ycn) / K[0];

			double ru = sqrt(xcn*xcn + ycn * ycn), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
			double t = rd / ru;
			double x_u = t * xcn, y_u = t * ycn;
			pts[ii].x = K[0] * x_u + K[1] * y_u + K[2];
			pts[ii].y = K[4] * y_u + K[5];
		}
		else
			pts[ii].x = x, pts[ii].y = y;
	}

	return;
}
void ProjectandDistort(Point3d WC, Point2d *pts, double *P, double *K, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (K != NULL)
			LensDistortionPoint(&pts[ii], K + ii * 9, distortion + ii * 7);
	}

	return;
}
void ProjectandDistort(Point3d WC, vector<Point2d> &pts, double *P, double *camera, double *distortion)
{
	int ii;
	double num1, num2, denum;

	int nviews = (int)pts.size();
	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (camera != NULL)
			LensDistortionPoint(&pts[ii], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void ProjectandDistort(vector<Point3d> WC, Point2d *pts, double *P, double *camera, double *distortion, int nviews)
{
	int ii, jj, npts = (int)WC.size();
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		for (jj = 0; jj < npts; jj++)
		{
			num1 = P[ii * 12 + 0] * WC[jj].x + P[ii * 12 + 1] * WC[jj].y + P[ii * 12 + 2] * WC[jj].z + P[ii * 12 + 3];
			num2 = P[ii * 12 + 4] * WC[jj].x + P[ii * 12 + 5] * WC[jj].y + P[ii * 12 + 6] * WC[jj].z + P[ii * 12 + 7];
			denum = P[ii * 12 + 8] * WC[jj].x + P[ii * 12 + 9] * WC[jj].y + P[ii * 12 + 10] * WC[jj].z + P[ii * 12 + 11];

			pts[ii*npts + jj].x = num1 / denum, pts[ii*npts + jj].y = num2 / denum;
		}
		if (camera != NULL)
			for (jj = 0; jj < npts; jj++)
				LensDistortionPoint(&pts[ii*npts + jj], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void TwoViewTriangulation(Point2d *pts1, Point2d *pts2, double *P1, double *P2, Point3d *WC, int npts)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < npts; ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1 * p31;
		A[1] = p12 - u1 * p32;
		A[2] = p13 - u1 * p33;
		A[3] = p21 - v1 * p31;
		A[4] = p22 - v1 * p32;
		A[5] = p23 - v1 * p33;

		A[6] = P11 - u2 * P31;
		A[7] = P12 - u2 * P32;
		A[8] = P13 - u2 * P33;
		A[9] = P21 - v2 * P31;
		A[10] = P22 - v2 * P32;
		A[11] = P23 - v2 * P33;

		B[0] = u1 * p34 - p14;
		B[1] = v1 * p34 - p24;
		B[2] = u2 * P34 - P14;
		B[3] = v2 * P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC[ii].x = B[0];
		WC[ii].y = B[1];
		WC[ii].z = B[2];
	}

	return;
}
void TwoViewTriangulation(vector<Point2d> pts1, vector<Point2d> pts2, double *P1, double *P2, vector<Point3d> &WC)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < (int)pts1.size(); ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1 * p31;
		A[1] = p12 - u1 * p32;
		A[2] = p13 - u1 * p33;
		A[3] = p21 - v1 * p31;
		A[4] = p22 - v1 * p32;
		A[5] = p23 - v1 * p33;

		A[6] = P11 - u2 * P31;
		A[7] = P12 - u2 * P32;
		A[8] = P13 - u2 * P33;
		A[9] = P21 - v2 * P31;
		A[10] = P22 - v2 * P32;
		A[11] = P23 - v2 * P33;

		B[0] = u1 * p34 - p14;
		B[1] = v1 * p34 - p24;
		B[2] = u2 * P34 - P14;
		B[3] = v2 * P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC.push_back(Point3d(B[0], B[1], B[2]));
	}

	return;
}
void TwoViewTriangulationQualityCheck(Point2d *pts1, Point2d *pts2, Point3d *WC, double *P1, double *P2, bool *GoodPoints, double thresh, int npts, double *K1, double *K2, double *distortion1, double *distortion2)
{
	double u1, v1, u2, v2, denum, reprojectionError;
	for (int ii = 0; ii < npts; ii++)
	{
		Point2d p1(pts1[ii].x, pts1[ii].y), p2(pts2[ii].x, pts2[ii].y);
		if (distortion1 != NULL)
		{
			LensCorrectionPoint(&p1, K1, distortion1);
			LensCorrectionPoint(&p2, K2, distortion2);
		}

		//Project to 1st view
		denum = P1[8] * WC[ii].x + P1[9] * WC[ii].y + P1[10] * WC[ii].z + P1[11];
		u1 = (P1[0] * WC[ii].x + P1[1] * WC[ii].y + P1[2] * WC[ii].z + P1[3]) / denum;
		v1 = (P1[4] * WC[ii].x + P1[5] * WC[ii].y + P1[6] * WC[ii].z + P1[7]) / denum;

		//Project to 2nd view
		denum = P2[8] * WC[ii].x + P2[9] * WC[ii].y + P2[10] * WC[ii].z + P2[11];
		u2 = (P2[0] * WC[ii].x + P2[1] * WC[ii].y + P2[2] * WC[ii].z + P2[3]) / denum;
		v2 = (P2[4] * WC[ii].x + P2[5] * WC[ii].y + P2[6] * WC[ii].z + P2[7]) / denum;

		reprojectionError = (abs(u2 - p2.x) + abs(v2 - p2.y) + abs(u1 - p1.x) + abs(v1 - p1.y)) / 4.0;
		if (reprojectionError > thresh)
			GoodPoints[ii] = false;
		else
			GoodPoints[ii] = true;
	}
	return;
}
void NviewTriangulation(Point2d *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj * npts].x, v = pts[ii + jj * npts].y;

				A[6 * jj + 0] = P[12 * jj] - u * P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u * P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u * P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v * P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v * P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v * P[12 * jj + 10];
				B[2 * jj + 0] = u * P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v * P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj * npts].x, v = pts[ii + jj * npts].y;

				A[6 * jj + 0] = P[12 * jj] - u * P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u * P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u * P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v * P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v * P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v * P[12 * jj + 10];
				B[2 * jj + 0] = u * P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v * P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(vector<Point2d> *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u * P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u * P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u * P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v * P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v * P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v * P[12 * jj + 10];
				B[2 * jj + 0] = u * P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v * P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u * P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u * P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u * P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v * P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v * P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v * P[12 * jj + 10];
				B[2 * jj + 0] = u * P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v * P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(CameraData *ViewInfo, int nviews, vector <vector<int> > &viewIdAll3D, vector<vector<Point2d> > &uvAll3D, vector<Point3d> &AllP3D, bool CayleyRS)
{
	int count;

	double *P = new double[12 * nviews], *A = new double[6 * nviews], *B = new double[2 * nviews], *points2d = new double[nviews * 2];

	double error, point3d[3];
	Point3d p3d;
	vector<Point2d> p2d;
	for (int ii = 0; ii < (int)viewIdAll3D.size(); ii++)
	{
		if (viewIdAll3D[ii].size() > 1)
		{
			p2d.clear();
			count = 0;
			for (int jj = 0; jj < viewIdAll3D[ii].size(); jj++)
			{
				if (ViewInfo[viewIdAll3D[ii][jj]].valid)
				{
					for (int kk = 0; kk < 12; kk++)
						P[count * 12 + kk] = ViewInfo[viewIdAll3D[ii][jj]].P[kk];
					p2d.push_back(uvAll3D[ii][jj]);

					int viewID = viewIdAll3D[ii][jj];
					LensCorrectionPoint(&p2d[count], ViewInfo[viewID].K, ViewInfo[viewID].distortion);
					count++;
				}
			}

			NviewTriangulation(&p2d, P, &p3d, count, 1, NULL, A, B);

			point3d[0] = p3d.x, point3d[1] = p3d.y, point3d[2] = p3d.z;
			for (int jj = 0; jj < count; jj++)
				points2d[2 * jj] = p2d[jj].x, points2d[2 * jj + 1] = p2d[jj].y;

			if (!CayleyRS)
				NviewTriangulationNonLinear(P, points2d, point3d, &error, count, 1);
			else
				NviewTriangulationNonLinearCayley(ViewInfo, points2d, point3d, &error, nviews, 1);

			AllP3D[ii] = Point3d(point3d[0], point3d[1], point3d[2]);
		}
	}
	delete[]P, delete[]A, delete[]B, delete[]points2d;

	return;
}
double NviewTriangulationRANSAC(Point2d *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int nMinPoints, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
		tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	vector<int> viewList;
	for (int ii = 0; ii < nview; ii++)
		viewList.push_back(ii);

	bool bruteforce = false;
	Combination CamCom(nview, nMinPoints);
	int nComs = CamCom.total_com;
	int *allCamCom, *ComI;
	if (nComs < MaxRanSacIter)
	{
		bruteforce = true;
		allCamCom = new int[nMinPoints * nComs];
		ComI = new int[nMinPoints];
		CamCom.All_Com(allCamCom);
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		bestCount = 0;
		for (kk = 0; kk < min(nComs, MaxRanSacIter); kk++)
		{
			//NviewTriangulation(tpts, tallP, &Vxyz[jid], count, 1, NULL, NULL, NULL);
			if (bruteforce)
				for (int jj = 0; jj < nMinPoints; jj++)
					ComI[jj] = allCamCom[nMinPoints*kk + jj];
			else
			{
				random_shuffle(viewList.begin(), viewList.end());
				for (int jj = 0; jj < nMinPoints; jj++)
					ComI[jj] = viewList[jj];
			}

			for (jj = 0; jj < nMinPoints; jj++)
			{
				ll = ComI[jj];
				u = pts[ii + ll * npts].x, v = pts[ii + ll * npts].y;

				A[6 * jj + 0] = P[12 * ll] - u * P[12 * ll + 8];
				A[6 * jj + 1] = P[12 * ll + 1] - u * P[12 * ll + 9];
				A[6 * jj + 2] = P[12 * ll + 2] - u * P[12 * ll + 10];
				A[6 * jj + 3] = P[12 * ll + 4] - v * P[12 * ll + 8];
				A[6 * jj + 4] = P[12 * ll + 5] - v * P[12 * ll + 9];
				A[6 * jj + 5] = P[12 * ll + 6] - v * P[12 * ll + 10];
				B[2 * jj + 0] = u * P[12 * ll + 11] - P[12 * ll + 3];
				B[2 * jj + 1] = v * P[12 * ll + 11] - P[12 * ll + 7];
			}
			QR_Solution_Double(A, B, 2 * nMinPoints, 3);
			t3D.x = B[0], t3D.y = B[1], t3D.z = B[2];

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				_pt = pts[ii + jj * npts];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii + jj * npts].x) < threshold && abs(_pt.y - pts[ii + jj * npts].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll < nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount > nview*inlierPercent)
				break;
		}

		int t = nview * inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii + jj * npts].x, v = pts[ii + jj * npts].y;
				goodpts2d[count] = pts[jj], goodpts2dbk[count] = pts[jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u * tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u * tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u * tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v * tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v * tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v * tP[12 * jj + 10];
				B[2 * jj + 0] = u * tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v * tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count / 2);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac && bestCount < nview)
			{
				int ogoodCount = -1;
				while (goodCount > ogoodCount)
				{
					goodCount = 0; finalerror = 0.0;
					Inliers[ii].clear();
					for (jj = 0; jj < nview; jj++)
					{
						ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
						double difx = _pt.x - pts[ii + jj * npts].x, dify = _pt.y - pts[ii + jj * npts].y, error = pow(difx, 2) + pow(dify, 2);

						if (error < threshold*threshold)
						{
							finalerror += error;
							Inliers[ii].push_back(1);

							GoodViewID[jj] = true;
							for (int ll = 0; ll < 12; ll++)
								tP[12 * goodCount + ll] = P[12 * jj + ll];
							goodpts2dbk[goodCount] = pts[ii + jj * npts];
							P2D[2 * goodCount] = pts[ii + jj * npts].x, P2D[2 * goodCount + 1] = pts[ii + jj * npts].y;
							goodCount++;
						}
						else
							GoodViewID[jj] = false, Inliers[ii].push_back(0);
					}
					finalerror = sqrt(finalerror / goodCount);
					ogoodCount = goodCount;

					if (goodCount > bestCount)
					{
						bestCount = goodCount;
						NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
						WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];
					}
				}
			}

			Inliers[ii].clear(); finalerror = 0;
			for (jj = 0; jj < nview; jj++)
			{
				ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
				double difx = _pt.x - pts[ii + jj * npts].x, dify = _pt.y - pts[ii + jj * npts].y, error = pow(difx, 2) + pow(dify, 2);

				if (error < threshold*threshold)
				{
					finalerror += error;
					Inliers[ii].push_back(1);
				}
				else
					Inliers[ii].push_back(0);
			}
			finalerror = sqrt(finalerror / goodCount);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
	}

	if (bruteforce)
		delete[]allCamCom, delete[]ComI;

	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
double NviewTriangulationRANSAC(vector<Point2d> *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int nMinPoints, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview], B = new double[2 * nview], tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	vector<int> viewList;
	for (int ii = 0; ii < nview; ii++)
		viewList.push_back(ii);

	bool bruteforce = false;
	Combination CamCom(nview, nMinPoints);
	int nComs = CamCom.total_com;
	int *allCamCom, *ComI;
	if (nComs < MaxRanSacIter)
	{
		bruteforce = true;
		allCamCom = new int[nMinPoints * nComs];
		ComI = new int[nMinPoints];
		CamCom.All_Com(allCamCom);
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		bestCount = 0;
		for (kk = 0; kk < MaxRanSacIter; kk++)
		{
			//NviewTriangulation(tpts, tallP, &Vxyz[jid], count, 1, NULL, NULL, NULL);
			if (bruteforce)
				for (int jj = 0; jj < nMinPoints; jj++)
					ComI[jj] = allCamCom[nMinPoints*kk + jj];
			else
			{
				random_shuffle(viewList.begin(), viewList.end());
				for (int jj = 0; jj < nMinPoints; jj++)
					ComI[jj] = viewList[jj];
			}

			for (jj = 0; jj < nMinPoints; jj++)
			{
				ll = ComI[jj];
				u = pts[ii][ll].x, v = pts[ii][ll].y;

				A[6 * jj + 0] = P[12 * ll] - u * P[12 * ll + 8];
				A[6 * jj + 1] = P[12 * ll + 1] - u * P[12 * ll + 9];
				A[6 * jj + 2] = P[12 * ll + 2] - u * P[12 * ll + 10];
				A[6 * jj + 3] = P[12 * ll + 4] - v * P[12 * ll + 8];
				A[6 * jj + 4] = P[12 * ll + 5] - v * P[12 * ll + 9];
				A[6 * jj + 5] = P[12 * ll + 6] - v * P[12 * ll + 10];
				B[2 * jj + 0] = u * P[12 * ll + 11] - P[12 * ll + 3];
				B[2 * jj + 1] = v * P[12 * ll + 11] - P[12 * ll + 7];
			}
			QR_Solution_Double(A, B, 2 * nMinPoints, 3);
			t3D.x = B[0], t3D.y = B[1], t3D.z = B[2];

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				//_pt = pts[ii + jj*npts];
				_pt = pts[ii][jj];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii][jj].x) < threshold && abs(_pt.y - pts[ii][jj].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll < nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount > nview*inlierPercent)
				break;
		}

		int t = nview * inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					//pts[ii + jj*npts].x = 0.0, pts[ii + jj*npts].y = 0.0;
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii][jj].x, v = pts[ii][jj].y;
				goodpts2d[count] = pts[ii][jj], goodpts2dbk[count] = pts[ii][jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u * tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u * tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u * tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v * tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v * tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v * tP[12 * jj + 10];
				B[2 * jj + 0] = u * tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v * tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count / 2);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac && bestCount < nview)
			{
				int ogoodCount = -1;
				while (goodCount > ogoodCount)
				{
					goodCount = 0; finalerror = 0.0;
					Inliers[ii].clear();
					for (jj = 0; jj < nview; jj++)
					{
						ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
						double difx = _pt.x - pts[ii][jj].x, dify = _pt.y - pts[ii][jj].y, error = pow(difx, 2) + pow(dify, 2);
						if (error < threshold*threshold)
						{
							finalerror += error;
							Inliers[ii].push_back(1);

							GoodViewID[jj] = true;
							for (int ll = 0; ll < 12; ll++)
								tP[12 * goodCount + ll] = P[12 * jj + ll];

							goodpts2dbk[goodCount] = pts[ii][jj];
							P2D[2 * goodCount] = pts[ii][jj].x, P2D[2 * goodCount + 1] = pts[ii][jj].y;
							goodCount++;
						}
						else
							GoodViewID[jj] = false, Inliers[ii].push_back(0);
					}
					finalerror = sqrt(finalerror / goodCount);
					ogoodCount = goodCount;

					if (goodCount > bestCount)
					{
						bestCount = goodCount;
						NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
						WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];
					}
				}
			}

			Inliers[ii].clear(); finalerror = 0;
			for (jj = 0; jj < nview; jj++)
			{
				ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
				double difx = _pt.x - pts[ii][jj].x, dify = _pt.y - pts[ii][jj].y, error = pow(difx, 2) + pow(dify, 2);

				if (error < threshold*threshold)
				{
					finalerror += error;
					Inliers[ii].push_back(1);
				}
				else
					Inliers[ii].push_back(0);
			}
			finalerror = sqrt(finalerror / goodCount);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
	}

	if (bruteforce)
		delete[]allCamCom, delete[]ComI;
	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
void MultiViewQualityCheck(Point2d *Pts, double *Pmat, int LensType, double *K, double *distortion, bool *PassedPoints, int nviews, int npts, double thresh, Point3d *aWC, Point2d *apts, Point2d *bkapts, int *DeviceMask, double *tK, double *tdistortion, double *tP, double *A, double *B)
{
	//Pts: [pts1; pts2; ...; ptsN]: (npts X nviews) matrix
	int ii, jj, kk, devCount;
	Point3d WC;
	bool createMem = false;
	double error;

	if (apts == NULL)
	{
		createMem = true;
		apts = new Point2d[nviews], bkapts = new Point2d[nviews], DeviceMask = new int[nviews];
		tK = new double[9 * nviews], tdistortion = new double[7 * nviews], tP = new double[12 * nviews];
	}

	for (ii = 0; ii < npts; ii++)
	{
		devCount = 0;
		for (jj = 0; jj < nviews; jj++)
		{
			DeviceMask[jj] = 1;
			if (Pts[jj + ii * nviews].x < 1 || Pts[jj + ii * nviews].y < 1)
				DeviceMask[jj] = 0;
			else
			{
				bkapts[devCount].x = Pts[jj + ii * nviews].x, bkapts[devCount].y = Pts[jj + ii * nviews].y;
				apts[devCount].x = bkapts[devCount].x, apts[devCount].y = bkapts[devCount].y;
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					LensCorrectionPoint(&apts[devCount], K + 9 * jj, distortion + 7 * jj);
				else
					//FishEyeCorrectionPoint(&apts[devCount], distortion[7 * jj], distortion[7 * jj + 1], distortion[7 * jj + 2]);
					FishEyeCorrectionPoint(&apts[devCount], K + 9 * jj, distortion[7 * jj]);

				for (kk = 0; kk < 12; kk++)
					tP[12 * devCount + kk] = Pmat[12 * jj + kk];
				for (kk = 0; kk < 9; kk++)
					tK[9 * devCount + kk] = K[9 * jj + kk];
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					for (kk = 0; kk < 7; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				else
					for (kk = 0; kk < 3; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				devCount++;
			}
		}

		NviewTriangulation(apts, tP, &WC, devCount, 1, NULL, A, B);
		if (aWC != NULL)
			aWC[ii] = WC;
		if (LensType == RADIAL_TANGENTIAL_PRISM)
			ProjectandDistort(WC, apts, tP, tK, tdistortion, devCount);
		else
			FisheyeProjectandDistort(WC, apts, tP, tdistortion, devCount);

		error = 0.0;
		for (jj = 0; jj < devCount; jj++)
			error += pow(bkapts[jj].x - apts[jj].x, 2) + pow(bkapts[jj].y - apts[jj].y, 2);
		error = sqrt(error / devCount);
		if (error < thresh)
			PassedPoints[ii] = true;
		else
			PassedPoints[ii] = false;
	}

	if (createMem)
	{
		delete[]apts, delete[]bkapts, delete[]DeviceMask;
		delete[]tK, delete[]tdistortion, delete[]tP;
	}

	return;
}
void NviewTriangulationRANSACDriver(CameraData *AllViewsInfo, vector<int>Selected3DIndex, vector<int> *nSelectedViews, vector<Point2d> *Selected2D, int nviews)
{
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *P = new double[12 * nviews * 2];
	double *tP = new double[12 * nviews * 2];
	int *BestViewID = new int[nviews * 2];
	bool *passedTri = new bool[nviews * 2];

	Point3d t3D;
	for (int ii = 0; ii < Selected3DIndex.size(); ii++)
	{
		int nviewsII = (int)nSelectedViews[ii].size();
		if (nviewsII <= 2 * nviews)
		{
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}

			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, 2, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);
		}
		else
		{
			double *A = new double[6 * nviewsII];
			double *B = new double[2 * nviewsII];
			double *P = new double[12 * nviewsII];
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}
			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, 2, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);

			delete[]A, delete[]B, delete[]P;
		}

	}
	delete[]A, delete[]B, delete[]P, delete[]BestViewID;

	return;
}

int FmatSyncBruteForce2DStereo(char *Path, int *SelectedCams, int realStartFrame, int startF, int stopF, int ntracks, int *OffsetInfo, int LowBound, int UpBound, bool GivenF, bool silent)
{
	char Fname[512]; FILE *fp = 0;
	const int nCams = 2;

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startF, stopF) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startF, stopF) == 1)
		return 1;

	int id, frameID, nf;
	int nframes = max(MaxnFrames, stopF);

	double u, v;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];
	vector<XYZD> *PerCam_XYZ = new vector<XYZD>[nCams], *XYZ = new vector<XYZD>[ntracks], XYZBK;

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopF - startF + 1);

		int  FirstValidFrame;
		if (!GivenF)
		{
			for (int fid = startF; fid < stopF; fid++)
			{
				if (VideoInfo[camID].VideoInfo[fid].valid)
				{
					FirstValidFrame = fid;
					break;
				}
			}
		}

		sprintf(Fname, "%s/Track2D/%.4d.txt", Path, SelectedCams[camID], realStartFrame); FILE *fp = fopen(Fname, "r");
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &nf);
			if (id != trackID)
				printLOG("Problem at Point %d of Cam %d", id, camID);
			for (int ii = 0; ii < nf; ii++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < startF || frameID>stopF)
					continue;
				if (GivenF && !VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID;
					if (GivenF)
						LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					else
						LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[FirstValidFrame].K, VideoInfo[camID].VideoInfo[FirstValidFrame].distortion);

					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	//Generate Calib Info
	if (GivenF)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			int count = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
				{
					int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],
						PerCam_UV[camID*ntracks + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];

					for (int kk = 0; kk < 3; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk],
						PerCam_UV[camID*ntracks + trackID][frameID].T[kk] = VideoInfo[camID].VideoInfo[RealFrameID].T[kk];
				}
			}
		}
	}

	//Start sliding
	int *OffsetID = new int[UpBound - LowBound + 1];
	double*AllFmatCost = new double[UpBound - LowBound + 1];

	int BestOffset = 0;
	double minError = 9e9;
	int count = 0;
	for (int off = LowBound; off <= UpBound; off++)
	{
		double Fmat[9], error, cumError = 0.0, usedPointsCount = 0;
		if (GivenF)
		{
			for (int trackID = 0; trackID < ntracks; trackID++)
			{
				for (int pid = 0; pid < PerCam_UV[trackID].size(); pid++)
				{
					int currentFrame = PerCam_UV[trackID][pid].frameID + OffsetInfo[0], otherCameraFrame = currentFrame + off + OffsetInfo[1];

					//see if the corresponding frame in the other camera has point
					error = 0.0;
					for (int pid2 = 0; pid2 < PerCam_UV[ntracks + trackID].size(); pid2++)
					{
						if (PerCam_UV[ntracks + trackID][pid2].frameID == otherCameraFrame)
						{
							computeFmat(VideoInfo[0].VideoInfo[currentFrame], VideoInfo[1].VideoInfo[otherCameraFrame], Fmat);
							error = FmatPointError(Fmat, PerCam_UV[trackID][pid].pt2D, PerCam_UV[ntracks + trackID][pid2].pt2D);
							usedPointsCount++;
							break;
						}
					}
					cumError += error;
				}
			}
		}
		else
		{
			//Compute Fmat
			vector<Point2d> points1, points2;
			for (int fid1 = 0; fid1 < (int)PerCam_UV[0].size(); fid1++)
			{
				for (int fid2 = 0; fid2 < (int)PerCam_UV[ntracks].size(); fid2++)
				{
					if (PerCam_UV[0][fid1].frameID + OffsetInfo[0] == PerCam_UV[ntracks][fid2].frameID + off + OffsetInfo[1])
					{
						for (int i = 0; i < ntracks; i++)
						{
							points1.push_back(PerCam_UV[i][fid1].pt2D);
							points2.push_back(PerCam_UV[i + ntracks][fid2].pt2D);
						}
						break;
					}
				}
			}

			if (points1.size() < 8)
			{
				cumError = 9e9;
				usedPointsCount = 0;
			}
			else
			{
				Mat cvFmat = findFundamentalMat(points1, points2, CV_FM_8POINT, 3, 0.99);

				double Fmat[9];
				for (int ii = 0; ii < 9; ii++)
					Fmat[ii] = cvFmat.at<double>(ii);

				for (int ii = 0; ii < (int)points1.size(); ii++)
					cumError += FmatPointError(Fmat, points1[ii], points2[ii]);
				usedPointsCount = points1.size();
			}
		}
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		AllFmatCost[count] = cumError;
		if (silent)
			printLOG("@off %d (id: %d): %.5f -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	printLOG("Pair (%d, %d): %d\n", SelectedCams[0], SelectedCams[1], BestOffset);

	OffsetInfo[1] = BestOffset;

	delete[]PerCam_UV, delete[]PerCam_XYZ;
	delete[]OffsetID, delete[]AllFmatCost;

	return 0;
}
int ClassifyPointsFromTriangulationLite(char *Path, int nCams, int StartFInst, int nViewsPlus, double TriangThesh)
{
	//since static points statisfy triangulation no matter what, noise and dynamic points can be classified
	char Fname[512];

	int minF = 9e9, maxF = -9e9;
	int fid, pid, npts = 0, newPidCount = 0;
	float u, v, s, a;

	vector<int> Vpid;
	for (int cid = 0; cid < nCams; cid++)
	{
		sprintf(Fname, "%s/Dynamic/K_%d_%.4d.txt", Path, cid, StartFInst);
		if (IsFileExist(Fname) == 0)
			continue;
		FILE *fp = fopen(Fname, "r");
		while (fscanf(fp, "%d %d %f %f %f %f ", &pid, &fid, &u, &v, &s, &a) != EOF)
		{
			int spid = -1;
			for (int ii = 0; ii < (int)Vpid.size() && spid == -1; ii++)
				if (Vpid[ii] == pid)
					spid = ii;
			if (spid == -1)
			{
				Vpid.push_back(pid);
				spid = npts;
				npts++;
			}

			minF = min(minF, fid);
			maxF = max(maxF, fid);
		}
		fclose(fp);
	}

	int *cFid = new int[nCams];
	vector<int>*PViewIdAll3D = new vector<int>[npts];
	vector<Point2f>*uvAll3D = new vector<Point2f>[npts];

	//Read key points
	Vpid.clear(), newPidCount = 0;
	for (int cid = 0; cid < nCams; cid++)
	{
		sprintf(Fname, "%s/Dynamic/K_%d_%.4d.txt", Path, cid, StartFInst);
		if (IsFileExist(Fname) == 0)
			continue;
		FILE *fp = fopen(Fname, "r");
		while (fscanf(fp, "%d %d %f %f %f %f ", &pid, &cFid[cid], &u, &v, &s, &a) != EOF)
		{
			int spid = -1;
			for (int ii = 0; ii < (int)Vpid.size() && spid == -1; ii++)
				if (Vpid[ii] == pid)
					spid = ii;
			if (spid == -1)
			{
				Vpid.push_back(pid);
				spid = newPidCount;
				newPidCount++;
			}

			minF = min(minF, cFid[cid]);
			maxF = max(maxF, cFid[cid]);
			PViewIdAll3D[spid].push_back(cid);
			uvAll3D[spid].push_back(Point2f(u, v));
		}
		fclose(fp);
	}

	VideoData *VideoInfo = new VideoData[nCams];
	for (int cid = 0; cid < nCams; cid++)
		if (ReadVideoDataI(Path, VideoInfo[cid], cid, minF, maxF) == 1)
			return 1;

	vector<double *> K, distortion;
	for (int cid = 0; cid < nCams; cid++)
	{
		for (int fid = minF; fid <= maxF; fid++)
		{
			if (VideoInfo[cid].VideoInfo[fid].valid && fid == cFid[cid])
			{
				K.push_back(VideoInfo[cid].VideoInfo[fid].K);
				distortion.push_back(VideoInfo[cid].VideoInfo[fid].distortion);
			}
		}
	}
	if ((int)K.size() != nCams)
	{
		printLOG("Not enough intrinsic info found. Abort()\n");
		return 1;
	}

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];

	vector<int> *ValidViewIdAll3D = new vector<int>[npts];
	for (int jj = 0; jj < npts; jj++)
		ValidViewIdAll3D[jj].push_back(nCams);

	for (int jj = 0; jj < npts; jj++)
	{
		int nvis = (int)uvAll3D[jj].size();
		if (nvis < 3)
			continue;

		for (int ii = 0; ii < nvis; ii++)
		{
			int cid = PViewIdAll3D[jj][ii], fid = cFid[cid];
			pts[ii] = uvAll3D[jj][ii];
			LensCorrectionPoint(&pts[ii], K[cid], distortion[cid]);
			if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 0)
				for (int ll = 0; ll < 12; ll++)
					P[12 * ii + ll] = VideoInfo[cid].VideoInfo[fid].P[ll];
			else
				AssembleP_RS(pts[ii], VideoInfo[cid].VideoInfo[fid], P + 12 * ii);
		}

		vector<int>Inliers[1];
		double finalerror = 0.0;
		if (nvis >= 2 * nViewsPlus)
			finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 2, 20, 0.5, TriangThesh, A, B, tP);
		else
		{
			NviewTriangulation(pts, P, &P3d, nvis, 1, NULL, A, B);
			ProjectandDistort(P3d, ppts, P, NULL, NULL, nvis);

			for (int ll = 0; ll < nvis; ll++)
			{
				Inliers[0].push_back(1);
				finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
			}
			finalerror = sqrt(finalerror / nvis);
		}

		if (finalerror > TriangThesh)
			continue;

		int ninliers = 0;
		for (int ii = 0; ii < nvis; ii++)
			if (Inliers[0][ii] == 1)
				ninliers++;

		if (ninliers >= nViewsPlus) //everything statisfy --> stationary
			for (int ii = 0; ii < nvis; ii++)
				if (Inliers[0][ii] == 1)
					ValidViewIdAll3D[jj].push_back(PViewIdAll3D[jj][ii]);
	}


	Vpid.clear(); newPidCount = 0;
	for (int cid = 0; cid < nCams; cid++)
	{
		int validCount = 0, totalCount = 0;
		sprintf(Fname, "%s/Dynamic/K_%d_%.4d.txt", Path, cid, StartFInst);
		if (IsFileExist(Fname) == 0)
			continue;
		FILE *fp = fopen(Fname, "r");
		char Fname2[512]; sprintf(Fname2, "%s/Dynamic/CK_%d_%.4d.txt", Path, cid, StartFInst);
		FILE *fp2 = fopen(Fname2, "w+");
		while (fscanf(fp, "%d %d %f %f %f %f ", &pid, &fid, &u, &v, &s, &a) != EOF)
		{
			int spid = -1;
			for (int ii = 0; ii < (int)Vpid.size() && spid == -1; ii++)
			{
				if (Vpid[ii] == pid)
					spid = ii;
			}
			if (spid == -1)
			{
				Vpid.push_back(pid);
				spid = newPidCount;
				newPidCount++;
			}
			if (spid == 1065)
				int a = 0;
			totalCount++;
			bool found = false;
			for (int jj = 0; jj < (int)ValidViewIdAll3D[spid].size() && !found; jj++)
				if (ValidViewIdAll3D[spid][jj] == cid)
					found = true;
			if (found)
			{
				validCount++;
				fprintf(fp2, "%d %d %.4f %.4f %.3f %.4f\n", pid, fid, u, v, s, a);
			}
		}
		fclose(fp), fclose(fp2);

		MyCopyFile(Fname2, Fname);
		remove(Fname2);

		printLOG("(V %d, F %d): %d/%d good matches\n", cid, StartFInst, validCount, totalCount);
	}

	delete[]ValidViewIdAll3D, delete[]PViewIdAll3D, delete[]uvAll3D;
	delete[]cFid, delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed, delete[]VideoInfo;

	return 0;
}
int ClassifyPointsFromTriangulation(char *Path, vector<int> &SelectedCams, int npts, vector<int> &frameTimeStamp, int startF, int stopF, int refFrame, int nViewsPlus, double TriangThesh, double stationaryThesh) //3cm
{
	//since static points statisfy triangulation no matter what, noise and dynamic points can be classified
	double stationaryThesh2 = stationaryThesh * stationaryThesh;
	int nCams = (int)SelectedCams.size();
	int minStamp = 9e9, maxStamp = -9e9;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (minStamp > frameTimeStamp[ii])
			minStamp = frameTimeStamp[ii];
		if (maxStamp < frameTimeStamp[ii])
			maxStamp = frameTimeStamp[ii];
	}

	char Fname[512];
	int count = 0;
	VideoData *VideoI = new VideoData[nCams];
	for (int cid = 0; cid < nCams; cid++)
		if (ReadVideoDataI(Path, VideoI[cid], SelectedCams[cid], startF - maxStamp, stopF - minStamp) == 1)
			count++;
	if (count > nCams - nViewsPlus)
		return 1;


	int nframes = stopF - startF + 1;
	int *CamID = new int[nframes*npts*nCams];
	int *RealframeID = new int[nframes*npts*nCams];
	Point2f *FrameSyncedPoints = new Point2f[nframes*npts*nCams];
	Point2f *FrameSyncedPointsDistorted = new Point2f[nframes*npts*nCams];
	float *FrameSyncedS = new float[nframes*npts*nCams];
	float *FrameSyncedA = new float[nframes*npts*nCams];
	AffinePara *FrameSyncedAP = new AffinePara[nframes*npts*nCams];
	Pmat *Pmatrix = new Pmat[nframes*npts*nCams];

	for (int ii = 0; ii < nframes*npts*nCams; ii++)
		CamID[ii] = -1, RealframeID[ii] = -1;

	for (int cid = 0; cid < nCams; cid++)
	{
		if (refFrame == -1)
			refFrame = startF;
		sprintf(Fname, "%s/Track2D/C_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printLOG("Cannot load %s\n", Fname);
			continue;
		}
		int previousPid = 0, dummy;
		fscanf(fp, "%d", &dummy);

		int pid, fid, nf;
		VideoI[2].VideoInfo[fid];
		Pmat Pm;
		Point2d uv, uvd; float s, a, w0, w1, w2, w3;
		AffinePara wp;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf %f %f %f %f %f %f ", &fid, &uv.x, &uv.y, &s, &a, &w0, &w1, &w2, &w3);
				if (fid<startF - maxStamp || fid>stopF - minStamp)
					continue;
				if (!VideoI[cid].VideoInfo[fid].valid)
					continue;
				uvd = uv;
				LensCorrectionPoint(&uv, VideoI[cid].VideoInfo[fid].K, VideoI[cid].VideoInfo[fid].distortion);
				wp.warp[0] = w0, wp.warp[1] = w1, wp.warp[2] = w2, wp.warp[3] = w3;

				if (VideoI[cid].VideoInfo[fid].ShutterModel == 0)
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoI[cid].VideoInfo[fid].P[ll];
				else if (VideoI[cid].VideoInfo[fid].ShutterModel == 1)
					AssembleP_RS(uv, VideoI[cid].VideoInfo[fid], Pm.P);
				else
					printLOG("Not supported model for motion prior sync\n");

				int fake_fid = fid + frameTimeStamp[SelectedCams[cid]]; //fake the order, associated with the ref camera (should range from startF to stopF)
				if (fake_fid<0 || fake_fid>stopF)
					continue;

				CamID[cid*nframes*npts + pid * nframes + fake_fid - startF] = cid;
				RealframeID[cid*nframes*npts + pid * nframes + fake_fid - startF] = fid;
				FrameSyncedPoints[cid*nframes*npts + pid * nframes + fake_fid - startF] = uv;
				FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + fake_fid - startF] = uvd;
				FrameSyncedS[cid*nframes*npts + pid * nframes + fake_fid - startF] = s;
				FrameSyncedA[cid*nframes*npts + pid * nframes + fake_fid - startF] = a;
				FrameSyncedAP[cid*nframes*npts + pid * nframes + fake_fid - startF] = wp;
				for (int ll = 0; ll < 12; ll++)
					Pmatrix[cid*nframes*npts + pid * nframes + fake_fid - startF].P[ll] = Pm.P[ll];
			}
		}
		fclose(fp);
	}

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];

	int *NotUsefulPoints = new int[npts];//1: not enough views, 2: tracking is too short, 3: static points, 4: noise (false matches)
	for (int ii = 0; ii < npts; ii++)
		NotUsefulPoints[ii] = 0;

	//Randomize frames of visble cameras and triangulate -> low error for # of trial --> static points
	printLOG("Removing stationary points\n");
	int RandomizedTriangulationTrial = 100;

	double starttime = omp_get_wtime();
	vector<Point3d> vP3d;
	vector<int> validFrames, randFrameAllVisCam;
	for (int pid = 0; pid < npts; pid++)
	{
		vector<int>PvalidCamID;
		for (int cid = 0; cid < nCams; cid++)
		{
			if (CamID[cid*nframes*npts + pid * nframes + refFrame - startF] > -1)
				PvalidCamID.push_back(cid);
		}
		int nvis = (int)PvalidCamID.size();
		if (nvis < nViewsPlus)
		{
			NotUsefulPoints[pid] = 1;
			continue;
		}

		int staticPointVote = 0;
		validFrames.clear(), randFrameAllVisCam.clear(), vP3d.clear();
		for (int trial = 0; trial < RandomizedTriangulationTrial; trial++)
		{
			randFrameAllVisCam.clear();
			int nvalidFramePool = 0;
			for (int ii = 0; ii < nvis; ii++)
			{
				validFrames.clear();
				int cid = PvalidCamID[ii];
				for (int kk = 0; kk < nframes; kk++)
					if (CamID[cid*nframes*npts + pid * nframes + kk] > -1)
						validFrames.push_back(kk);

				nvalidFramePool += (int)validFrames.size();
				randFrameAllVisCam.push_back(validFrames[rand() % (int)validFrames.size()]);
			}
			if (nvalidFramePool < 20 * nvis) //tracking is too short
			{
				NotUsefulPoints[pid] = 2;
				break;
			}

			for (int ii = 0; ii < nvis; ii++)
			{
				int cid = PvalidCamID[ii], fid = randFrameAllVisCam[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
				Point2d uvd = FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + fid];
				pts[ii] = FrameSyncedPoints[cid*nframes*npts + pid * nframes + fid];
				if (VideoI[cid].VideoInfo[realframe].ShutterModel == 0)
					for (int ll = 0; ll < 12; ll++)
						P[12 * ii + ll] = Pmatrix[cid*nframes*npts + pid * nframes + fid].P[ll];
				else
					AssembleP_RS(pts[ii], VideoI[cid].VideoInfo[realframe], P + 12 * ii);
			}

			vector<int>Inliers[1];
			double finalerror = 0.0;
			if (nvis >= 2 * nViewsPlus)
				finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 2, 10, 0.5, TriangThesh, A, B, tP);
			else
			{
				NviewTriangulation(pts, P, &P3d, nvis, 1, NULL, A, B);
				ProjectandDistort(P3d, ppts, P, NULL, NULL, nvis);

				for (int ll = 0; ll < nvis; ll++)
				{
					Inliers[0].push_back(1);
					finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
				}
				finalerror = sqrt(finalerror / nvis);
			}

			if (finalerror > TriangThesh)
				continue;

			int ninliers = 0;
			for (int ii = 0; ii < nvis; ii++)
				if (Inliers[0][ii] == 1)
					ninliers++;

			if (ninliers >= nViewsPlus) //everything statisfy --> stationary
			{
				staticPointVote++;
				vP3d.push_back(P3d);
			}
		}

		if (staticPointVote > 7 * RandomizedTriangulationTrial / 10) //static points
			NotUsefulPoints[pid] = 3;
		else
		{
			if (vP3d.size() > 10) //enough data for statistical method
			{
				Point3d mean3D(0, 0, 0), var3D(0, 0, 0);
				for (int ii = 0; ii < vP3d.size(); ii++)
					mean3D.x += vP3d[ii].x, mean3D.y += vP3d[ii].y, mean3D.z += vP3d[ii].z;
				mean3D.x = mean3D.x / (int)vP3d.size(), mean3D.y = mean3D.y / (int)vP3d.size(), mean3D.z = mean3D.z / (int)vP3d.size();

				for (int ii = 0; ii < vP3d.size(); ii++)
					var3D.x += pow(vP3d[ii].x - mean3D.x, 2), var3D.y += pow(vP3d[ii].y - mean3D.y, 2), var3D.z += pow(vP3d[ii].z - mean3D.z, 2);
				var3D.x = var3D.x / (int)vP3d.size(), var3D.y = var3D.y / (int)vP3d.size(), var3D.z = var3D.z / (int)vP3d.size();

				if (var3D.x < stationaryThesh2 && var3D.y < stationaryThesh2 && var3D.z < stationaryThesh2)
					NotUsefulPoints[pid] = 4;  //noise
			}
			else
				NotUsefulPoints[pid] = 0; //either dyna or noise
		}
	}

	sprintf(Fname, "%s/StaticTrack2D", Path); makeDir(Fname);
	for (int cid = 0; cid < nCams; cid++)
	{
		if (refFrame == -1)
			refFrame = startF;

		sprintf(Fname, "%s/Track2D/CC_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);	FILE *fp1 = fopen(Fname, "w+"); fprintf(fp1, "%d \n", npts);
		sprintf(Fname, "%s/StaticTrack2D/CC_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);	FILE *fp2 = fopen(Fname, "w+"); fprintf(fp2, "%d \n", npts);

		int goodPts = 0, goodPts2 = 0;
		for (int pid = 0; pid < npts; pid++)
		{
			if (NotUsefulPoints[pid] == 0)
			{
				int validFrames = 0;
				for (int ii = 0; ii < nframes; ii++)
					if (CamID[cid*nframes*npts + pid * nframes + ii] != -1)
						validFrames += 1;

				if (validFrames == 0)
					continue;

				goodPts++;
				fprintf(fp1, "%d %d ", pid, validFrames);
				for (int ii = 0; ii < nframes; ii++)
				{
					if (CamID[cid*nframes*npts + pid * nframes + ii] != -1)
					{
						Point2f uv = FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + ii];
						float s = FrameSyncedS[cid*nframes*npts + pid * nframes + ii];
						float a = FrameSyncedA[cid*nframes*npts + pid * nframes + ii];
						AffinePara *wp = &FrameSyncedAP[cid*nframes*npts + pid * nframes + ii];
						fprintf(fp1, "%d %.4f %.4f %.2f %.4f %.8f %.8f %.8f  %.8f ", RealframeID[cid*nframes*npts + pid * nframes + ii], uv.x, uv.y,
							s, a, wp[0].warp[0], wp[0].warp[1], wp[0].warp[2], wp[0].warp[3]);
					}
				}
				fprintf(fp1, "\n");
			}
			else if (NotUsefulPoints[pid] == 3)
			{
				int validFrames = 0;
				for (int ii = 0; ii < nframes; ii++)
					if (CamID[cid*nframes*npts + pid * nframes + ii] != -1)
						validFrames += 1;

				if (validFrames == 0)
					continue;
				goodPts2++;
				fprintf(fp2, "%d %d ", pid, validFrames);
				for (int ii = 0; ii < nframes; ii++)
				{
					if (CamID[cid*nframes*npts + pid * nframes + ii] != -1)
					{
						Point2f uv = FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + ii];
						float s = FrameSyncedS[cid*nframes*npts + pid * nframes + ii];
						float a = FrameSyncedA[cid*nframes*npts + pid * nframes + ii];
						AffinePara *wp = &FrameSyncedAP[cid*nframes*npts + pid * nframes + ii];
						fprintf(fp2, "%d %.4f %.4f %.2f %.4f %.8f %.8f %.8f  %.8f ", RealframeID[cid*nframes*npts + pid * nframes + ii], uv.x, uv.y,
							s, a, wp[0].warp[0], wp[0].warp[1], wp[0].warp[2], wp[0].warp[3]);
					}
				}
				fprintf(fp2, "\n");
			}
		}
		fclose(fp1), fclose(fp2);
		printLOG("Cam (%d, %d): %d dyna, %d static\n", SelectedCams[cid], refFrame, goodPts, goodPts2);
	}

	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	delete[]VideoI, delete[]CamID, delete[]RealframeID, delete[]FrameSyncedPoints, delete[]FrameSyncedPointsDistorted, delete[]FrameSyncedA, delete[]FrameSyncedAP, delete[]Pmatrix;

	return 0;
}

int FmatSyncBruteForce2DStereoAllInstances(char *Path, int *SelectedCams, vector<int> &TrackingInst, int TrajRange, int startF, int stopF, int increImgFrames, int allNpts, int *frameTimeStamp, int LowBound, int UpBound, bool GivenF, vector<ImgPtEle> *PerCam_UV, bool silent)
{
	//The goad is to accumulate all info from all instances for sync. 
	char Fname[512]; FILE *fp = 0;
	const int nCams = 2;
	int minStamp = min(frameTimeStamp[0], frameTimeStamp[1]), maxStamp = max(frameTimeStamp[0], frameTimeStamp[1]);

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;

	ImgPtEle ptEle;
	bool createdMem = false;
	if (PerCam_UV == NULL)
	{
		createdMem = true;
		PerCam_UV = new vector<ImgPtEle>[nCams*allNpts];
		for (int camID = 0; camID < nCams; camID++)
			for (int pid = 0; pid < allNpts; pid++)
				PerCam_UV[camID*allNpts + pid].reserve(TrajRange + 1);
	}
	else
	{
		for (int camID = 0; camID < nCams; camID++)
			for (int trackID = 0; trackID < allNpts; trackID++)
				PerCam_UV[camID*allNpts + trackID].clear();
	}

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		int  FirstValidFrame;
		if (!GivenF)
		{
			for (int fid = startF; fid < stopF; fid++)
			{
				if (VideoInfo[camID].VideoInfo[fid].valid)
				{
					FirstValidFrame = fid;
					break;
				}
			}
		}

		int nptsSeed, nptsCum = 0, nseeds = (int)TrackingInst.size();
		for (int seedID = 0; seedID < nseeds; seedID++)
		{
			sprintf(Fname, "%s/Track2D/RCC_%d_%.4d.txt", Path, SelectedCams[camID], TrackingInst[seedID]);
			if (IsFileExist(Fname) == 0)
			{
				printLOG("Cannot load %s\n", Fname);
				abort();
			}
			int pid, fid, nf;
			float u, v, s;
			FILE *fp = fopen(Fname, "r");
			fscanf(fp, "%d ", &nptsSeed);
			while (fscanf(fp, "%d %d", &pid, &nf) != EOF)
			{
				for (int ii = 0; ii < nf; ii++)
				{
					fscanf(fp, "%d %f %f %f ", &fid, &u, &v, &s);
					if (GivenF && !VideoInfo[camID].VideoInfo[fid].valid)
						continue; //camera not localized

					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.scale = s, ptEle.frameID = fid;
					if (GivenF)
						LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[fid].K, VideoInfo[camID].VideoInfo[fid].distortion);
					PerCam_UV[camID*allNpts + pid + nptsCum].push_back(ptEle);
				}
			}
			fclose(fp);

			nptsCum += nptsSeed; //nptsCum == allNpts in the end
		}
	}

	//Start sliding
	int count = 0, BestOffset = 9e9;
	double minError = 9e9;
	int *aOffset = new int[UpBound - LowBound + 1];
	double *aError = new double[UpBound - LowBound + 1];

	for (int off = LowBound * increImgFrames; off <= UpBound * increImgFrames; off += increImgFrames)
	{
		double Fmat[9], error, cumError = 0.0, usedPointsCount = 0;
		if (GivenF)
		{
			for (int pid = 0; pid < allNpts; pid++)
			{
				for (int fid1 = 0; fid1 < PerCam_UV[pid].size(); fid1++)
				{
					error = 0.0;
					int ref1 = PerCam_UV[pid][fid1].frameID; //the point has been tracked at the offset frame already
					for (int fid2 = 0; fid2 < PerCam_UV[allNpts + pid].size(); fid2++)
					{
						int ref2 = PerCam_UV[allNpts + pid][fid2].frameID; //the point has been tracked at the offset frame already
						if (ref1 + frameTimeStamp[0] == ref2 + frameTimeStamp[1] + off) //see if the corresponding frame in the other camera has point. Use addition to fake the refframe: 
						{
							if (VideoInfo[0].VideoInfo[ref1].valid == 0 || VideoInfo[1].VideoInfo[ref2].valid == 0)
								continue;

							double K1[9], K2[9], R1[9], T1[3], R2[9], T2[3];
							for (int kk = 0; kk < 9; kk++)
								K1[kk] = VideoInfo[0].VideoInfo[ref1].K[kk], K2[kk] = VideoInfo[1].VideoInfo[ref2].K[kk];
							if (VideoInfo[0].VideoInfo[ref1].ShutterModel == 0)
							{
								for (int kk = 0; kk < 9; kk++)
									R1[kk] = VideoInfo[0].VideoInfo[ref1].R[kk];
								for (int kk = 0; kk < 3; kk++)
									T1[kk] = VideoInfo[0].VideoInfo[ref1].T[kk];
							}
							else
								AssembleRT_RS(PerCam_UV[pid][fid1].pt2D, VideoInfo[0].VideoInfo[ref1], R1, T1);

							if (VideoInfo[1].VideoInfo[ref2].ShutterModel == 0)
							{
								for (int kk = 0; kk < 9; kk++)
									R2[kk] = VideoInfo[1].VideoInfo[ref2].R[kk];
								for (int kk = 0; kk < 3; kk++)
									T2[kk] = VideoInfo[1].VideoInfo[ref2].T[kk];
							}
							else
								AssembleRT_RS(PerCam_UV[allNpts + pid][fid2].pt2D, VideoInfo[1].VideoInfo[ref2], R2, T2);

							computeFmat(K1, K2, R1, T1, R2, T2, Fmat);

							error = FmatPointError(Fmat, PerCam_UV[pid][fid1].pt2D, PerCam_UV[allNpts + pid][fid2].pt2D);
							usedPointsCount++;
							break;
						}
					}
					cumError += error;
				}
			}
		}
		else
		{
			//Compute Fmat
			vector<Point2d> points1, points2;
			for (int fid1 = 0; fid1 < (int)PerCam_UV[0].size(); fid1++)
			{
				int ref1 = PerCam_UV[0][fid1].frameID; //the point has been tracked at the offset frame already
				for (int fid2 = 0; fid2 < (int)PerCam_UV[allNpts].size(); fid2++)
				{
					int ref2 = PerCam_UV[allNpts][fid2].frameID; //the point has been tracked at the offset frame already
					if (ref1 == ref2 + off)
					{
						for (int ii = 0; ii < allNpts; ii++)
						{
							points1.push_back(PerCam_UV[ii][fid1].pt2D);
							points2.push_back(PerCam_UV[ii + allNpts][fid2].pt2D);
						}
						break;
					}
				}
			}

			if (points1.size() < 8)
			{
				cumError = 9e9;
				usedPointsCount = 0;
			}
			else
			{
				Mat cvFmat = findFundamentalMat(points1, points2, CV_FM_8POINT, 3, 0.99);

				double Fmat[9];
				for (int ii = 0; ii < 9; ii++)
					Fmat[ii] = cvFmat.at<double>(ii);

				for (int ii = 0; ii < (int)points1.size(); ii++)
					cumError += FmatPointError(Fmat, points1[ii], points2[ii]);
				usedPointsCount = points1.size();
			}
		}
		if (usedPointsCount == 0)
			cumError = 9e9;
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		aError[count] = cumError;
		aOffset[count] = off;
		if (!silent)
			printLOG("@off %d (id: %d): %.5e -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	Quick_Sort_Double(aError, aOffset, 0, count - 1);
	printLOG("Pair (%d, %d): %d: %.3e  ... %d: %.3e \n", SelectedCams[0], SelectedCams[1], aOffset[0], aError[0], aOffset[1], aError[1]);

	frameTimeStamp[1] = frameTimeStamp[1] - BestOffset;

	if (createdMem)
		delete[]PerCam_UV;
	delete[]aOffset, delete[]aError;

	return 0;
}
int FmatSyncRobustBruteForce2DStereoAllInstances(char *Path, int *SelectedCams, vector<int> &TrackingInst, int TrajRange, int startF, int stopF, int increImgFrames, int allNpts, int *frameTimeStamp, int LowBound, int UpBound, vector<ImgPtEle> *PerCam_UV, bool silent)
{
	//The goad is to accumulate all info from all instances for sync. This function only looks at points where there is a valley in the cost(offset) to sync and filter points
	char Fname[512]; FILE *fp = 0;
	const int nCams = 2;
	int minStamp = min(frameTimeStamp[0], frameTimeStamp[1]), maxStamp = max(frameTimeStamp[0], frameTimeStamp[1]);

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;

	ImgPtEle ptEle;
	bool createdMem = false;
	if (PerCam_UV == NULL)
	{
		createdMem = true;
		PerCam_UV = new vector<ImgPtEle>[nCams*allNpts];
		for (int camID = 0; camID < nCams; camID++)
			for (int pid = 0; pid < allNpts; pid++)
				PerCam_UV[camID*allNpts + pid].reserve(TrajRange + 1);
	}
	else
	{
		for (int camID = 0; camID < nCams; camID++)
			for (int trackID = 0; trackID < allNpts; trackID++)
				PerCam_UV[camID*allNpts + trackID].clear();
	}

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		float u, v, s;
		int pid, fid, nf, nptsSeed, nptsCum = 0, nseeds = (int)TrackingInst.size();
		for (int seedID = 0; seedID < nseeds; seedID++)
		{
			sprintf(Fname, "%s/Track2D/RCC_%d_%.4d.txt", Path, SelectedCams[camID], TrackingInst[seedID]);
			if (IsFileExist(Fname) == 0)
			{
				printLOG("Cannot load %s\n", Fname);
				abort();
			}
			FILE *fp = fopen(Fname, "r");
			fscanf(fp, "%d ", &nptsSeed);
			while (fscanf(fp, "%d %d", &pid, &nf) != EOF)
			{
				for (int ii = 0; ii < nf; ii++)
				{
					fscanf(fp, "%d %f %f %f ", &fid, &u, &v, &s);
					if (!VideoInfo[camID].VideoInfo[fid].valid)
						continue; //camera not localized

					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.scale = s, ptEle.frameID = fid;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[fid].K, VideoInfo[camID].VideoInfo[fid].distortion);
					PerCam_UV[camID*allNpts + pid + nptsCum].push_back(ptEle);
				}
			}
			fclose(fp);

			nptsCum += nptsSeed; //nptsCum == allNpts in the end
		}
	}

	//Start sliding
	int *aOffset = new int[UpBound - LowBound + 1], *badPoints = new int[allNpts];
	double *aError = new double[UpBound - LowBound + 1], *saError = new double[UpBound - LowBound + 1];
	for (int pid = 0; pid < allNpts; pid++)
	{
		int count = 0;
		double maxError = 0, minError = 9e9;
		for (int off = LowBound * increImgFrames; off <= UpBound * increImgFrames; off += increImgFrames)
		{
			double Fmat[9], cumError = 0.0, usedPointsCount = 0;
			for (int fid1 = 0; fid1 < PerCam_UV[pid].size(); fid1++)
			{
				double error = 0.0;
				int ref1 = PerCam_UV[pid][fid1].frameID; //the point has been tracked at the offset frame already
				for (int fid2 = 0; fid2 < PerCam_UV[allNpts + pid].size(); fid2++)
				{
					int ref2 = PerCam_UV[allNpts + pid][fid2].frameID; //the point has been tracked at the offset frame already
					if (ref1 + frameTimeStamp[0] == ref2 + frameTimeStamp[1] + off) //see if the corresponding frame in the other camera has point. Use addition to fake the refframe: 
					{
						if (VideoInfo[0].VideoInfo[ref1].valid == 0 || VideoInfo[1].VideoInfo[ref2].valid == 0)
							continue;

						double K1[9], K2[9], R1[9], T1[3], R2[9], T2[3];
						for (int kk = 0; kk < 9; kk++)
							K1[kk] = VideoInfo[0].VideoInfo[ref1].K[kk], K2[kk] = VideoInfo[1].VideoInfo[ref2].K[kk];
						if (VideoInfo[0].VideoInfo[ref1].ShutterModel == 0)
						{
							for (int kk = 0; kk < 9; kk++)
								R1[kk] = VideoInfo[0].VideoInfo[ref1].R[kk];
							for (int kk = 0; kk < 3; kk++)
								T1[kk] = VideoInfo[0].VideoInfo[ref1].T[kk];
						}
						else
							AssembleRT_RS(PerCam_UV[pid][fid1].pt2D, VideoInfo[0].VideoInfo[ref1], R1, T1);

						if (VideoInfo[1].VideoInfo[ref2].ShutterModel == 0)
						{
							for (int kk = 0; kk < 9; kk++)
								R2[kk] = VideoInfo[1].VideoInfo[ref2].R[kk];
							for (int kk = 0; kk < 3; kk++)
								T2[kk] = VideoInfo[1].VideoInfo[ref2].T[kk];
						}
						else
							AssembleRT_RS(PerCam_UV[allNpts + pid][fid2].pt2D, VideoInfo[1].VideoInfo[ref2], R2, T2);

						computeFmat(K1, K2, R1, T1, R2, T2, Fmat);

						error = FmatPointError(Fmat, PerCam_UV[pid][fid1].pt2D, PerCam_UV[allNpts + pid][fid2].pt2D);
						usedPointsCount++;
						break;
					}
				}
				cumError += error;
			}

			if (usedPointsCount > 0)
			{
				maxError = max(maxError, cumError);
				minError = min(minError, cumError);
			}
			aError[count] = cumError / (0.0000001 + usedPointsCount);
			count++;
		}

		if (minError / maxError > 0.25 || minError == 0) //there is a valley in the cost function -->almost always corredponding trajectory
			badPoints[pid] = 1;
		else
		{
			badPoints[pid] = 0;
			if (!silent)
				printLOG("%d ...", pid);
		}
	}

	sprintf(Fname, "%s/GoodPoints.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < allNpts; ii++)
	{
		if (badPoints[ii] == 0)
		{
			Point2d uv1 = PerCam_UV[0 * allNpts + ii][0].pt2D;
			int realfid1 = PerCam_UV[0 * allNpts + ii][0].frameID;
			LensDistortionPoint(&uv1, VideoInfo[0].VideoInfo[realfid1].K, VideoInfo[0].VideoInfo[realfid1].distortion);

			Point2d uv2 = PerCam_UV[1 * allNpts + ii][0].pt2D;
			int realfid2 = PerCam_UV[1 * allNpts + ii][0].frameID;
			LensDistortionPoint(&uv2, VideoInfo[1].VideoInfo[realfid2].K, VideoInfo[1].VideoInfo[realfid2].distortion);
			fprintf(fp, "%d %d %d %.2f %.2f %d %d %.2f %.2f\n", ii, SelectedCams[0], realfid1, uv1.x, uv1.y, SelectedCams[1], realfid2, uv2.x, uv2.y);
		}
	}
	fclose(fp);

	int count = 0, BestOffset = 9e9;
	double minError = 9e9;
	for (int off = LowBound * increImgFrames; off <= UpBound * increImgFrames; off += increImgFrames)
	{
		double Fmat[9], cumError = 0.0, usedPointsCount = 0;
		for (int pid = 0; pid < allNpts; pid++)
		{
			if (badPoints[pid] == 1)
				continue;
			for (int fid1 = 0; fid1 < PerCam_UV[pid].size(); fid1++)
			{
				double error = 0.0;
				int ref1 = PerCam_UV[pid][fid1].frameID; //the point has been tracked at the offset frame already
				for (int fid2 = 0; fid2 < PerCam_UV[allNpts + pid].size(); fid2++)
				{
					int ref2 = PerCam_UV[allNpts + pid][fid2].frameID; //the point has been tracked at the offset frame already
					if (ref1 + frameTimeStamp[0] == ref2 + frameTimeStamp[1] + off) //see if the corresponding frame in the other camera has point. Use addition to fake the refframe: 
					{
						if (VideoInfo[0].VideoInfo[ref1].valid == 0 || VideoInfo[1].VideoInfo[ref2].valid == 0)
							continue;

						double K1[9], K2[9], R1[9], T1[3], R2[9], T2[3];
						for (int kk = 0; kk < 9; kk++)
							K1[kk] = VideoInfo[0].VideoInfo[ref1].K[kk], K2[kk] = VideoInfo[1].VideoInfo[ref2].K[kk];
						if (VideoInfo[0].VideoInfo[ref1].ShutterModel == 0)
						{
							for (int kk = 0; kk < 9; kk++)
								R1[kk] = VideoInfo[0].VideoInfo[ref1].R[kk];
							for (int kk = 0; kk < 3; kk++)
								T1[kk] = VideoInfo[0].VideoInfo[ref1].T[kk];
						}
						else
							AssembleRT_RS(PerCam_UV[pid][fid1].pt2D, VideoInfo[0].VideoInfo[ref1], R1, T1);

						if (VideoInfo[1].VideoInfo[ref2].ShutterModel == 0)
						{
							for (int kk = 0; kk < 9; kk++)
								R2[kk] = VideoInfo[1].VideoInfo[ref2].R[kk];
							for (int kk = 0; kk < 3; kk++)
								T2[kk] = VideoInfo[1].VideoInfo[ref2].T[kk];
						}
						else
							AssembleRT_RS(PerCam_UV[allNpts + pid][fid2].pt2D, VideoInfo[1].VideoInfo[ref2], R2, T2);

						computeFmat(K1, K2, R1, T1, R2, T2, Fmat);
						error = FmatPointError(Fmat, PerCam_UV[pid][fid1].pt2D, PerCam_UV[allNpts + pid][fid2].pt2D);
						usedPointsCount++;
						break;
					}
				}
				cumError += error;
			}
		}

		if (usedPointsCount == 0)
			cumError = 9e9;
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		aError[count] = cumError;
		aOffset[count] = off;
		if (!silent)
			printLOG("@off %d (id: %d): %.5e -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	Quick_Sort_Double(aError, aOffset, 0, count - 1);
	printLOG("Pair (%d, %d): %d: %.3e  ... %d: %.3e \n", SelectedCams[0], SelectedCams[1], aOffset[0], aError[0], aOffset[1], aError[1]);

	frameTimeStamp[1] = frameTimeStamp[1] + BestOffset;

	for (int cid = 0; cid < nCams; cid++)
	{
		sprintf(Fname, "%s/Track2D/UltimateID_%.4d.txt", Path, SelectedCams[cid]);	FILE *fp = fopen(Fname, "w+");
		for (int pid = 0; pid < allNpts; pid++)
		{
			if (badPoints[pid] != 0)
				continue;
			fprintf(fp, "%d %d ", pid, (int)PerCam_UV[cid*allNpts + pid].size());
			for (int ii = 0; ii < (int)PerCam_UV[cid*allNpts + pid].size(); ii++)
			{
				Point2d uv = PerCam_UV[cid*allNpts + pid][ii].pt2D;
				int realfid = PerCam_UV[cid*allNpts + pid][ii].frameID;
				LensDistortionPoint(&uv, VideoInfo[cid].VideoInfo[realfid].K, VideoInfo[cid].VideoInfo[realfid].distortion);
				fprintf(fp, "%d %.4f %.4f %.2f ", realfid, uv.x, uv.y, PerCam_UV[cid*allNpts + pid][ii].scale);
			}
			fprintf(fp, "\n");
		}
		fclose(fp);
	}

	if (createdMem)
		delete[]PerCam_UV;
	delete[]aOffset, delete[]aError, delete[]saError, delete[]badPoints;

	return 0;
}
int TriangulateFrameSync2DTrajectories_Block(char *Path, vector<int> &SelectedCams, vector<int> &frameTimeStamp, int refFrame, int startF, int stopF, int nViewsPlus, double TriangThesh, double stationaryThesh, int CleanCorrespondencesByTriangulationTest, double *GTFrameTimeStamp, double *ialpha, double*Tscale)
{
	double stationaryThesh2 = stationaryThesh * stationaryThesh;
	int nCams = (int)SelectedCams.size();
	int minStamp = 9e9, maxStamp = -9e9;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (minStamp > frameTimeStamp[ii])
			minStamp = frameTimeStamp[ii];
		if (maxStamp < frameTimeStamp[ii])
			maxStamp = frameTimeStamp[ii];
	}

	bool createdMem = false;
	if (GTFrameTimeStamp == NULL)
	{
		createdMem = true;
		GTFrameTimeStamp = new double[nCams];
		ialpha = new double[1], Tscale = new double[1];
		ialpha[0] = 1.0, Tscale[0] = 1.0;
		for (int ii = 0; ii < nCams; ii++)
			GTFrameTimeStamp[ii] = 0.0;
	}

	char Fname[512];
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startF, stopF) == 1)
			return 1;

	int npts, nframes = stopF - startF + 1;
	int *CamID = 0, *RealframeID = 0;
	Point2f *FrameSyncedPoints = 0, *FrameSyncedPointsDistorted = 0;
	float *FrameSyncedS = 0;
	Pmat *Pmatrix = 0;

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];

	if (refFrame > -1)
		sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[0], refFrame);
	else
		sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[0]);
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printLOG("Cannot load %s\n", Fname);
		return 1;
	}
	int previousPid = 0;
	fscanf(fp, "%d", &npts);
	fclose(fp);

	int nbatches = 60, nptsBlock = npts / nbatches + 1;

	vector<Point3d> vP3d;
	vector<int>PvalidCamID, vcid_P3d, vfid_P3d;
	vector<int> *valid_cid_P3d = new vector<int>[nptsBlock], *valid_fid_P3d = new vector<int>[nptsBlock];
	vector<Point3d> *validP3d = new vector<Point3d>[nptsBlock];
	vector<int> *CleanFrameSynID = new vector<int>[nCams*nptsBlock];
	vector<Point2d> *CleanedFrameSyncedPoints = new vector<Point2d>[nCams*nptsBlock];

	for (int batchId = 0; batchId <= nbatches; batchId++)
	{
		int pidLow = nptsBlock * batchId, pidHigh = nptsBlock * (batchId + 1);
		for (int cid = 0; cid < nCams; cid++)
		{
			if (refFrame > -1)
				sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
			else
				sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
			FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printLOG("Cannot load %s\n", Fname);
				continue;
			}
			int previousPid = 0;
			fscanf(fp, "%d", &npts);
			if (CamID == NULL)
			{
				CamID = new int[nframes*nptsBlock*nCams];
				RealframeID = new int[nframes*nptsBlock*nCams];
				FrameSyncedPoints = new Point2f[nframes*nptsBlock*nCams];
				FrameSyncedPointsDistorted = new Point2f[nframes*nptsBlock*nCams];
				FrameSyncedS = new float[nframes*nptsBlock*nCams];
				Pmatrix = new Pmat[nframes*nptsBlock*nCams];
				for (int ii = 0; ii < nframes*nptsBlock*nCams; ii++)
					CamID[ii] = -1, RealframeID[ii] = -1;
			}

			int pid, fid, nf;
			Pmat Pm;
			Point2d uv, uvd; double s = 1.0;
			while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
			{
				for (int kk = 0; kk < nf; kk++)
				{
					fscanf(fp, "%d %lf %lf %lf ", &fid, &uv.x, &uv.y, &s);
					if (fid<startF - maxStamp || fid>stopF - minStamp || !VideoInfo[cid].VideoInfo[fid].valid)
						continue;

					if (pid<pidLow || pid>pidHigh)
						continue;

					uvd = uv;
					LensCorrectionPoint(&uv, VideoInfo[cid].VideoInfo[fid].K, VideoInfo[cid].VideoInfo[fid].distortion);

					if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 0)
					{
						for (int ll = 0; ll < 12; ll++)
							Pm.P[ll] = VideoInfo[cid].VideoInfo[fid].P[ll];
					}
					else if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 1)
						AssembleP_RS(uv, VideoInfo[cid].VideoInfo[fid], Pm.P);
					else
						printLOG("Not supported model for motion prior sync\n");

					int fake_fid = fid + frameTimeStamp[cid]; //fake the order, associated with the ref camera (should range from startF to stopF)
					if (fake_fid<0 || fake_fid>stopF)
						continue;

					CamID[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF] = cid;
					RealframeID[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF] = fid;
					FrameSyncedPoints[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF] = uv;
					FrameSyncedPointsDistorted[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF] = uvd;
					FrameSyncedS[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF] = s;
					for (int ll = 0; ll < 12; ll++)
						Pmatrix[cid*nframes*nptsBlock + pid * nframes + fake_fid - startF].P[ll] = Pm.P[ll];
				}
			}
			fclose(fp);
		}

		for (int pid = 0; pid < nptsBlock; pid++)
		{
			vP3d.clear(), vcid_P3d.clear(), vfid_P3d.clear();
			for (int fid = 0; fid < nframes; fid++)
			{
				PvalidCamID.clear();
				for (int cid = 0; cid < nCams; cid++)
				{
					if (CamID[cid*nframes*nptsBlock + pid * nframes + fid] > -1)
						PvalidCamID.push_back(cid);
				}
				int nvis = (int)PvalidCamID.size();
				if (nvis < nViewsPlus)
					continue;

				for (int ii = 0; ii < nvis; ii++)
				{
					int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*nptsBlock + pid * nframes + fid];
					pts[ii] = FrameSyncedPoints[cid*nframes*nptsBlock + pid * nframes + fid];
					for (int ll = 0; ll < 12; ll++)
						P[12 * ii + ll] = Pmatrix[cid*nframes*nptsBlock + pid * nframes + fid].P[ll];
				}

				vector<int>Inliers[1];
				double finalerror = 0.0;
				if (nvis >= 2 * nViewsPlus)
					finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 2, 20, 1.0 * 2 / nvis, TriangThesh, A, B, tP);
				else
				{
					NviewTriangulation(pts, P, &P3d, nvis, 1, NULL, A, B);
					ProjectandDistort(P3d, ppts, P, NULL, NULL, nvis);

					for (int ll = 0; ll < nvis; ll++)
					{
						Inliers[0].push_back(1);
						finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
					}
					finalerror = sqrt(finalerror / nvis);
				}

				if (finalerror > TriangThesh)
					continue;

				int ninliers = 0;
				for (int ii = 0; ii < nvis; ii++)
					if (Inliers[0][ii] == 1)
						ninliers++;

				vP3d.push_back(P3d);
				vcid_P3d.push_back(PvalidCamID[0]), vfid_P3d.push_back(RealframeID[PvalidCamID[0] * nframes*nptsBlock + pid * nframes + fid]);

				for (int ii = 0; ii < nvis; ii++)
				{
					int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*nptsBlock + pid * nframes + fid];
					pts[ii] = FrameSyncedPoints[cid*nframes*nptsBlock + pid * nframes + fid];
					CleanFrameSynID[cid*nptsBlock + pid].push_back(realframe);
					CleanedFrameSyncedPoints[cid*nptsBlock + pid].push_back(pts[ii]);
				}
			}

			if (vP3d.size() > 10) //enough data for statistical method
			{
				Point3d mean3D(0, 0, 0), var3D(0, 0, 0);
				for (int ii = 0; ii < (int)vP3d.size(); ii++)
					mean3D.x += vP3d[ii].x, mean3D.y += vP3d[ii].y, mean3D.z += vP3d[ii].z;
				mean3D.x = mean3D.x / (int)vP3d.size(), mean3D.y = mean3D.y / (int)vP3d.size(), mean3D.z = mean3D.z / (int)vP3d.size();

				for (int ii = 0; ii < vP3d.size(); ii++)
					var3D.x += pow(vP3d[ii].x - mean3D.x, 2), var3D.y += pow(vP3d[ii].y - mean3D.y, 2), var3D.z += pow(vP3d[ii].z - mean3D.z, 2);
				var3D.x = var3D.x / (int)vP3d.size(), var3D.y = var3D.y / (int)vP3d.size(), var3D.z = var3D.z / (int)vP3d.size();

				if (var3D.x < stationaryThesh2 && var3D.y < stationaryThesh2 && var3D.z < stationaryThesh2)
					continue;
				else
				{
					valid_cid_P3d[pid].reserve(vP3d.size()), valid_fid_P3d[pid].reserve(vP3d.size()), validP3d[pid].reserve(vP3d.size());
					for (int ii = 0; ii < (int)vP3d.size(); ii++)
						valid_cid_P3d[pid].push_back(vcid_P3d[ii]), valid_fid_P3d[pid].push_back(vfid_P3d[ii]), validP3d[pid].push_back(vP3d[ii]);
				}
			}
		}

		sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
		for (int pid = 0; pid < nptsBlock; pid++)
		{
			if ((int)validP3d[pid].size() == 0)
				continue;

			if (refFrame > -1)
				sprintf(Fname, "%s/Track3D/frameSynced_Track_%d_%.4d.txt", Path, pid, refFrame);
			else
				sprintf(Fname, "%s/frameSynced_Track_%.4d.txt", Path, pid);
			FILE *fp = fopen(Fname, "a+");
			for (int ii = 0; ii < (int)validP3d[pid].size(); ii++)
			{
				int cid = valid_cid_P3d[pid][ii], fid = valid_fid_P3d[pid][ii];
				fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", validP3d[pid][ii].x, validP3d[pid][ii].y, validP3d[pid][ii].z, (GTFrameTimeStamp[cid] + fid)*ialpha[0] * Tscale[0], SelectedCams[cid], fid);
			}
			fclose(fp);
		}


	}

	/*if (CleanCorrespondencesByTriangulationTest == 1)
	{
	for (int cid = 0; cid < nCams; cid++)
	{
	if (refFrame >-1)
	sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
	else
	sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
	FILE *fp = fopen(Fname, "w+");
	for (int pid = 0; pid < npts; pid++)
	{
	if (CleanedFrameSyncedPoints[cid*nptsBlock + pid].size() < 20)
	continue;
	fprintf(fp, "%d %d ", pid, CleanedFrameSyncedPoints[cid*npts + pid].size());
	for (int fid = 0; fid < CleanedFrameSyncedPoints[cid*npts + pid].size(); fid++)
	{
	int realfid = CleanFrameSynID[cid*npts + pid][fid];
	int fake_fid = realfid + frameTimeStamp[cid]; //fake the order, associated with the ref camera (should range from startF to stopF)
	double s = FrameSyncedS[cid*nframes*npts + pid*nframes + fake_fid - startF];
	Point2d uv = CleanedFrameSyncedPoints[cid*npts + pid][fid];
	LensDistortionPoint(&uv, VideoInfo[cid].VideoInfo[realfid].K, VideoInfo[cid].VideoInfo[realfid].distortion);
	fprintf(fp, "%d %.4f %.4f %.2f ", realfid, uv.x, uv.y, s);
	}
	fprintf(fp, "\n");
	}
	fclose(fp);
	}
	}*/

	if (createdMem)
		delete[]GTFrameTimeStamp;
	delete[]VideoInfo;
	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	delete[]CamID, delete[]RealframeID, delete[]FrameSyncedPoints, delete[]FrameSyncedPointsDistorted, delete[]FrameSyncedS, delete[]Pmatrix;
	delete[]valid_cid_P3d, delete[]valid_fid_P3d, delete[]validP3d, delete[]CleanFrameSynID, delete[]CleanedFrameSyncedPoints;

	return 0;
}
int TriangulateFrameSync2DTrajectories(char *Path, vector<int> &SelectedCams, vector<int> &frameTimeStamp, int refFrame, int startF, int stopF, int nViewsPlus, double TriangThesh, double stationaryThesh, double MinDistToCamThresh, int Discon3DThresh, int CleanCorrespondencesByTriangulationTest, double *GTFrameTimeStamp, double *ialpha, double*Tscale)
{
	double stationaryThesh2 = stationaryThesh * stationaryThesh;
	int nCams = (int)SelectedCams.size();
	int minStamp = 9e9, maxStamp = -9e9;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (minStamp > frameTimeStamp[ii])
			minStamp = frameTimeStamp[ii];
		if (maxStamp < frameTimeStamp[ii])
			maxStamp = frameTimeStamp[ii];
	}

	bool createdMem = false;
	if (GTFrameTimeStamp == NULL)
	{
		createdMem = true;
		GTFrameTimeStamp = new double[nCams];
		ialpha = new double[1], Tscale = new double[1];
		ialpha[0] = 1.0, Tscale[0] = 1.0;
		for (int ii = 0; ii < nCams; ii++)
			GTFrameTimeStamp[ii] = frameTimeStamp[ii];
	}

	char Fname[512];
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startF, stopF) == 1)
			return 1;

	int npts, nframes = stopF - startF + 1;
	int *CamID = 0, *RealframeID = 0;
	Point2f *FrameSyncedPoints = 0, *FrameSyncedPointsDistorted = 0;
	float *FrameSyncedS = 0;
	Pmat *Pmatrix = 0;


	for (int cid = 0; cid < nCams; cid++)
	{
		if (refFrame > -1)
			sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
		else
			sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
		FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printLOG("Cannot load %s\n", Fname);
			continue;
		}
		int previousPid = 0;
		fscanf(fp, "%d", &npts);
		if (CamID == NULL)
		{
			CamID = new int[nframes*npts*nCams];
			RealframeID = new int[nframes*npts*nCams];
			FrameSyncedPoints = new Point2f[nframes*npts*nCams];
			FrameSyncedPointsDistorted = new Point2f[nframes*npts*nCams];
			FrameSyncedS = new float[nframes*npts*nCams];
			Pmatrix = new Pmat[nframes*npts*nCams];
			for (int ii = 0; ii < nframes*npts*nCams; ii++)
				CamID[ii] = -1, RealframeID[ii] = -1;
		}

		int pid, fid, nf;
		Pmat Pm;
		Point2d uv, uvd; double s = 1.0;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			bool tooshort = false;
			if (nf < 20)
				tooshort = true;
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf %lf ", &fid, &uv.x, &uv.y, &s);
				if (fid<startF - maxStamp || fid>stopF - minStamp || !VideoInfo[cid].VideoInfo[fid].valid)
					continue;
				if (tooshort)
					continue;

				uvd = uv;
				LensCorrectionPoint(&uv, VideoInfo[cid].VideoInfo[fid].K, VideoInfo[cid].VideoInfo[fid].distortion);

				if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 0)
				{
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoInfo[cid].VideoInfo[fid].P[ll];
				}
				else if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 1)
					AssembleP_RS(uv, VideoInfo[cid].VideoInfo[fid], Pm.P);
				else
					printLOG("Not supported model for motion prior sync\n");

				int fake_fid = fid + frameTimeStamp[cid]; //fake the order, associated with the ref camera (should range from startF to stopF)
				if (fake_fid<startF || fake_fid>stopF)
					continue;

				CamID[cid*nframes*npts + pid * nframes + fake_fid - startF] = cid;
				RealframeID[cid*nframes*npts + pid * nframes + fake_fid - startF] = fid;
				FrameSyncedPoints[cid*nframes*npts + pid * nframes + fake_fid - startF] = uv;
				FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + fake_fid - startF] = uvd;
				FrameSyncedS[cid*nframes*npts + pid * nframes + fake_fid - startF] = s;
				for (int ll = 0; ll < 12; ll++)
					Pmatrix[cid*nframes*npts + pid * nframes + fake_fid - startF].P[ll] = Pm.P[ll];
			}
		}
		fclose(fp);
	}

	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];

	MultiViewPtEle mvP3d;
	vector<MultiViewPtEle> vmvP3d;
	vector<int>PvalidCamID;
	vector<int> *CleanFrameSynID = new vector<int>[nCams*npts];
	vector<Point2d> *CleanedFrameSyncedPoints = new vector<Point2d>[nCams*npts];
	int *SortedTime = new int[nframes], *dummy = new int[nframes];

	sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
	for (int pid = 0; pid < npts; pid++)
	{
		vmvP3d.clear();
		for (int fid = 0; fid < nframes; fid++)
		{
			PvalidCamID.clear(), mvP3d.viewID.clear(), mvP3d.frameID.clear(), mvP3d.pt2D.clear();
			for (int cid = 0; cid < nCams; cid++)
			{
				if (CamID[cid*nframes*npts + pid * nframes + fid] > -1)
					PvalidCamID.push_back(cid);
			}
			int nvis = (int)PvalidCamID.size();
			if (nvis < nViewsPlus)
				continue;
			for (int ii = 0; ii < nvis; ii++)
			{
				int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
				pts[ii] = FrameSyncedPoints[cid*nframes*npts + pid * nframes + fid];
				Point2d uvd = FrameSyncedPointsDistorted[cid*nframes*npts + pid * nframes + fid];
				for (int ll = 0; ll < 12; ll++)
					P[12 * ii + ll] = Pmatrix[cid*nframes*npts + pid * nframes + fid].P[ll];
			}

			vector<int>Inliers[1];
			double finalerror = 0.0;
			if (nvis >= 2 * nViewsPlus)
				finalerror = NviewTriangulationRANSAC(pts, P, &mvP3d.pt3D, passed, Inliers, nvis, 1, 2, 20, 1.0 * 2 / nvis, TriangThesh, A, B, tP);
			else
			{
				NviewTriangulation(pts, P, &mvP3d.pt3D, nvis, 1, NULL, A, B);
				ProjectandDistort(mvP3d.pt3D, ppts, P, NULL, NULL, nvis);

				for (int ll = 0; ll < nvis; ll++)
				{
					Inliers[0].push_back(1);
					finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
				}
				finalerror = sqrt(finalerror / nvis);
			}
			if (finalerror > TriangThesh)
				continue;

			double dist = 9e9;
			for (int ii = 0; ii < nvis; ii++)
			{
				int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
				double dpt[] = { mvP3d.pt3D.x, mvP3d.pt3D.y, mvP3d.pt3D.z };
				GetCfromT(VideoInfo[cid].VideoInfo[realframe]);
				double ndist = Distance3D(dpt, VideoInfo[cid].VideoInfo[realframe].camCenter);
				dist = dist < ndist ? dist : ndist;
			}
			if (dist > MinDistToCamThresh)
				continue;

			int ninliers = 0;
			for (int ii = 0; ii < nvis; ii++)
			{
				if (Inliers[0][ii] == 1)
				{
					int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
					pts[ii] = FrameSyncedPoints[cid*nframes*npts + pid * nframes + fid];

					mvP3d.viewID.push_back(cid);
					mvP3d.frameID.push_back(realframe);
					mvP3d.pt2D.push_back(pts[ii]);
					ninliers++;
				}
			}

			if (ninliers < nViewsPlus)
				continue;

			vmvP3d.push_back(mvP3d);
		}

		if (vmvP3d.size() > 10) //enough data for statistical method
		{
			Point3d mean3D(0, 0, 0), var3D(0, 0, 0);
			for (int ii = 0; ii < (int)vmvP3d.size(); ii++)
				mean3D.x += vmvP3d[ii].pt3D.x, mean3D.y += vmvP3d[ii].pt3D.y, mean3D.z += vmvP3d[ii].pt3D.z;
			mean3D.x = mean3D.x / (int)vmvP3d.size(), mean3D.y = mean3D.y / (int)vmvP3d.size(), mean3D.z = mean3D.z / (int)vmvP3d.size();

			for (int ii = 0; ii < vmvP3d.size(); ii++)
				var3D.x += pow(vmvP3d[ii].pt3D.x - mean3D.x, 2), var3D.y += pow(vmvP3d[ii].pt3D.y - mean3D.y, 2), var3D.z += pow(vmvP3d[ii].pt3D.z - mean3D.z, 2);
			var3D.x = var3D.x / (int)vmvP3d.size(), var3D.y = var3D.y / (int)vmvP3d.size(), var3D.z = var3D.z / (int)vmvP3d.size();

			if (var3D.x < stationaryThesh2 && var3D.y < stationaryThesh2 && var3D.z < stationaryThesh2)
				continue;
			else
			{
				//let's sort the 3D points in time
				int nf = (int)vmvP3d.size();
				for (int ii = 0; ii < nf; ii++)
				{
					int cid = vmvP3d[ii].viewID[0], fid = vmvP3d[ii].frameID[0];
					SortedTime[ii] = (fid + frameTimeStamp[cid]); //from real to ref
					dummy[ii] = ii;
				}
				Quick_Sort_Int(SortedTime, dummy, 0, nf - 1);

				int lastvalid = -1; bool foundFirstValid = false, badTraj = false;
				for (int ii = 0; ii < nf - 1; ii++)
				{
					int id1 = dummy[ii], id2 = dummy[ii + 1];
					if (!foundFirstValid)
						lastvalid = id1;
					double dist = Distance3D(vmvP3d[lastvalid].pt3D, vmvP3d[id2].pt3D);
					if (dist < Discon3DThresh)
					{
						foundFirstValid = true;
						lastvalid = id1;
					}
					else
					{
						badTraj = true;
						break;
					}
				}

				if (!badTraj)
				{
					if (refFrame > -1)
						sprintf(Fname, "%s/Track3D/frameSynced_Track_%d_%.4d.txt", Path, pid, refFrame);
					else
						sprintf(Fname, "%s/Track3D/frameSynced_Track_%.4d.txt", Path, pid);
					FILE *fp = fopen(Fname, "w+");
					int lastvalid = -1; bool foundFirstValid = false;
					for (int ii = 0; ii < nf - 1; ii++)
					{
						int id1 = dummy[ii], id2 = dummy[ii + 1];
						if (!foundFirstValid)
							lastvalid = id1;
						double dist = Distance3D(vmvP3d[lastvalid].pt3D, vmvP3d[id2].pt3D);
						if (dist < Discon3DThresh)
						{
							foundFirstValid = true;
							lastvalid = id1;

							for (int jj = 0; jj < (int)vmvP3d[id1].pt2D.size(); jj++)
							{
								int cid = vmvP3d[id1].viewID[jj], fid = vmvP3d[id1].frameID[jj];
								CleanFrameSynID[cid*npts + pid].push_back(fid);
								CleanedFrameSyncedPoints[cid*npts + pid].push_back(vmvP3d[id1].pt2D[jj]);

								//double t = (fid + GTFrameTimeStamp[cid]); //from real to ref
								//fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", vmvP3d[id1].pt3D.x, vmvP3d[id1].pt3D.y, vmvP3d[id1].pt3D.z, t, cid, fid);
							}
							int cid = vmvP3d[id1].viewID[0], fid = vmvP3d[id1].frameID[0];
							double t = (fid + GTFrameTimeStamp[cid]); //from real to ref
							fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", vmvP3d[id1].pt3D.x, vmvP3d[id1].pt3D.y, vmvP3d[id1].pt3D.z, t, cid, fid);
						}
					}
					fclose(fp);
				}
			}
		}
	}

	if (CleanCorrespondencesByTriangulationTest == 1)
	{
		for (int cid = 0; cid < nCams; cid++)
		{
			if (refFrame > -1)
				sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
			else
				sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
			FILE *fp = fopen(Fname, "w+");
			fprintf(fp, "%d\n", npts);
			for (int pid = 0; pid < npts; pid++)
			{
				if (CleanedFrameSyncedPoints[cid*npts + pid].size() < 20)
					continue;
				fprintf(fp, "%d %d ", pid, CleanedFrameSyncedPoints[cid*npts + pid].size());
				for (int fid = 0; fid < CleanedFrameSyncedPoints[cid*npts + pid].size(); fid++)
				{
					int realfid = CleanFrameSynID[cid*npts + pid][fid];
					int fake_fid = realfid + frameTimeStamp[cid]; //fake the order, associated with the ref camera (should range from startF to stopF)
					double s = FrameSyncedS[cid*nframes*npts + pid * nframes + fake_fid - startF];
					Point2d uv = CleanedFrameSyncedPoints[cid*npts + pid][fid];
					LensDistortionPoint(&uv, VideoInfo[cid].VideoInfo[realfid].K, VideoInfo[cid].VideoInfo[realfid].distortion);
					fprintf(fp, "%d %.4f %.4f %.2f ", realfid, uv.x, uv.y, s);
				}
				fprintf(fp, "\n");
			}
			fclose(fp);
		}
	}

	if (createdMem)
		delete[]GTFrameTimeStamp;
	delete[]VideoInfo;
	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	delete[]CamID, delete[]RealframeID, delete[]FrameSyncedPoints, delete[]FrameSyncedPointsDistorted, delete[]FrameSyncedS, delete[]Pmatrix;
	delete[]CleanFrameSynID, delete[]CleanedFrameSyncedPoints;

	return 0;
}
int TriangulateFrameSync2DTrajectories_BK(char *Path, vector<int> &SelectedCams, vector<int> &FrameTimeStamp, int startF, int stopF, int npts, bool CleanCorrespondencesByTriangulationTest, double *GTFrameTimeStamp, double *ialpha, double*Tscale, int realStartFrame)
{
	int nCams = (int)SelectedCams.size();
	bool createdMem = false;
	if (GTFrameTimeStamp == NULL)
	{
		createdMem = true;
		GTFrameTimeStamp = new double[nCams];
		ialpha = new double[1], Tscale = new double[1];
		ialpha[0] = 1.0, Tscale[0] = 1.0;
		for (int ii = 0; ii < nCams; ii++)
			GTFrameTimeStamp[ii] = 0.0;
	}

	char Fname[512];
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
	{
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startF, stopF) == 1)
			return 1;
	}

	vector<int> *RealframeID = new vector<int>[MaxnFrames*npts];
	vector<int> *CamID = new vector<int>[MaxnFrames*npts];
	vector<Point2d> *FrameSyncedPoints = new vector<Point2d>[MaxnFrames*npts];
	vector<Pmat> *Pmatrix = new vector<Pmat>[MaxnFrames*npts];

	Pmat Pm;
	Point2d uv;
	int pid, cid, fid, nf;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (realStartFrame == -1)
			realStartFrame = startF;
		sprintf(Fname, "%s/Track2D/%d_%.4d.txt", Path, SelectedCams[ii], realStartFrame);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			sprintf(Fname, "%s/Track2D/Dyna_%d_%.4d.txt", Path, SelectedCams[ii], realStartFrame);	fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printLOG("Cannot load %s\n", Fname);
				return 1;
			}
		}
		int previousPid = 0;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf ", &fid, &uv.x, &uv.y);
				if (fid<0 || fid>MaxnFrames || !VideoInfo[ii].VideoInfo[fid].valid)
					continue;
				LensCorrectionPoint(&uv, VideoInfo[ii].VideoInfo[fid].K, VideoInfo[ii].VideoInfo[fid].distortion);

				if (VideoInfo[ii].VideoInfo[fid].ShutterModel == 0)
				{
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoInfo[ii].VideoInfo[fid].P[ll];
				}
				else if (VideoInfo[ii].VideoInfo[fid].ShutterModel == 1)
				{
					double *K = VideoInfo[ii].VideoInfo[fid].K;
					double ycn = (uv.y - K[5]) / K[4];
					double xcn = (uv.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[ii].VideoInfo[fid].wt;
					double *R_global = VideoInfo[ii].VideoInfo[fid].R;
					double *T_global = VideoInfo[ii].VideoInfo[fid].T;

					double wx = ycn * wt[0], wy = ycn * wt[1], wz = ycn * wt[2];
					double wx2 = wx * wx, wy2 = wy * wy, wz2 = wz * wz, wxz = wx * wz, wxy = wx * wy, wyz = wy * wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, R_global, R, 3, 3, 3);
					double T[3] = { T_global[0] + ycn * wt[3], T_global[1] + ycn * wt[4], T_global[2] + ycn * wt[5] };

					AssembleP(K, R, T, Pm.P);
				}
				else
					printLOG("Not supported model for motion prior sync\n");

				int fake_fid = fid + FrameTimeStamp[ii]; //fake the order
				if (fake_fid<0 || fake_fid>MaxnFrames)
					continue;

				CamID[fake_fid + pid * MaxnFrames].push_back(ii);
				RealframeID[fake_fid + pid * MaxnFrames].push_back(fid);
				FrameSyncedPoints[fake_fid + pid * MaxnFrames].push_back(uv);
				Pmatrix[fake_fid + pid * MaxnFrames].push_back(Pm);
			}
		}
		fclose(fp);
	}

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2];
	double *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2];
	double *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];
	vector<int>Inliers[1];  Inliers[0].reserve(nCams * 2);

	vector<int> *CleanFrameSynID;
	vector<Point2d> *CleanedFrameSyncedPoints;
	if (CleanCorrespondencesByTriangulationTest)
		CleanFrameSynID = new vector<int>[nCams*npts], CleanedFrameSyncedPoints = new vector<Point2d>[nCams*npts];

	//sprintf(Fname, "%s/Track3D/frameSynced_Track_%.4d.txt", Path, startF);  FILE *fp = fopen(Fname, "w+");
	sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
	for (pid = 0; pid < npts; pid++)
	{
		sprintf(Fname, "%s/Track3D/frameSynced_Track_%d_%.4d.txt", Path, pid, realStartFrame);  FILE *fp = NULL;
		for (int kk = 0; kk <= stopF - startF; kk++)
		{
			int nvis = (int)FrameSyncedPoints[kk + pid * MaxnFrames].size();
			if (nvis < 2)
				continue;
			if (fp == NULL)
				fp = fopen(Fname, "w+");

			vector<int> cameraID, frameID;
			for (int ii = 0; ii < nvis; ii++)
			{
				cameraID.push_back(CamID[kk + pid * MaxnFrames][ii]);
				frameID.push_back(RealframeID[kk + pid * MaxnFrames][ii]);
				uv = FrameSyncedPoints[kk + pid * MaxnFrames][ii];
				pts[ii] = FrameSyncedPoints[kk + pid * MaxnFrames][ii];

				for (int ll = 0; ll < 12; ll++)
					P[12 * ii + ll] = Pmatrix[kk + pid * MaxnFrames][ii].P[ll];
			}

			/*finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 2, 10, 0.5, 10, A, B, tP);
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
			if (Inliers[0].at(ii))
			ninlier++;
			Inliers[0].clear();
			if (ninlier>=5)*/
			NviewTriangulation(pts, P, &P3d, nvis, 1, NULL, A, B);
			ProjectandDistort(P3d, ppts, P, NULL, NULL, nvis);

			int nvalid = 0;
			double finalerror = 0.0;
			for (int ll = 0; ll < nvis; ll++)
				finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2), nvalid++;
			finalerror = sqrt(finalerror / nvis);

			if (finalerror < 1000 && nvalid >= 2)
			{
				for (int ii = 0; ii < nvis; ii++)
				{
					cid = CamID[kk + pid * MaxnFrames][ii], fid = RealframeID[kk + pid * MaxnFrames][ii];
					fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", P3d.x, P3d.y, P3d.z, (GTFrameTimeStamp[cid] + fid)*ialpha[0] * Tscale[0], SelectedCams[cid], fid);
				}

				for (int ii = 0; ii < nvis && CleanCorrespondencesByTriangulationTest; ii++)
				{
					cid = CamID[kk + pid * MaxnFrames][ii], fid = RealframeID[kk + pid * MaxnFrames][ii];
					CleanFrameSynID[cid*npts + pid].push_back(fid);
					CleanedFrameSyncedPoints[cid*npts + pid].push_back(FrameSyncedPoints[kk + pid * MaxnFrames][ii]);
				}
			}
			else
				int a = 0;
		}
		if (fp != NULL)
			fclose(fp);
	}


	for (int ii = 0; ii < nCams &&CleanCorrespondencesByTriangulationTest; ii++)
	{
		sprintf(Fname, "%s/Track2D/C_%d_%.4d.txt", Path, SelectedCams[ii], startF);	FILE *fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			if (CleanedFrameSyncedPoints[ii*npts + jj].size() < 20)
				continue;
			fprintf(fp, "%d %d ", jj, CleanedFrameSyncedPoints[ii*npts + jj].size());
			for (int kk = 0; kk < CleanedFrameSyncedPoints[ii*npts + jj].size(); kk++)
				fprintf(fp, "%d %.4f %.4f ", CleanFrameSynID[ii*npts + jj][kk], CleanedFrameSyncedPoints[ii*npts + jj][kk].x, CleanedFrameSyncedPoints[ii*npts + jj][kk].y);
			fprintf(fp, "\n");
		}
		fclose(fp);
	}

	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	if (createdMem)
		delete[]CleanFrameSynID, delete[]CleanedFrameSyncedPoints;

	return 0;
}
int TriangulateFrameSync2DTrajectories2(char *Path, vector<int> &SelectedCams, vector<int> &frameTimeStamp, int refFrame, int startF, int stopF, int nViewsPlus, double TriangThesh, double stationaryThesh, double MinDistToCamThresh, double Discon3DThresh, int CleanCorrespondencesByTriangulationTest, double *GTFrameTimeStamp, double *ialpha, double*Tscale)
{
	double stationaryThesh2 = stationaryThesh * stationaryThesh;
	int nCams = (int)SelectedCams.size();
	int minStamp = 9e9, maxStamp = -9e9, minLength = 2;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (minStamp > frameTimeStamp[ii])
			minStamp = frameTimeStamp[ii];
		if (maxStamp < frameTimeStamp[ii])
			maxStamp = frameTimeStamp[ii];
	}

	bool createdMem = false;
	if (GTFrameTimeStamp == NULL)
	{
		createdMem = true;
		GTFrameTimeStamp = new double[nCams];
		ialpha = new double[1], Tscale = new double[1];
		ialpha[0] = 1.0, Tscale[0] = 1000.0;

		for (int ii = 0; ii < nCams; ii++)
			GTFrameTimeStamp[ii] = frameTimeStamp[ii];
	}

	char Fname[512];
	int nloaded = 0;
	VideoData *VideoI = new VideoData[nCams];
	for (int cid = 0; cid < nCams; cid++)
	{
		if (ReadVideoDataI(Path, VideoI[cid], SelectedCams[cid], startF, stopF) == 1)
			continue;
		else
			nloaded++;
	}
	if (nloaded < 3)
	{
		printLOG("Less than 3 calibrated cameras are avail!\n");
		exit(1);
	}

	int npts, nframes = stopF - startF + 1;
	int *RealframeID = 0;
	Point2f *FrameSyncedPoints = 0;
	Pmat *Pmatrix = 0;


	for (int cid = 0; cid < nCams; cid++)
	{
		if (refFrame > -1)
			sprintf(Fname, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
		else
			sprintf(Fname, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
		FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printLOG("Cannot load %s\n", Fname);
			continue;
		}
		int previousPid = 0;
		fscanf(fp, "%d", &npts);
		if (RealframeID == NULL)
		{
			RealframeID = new int[nframes*npts*nCams];
			FrameSyncedPoints = new Point2f[nframes*npts*nCams];
			Pmatrix = new Pmat[nframes*npts*nCams];
			for (int ii = 0; ii < nframes*npts*nCams; ii++)
				RealframeID[ii] = -1;
		}

		int pid, fid, nf;
		Pmat Pm;
		Point2d uv, uvd; float s, a, w0, w1, w2, w3;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			bool tooshort = false;
			if (nf < minLength)
				tooshort = true;
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf %f %f %f %f %f %f ", &fid, &uv.x, &uv.y, &s, &a, &w0, &w1, &w2, &w3);
				//fscanf(fp, "%d %lf %lf %f ", &fid, &uv.x, &uv.y, &s);
				//if (fid<startF - maxStamp || fid>stopF - minStamp )
				if (fid<startF || fid>stopF)
					continue;
				if (!VideoI[cid].VideoInfo[fid].valid)
					continue;
				if (tooshort)
					continue;

				uvd = uv;
				LensCorrectionPoint(&uv, VideoI[cid].VideoInfo[fid].K, VideoI[cid].VideoInfo[fid].distortion);

				if (VideoI[cid].VideoInfo[fid].ShutterModel == 0)
				{
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoI[cid].VideoInfo[fid].P[ll];
				}
				else if (VideoI[cid].VideoInfo[fid].ShutterModel == 1)
					AssembleP_RS(uv, VideoI[cid].VideoInfo[fid], Pm.P);
				else
					printLOG("Not supported model for motion prior sync\n");

				int fake_fid = fid + frameTimeStamp[cid]; //fake the order, associated with the ref camera (should range from startF to stopF)
				if (fake_fid<startF || fake_fid>stopF)
					continue;

				RealframeID[cid*nframes*npts + pid * nframes + fake_fid - startF] = fid;
				FrameSyncedPoints[cid*nframes*npts + pid * nframes + fake_fid - startF] = uv;
				for (int ll = 0; ll < 12; ll++)
					Pmatrix[cid*nframes*npts + pid * nframes + fake_fid - startF].P[ll] = Pm.P[ll];
			}
		}
		fclose(fp);
	}

	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];

	MultiViewPtEle mvP3d;
	vector<MultiViewPtEle> vmvP3d;
	vector<int>PvalidCamID;
	vector<int> *CleanFrameSynID = new vector<int>[nCams*npts];
	vector<Point2d> *CleanedFrameSyncedPoints = new vector<Point2d>[nCams*npts];
	int *SortedTime = new int[nframes], *dummy = new int[nframes];

	sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
	for (int pid = 0; pid < npts; pid++)
	{
		vmvP3d.clear();
		for (int fid = 0; fid < nframes; fid++)
		{
			PvalidCamID.clear(), mvP3d.viewID.clear(), mvP3d.frameID.clear(), mvP3d.pt2D.clear();
			for (int cid = 0; cid < nCams; cid++)
			{
				if (RealframeID[cid*nframes*npts + pid * nframes + fid] > -1)
					PvalidCamID.push_back(cid);
			}
			int nvis = (int)PvalidCamID.size();
			if (nvis < nViewsPlus)
				continue;
			for (int ii = 0; ii < nvis; ii++)
			{
				int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
				pts[ii] = FrameSyncedPoints[cid*nframes*npts + pid * nframes + fid];
				for (int ll = 0; ll < 12; ll++)
					P[12 * ii + ll] = Pmatrix[cid*nframes*npts + pid * nframes + fid].P[ll];
			}

			vector<int>Inliers[1];
			double finalerror = 0.0;
			if (nvis >= 2 * nViewsPlus)
				finalerror = NviewTriangulationRANSAC(pts, P, &mvP3d.pt3D, passed, Inliers, nvis, 1, 2, 20, 1.0 * 2 / nvis, TriangThesh, A, B, tP);
			else
			{
				NviewTriangulation(pts, P, &mvP3d.pt3D, nvis, 1, NULL, A, B);
				ProjectandDistort(mvP3d.pt3D, ppts, P, NULL, NULL, nvis);

				for (int ll = 0; ll < nvis; ll++)
				{
					Inliers[0].push_back(1);
					finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
				}
				finalerror = sqrt(finalerror / nvis);
			}
			if (finalerror > TriangThesh)
				continue;

			double dist = 9e9;
			for (int ii = 0; ii < nvis; ii++)
			{
				int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
				double dpt[] = { mvP3d.pt3D.x, mvP3d.pt3D.y, mvP3d.pt3D.z };
				GetCfromT(VideoI[cid].VideoInfo[realframe]);
				double ndist = Distance3D(dpt, VideoI[cid].VideoInfo[realframe].camCenter);
				dist = dist < ndist ? dist : ndist;
			}
			if (dist > MinDistToCamThresh)
				continue;

			int ninliers = 0;
			for (int ii = 0; ii < nvis; ii++)
			{
				if (Inliers[0][ii] == 1)
				{
					int cid = PvalidCamID[ii], realframe = RealframeID[cid*nframes*npts + pid * nframes + fid];
					pts[ii] = FrameSyncedPoints[cid*nframes*npts + pid * nframes + fid];

					mvP3d.viewID.push_back(cid);
					mvP3d.frameID.push_back(realframe);
					mvP3d.pt2D.push_back(pts[ii]);
					ninliers++;
				}
			}

			if (ninliers < nViewsPlus)
				continue;

			vmvP3d.push_back(mvP3d);
		}

		if (vmvP3d.size() > 10) //enough data for statistical method
		{
			Point3d mean3D(0, 0, 0), var3D(0, 0, 0);
			for (int ii = 0; ii < (int)vmvP3d.size(); ii++)
				mean3D.x += vmvP3d[ii].pt3D.x, mean3D.y += vmvP3d[ii].pt3D.y, mean3D.z += vmvP3d[ii].pt3D.z;
			mean3D.x = mean3D.x / (int)vmvP3d.size(), mean3D.y = mean3D.y / (int)vmvP3d.size(), mean3D.z = mean3D.z / (int)vmvP3d.size();

			for (int ii = 0; ii < vmvP3d.size(); ii++)
				var3D.x += pow(vmvP3d[ii].pt3D.x - mean3D.x, 2), var3D.y += pow(vmvP3d[ii].pt3D.y - mean3D.y, 2), var3D.z += pow(vmvP3d[ii].pt3D.z - mean3D.z, 2);
			var3D.x = var3D.x / (int)vmvP3d.size(), var3D.y = var3D.y / (int)vmvP3d.size(), var3D.z = var3D.z / (int)vmvP3d.size();

			if (var3D.x < stationaryThesh2 && var3D.y < stationaryThesh2 && var3D.z < stationaryThesh2)
				continue;
			else
			{
				//let's sort the 3D points in time
				int nf = (int)vmvP3d.size();
				for (int ii = 0; ii < nf; ii++)
				{
					int cid = vmvP3d[ii].viewID[0], fid = vmvP3d[ii].frameID[0];
					SortedTime[ii] = (fid + frameTimeStamp[cid]); //from real to ref
					dummy[ii] = ii;
				}
				Quick_Sort_Int(SortedTime, dummy, 0, nf - 1);

				int lastvalid = -1; bool foundFirstValid = false, badTraj = false;
				for (int ii = 0; ii < nf - 1; ii++)
				{
					int id1 = dummy[ii], id2 = dummy[ii + 1];
					if (!foundFirstValid)
						lastvalid = id1;
					double dist = Distance3D(vmvP3d[lastvalid].pt3D, vmvP3d[id2].pt3D);
					if (dist < Discon3DThresh)
					{
						foundFirstValid = true;
						lastvalid = id1;
					}
					else
					{
						badTraj = true;
						break;
					}
				}

				if (!badTraj)
				{
					if (refFrame > -1)
						sprintf(Fname, "%s/Track3D/frameSynced_Track_%d_%.4d.txt", Path, pid, refFrame);
					else
						sprintf(Fname, "%s/Track3D/frameSynced_Track_%.4d.txt", Path, pid);
					FILE *fp = fopen(Fname, "w+");
					int lastvalid = -1; bool foundFirstValid = false;
					for (int ii = 0; ii < nf - 1; ii++)
					{
						int id1 = dummy[ii], id2 = dummy[ii + 1];
						if (!foundFirstValid)
							lastvalid = id1;
						double dist = Distance3D(vmvP3d[lastvalid].pt3D, vmvP3d[id2].pt3D);
						if (dist < Discon3DThresh)
						{
							foundFirstValid = true;
							lastvalid = id1;

							for (int jj = 0; jj < (int)vmvP3d[id1].pt2D.size(); jj++)
							{
								int cid = vmvP3d[id1].viewID[jj], fid = vmvP3d[id1].frameID[jj];
								CleanFrameSynID[cid*npts + pid].push_back(fid);
								CleanedFrameSyncedPoints[cid*npts + pid].push_back(vmvP3d[id1].pt2D[jj]);
								double ialpha = 1.0 / VideoI[cid].VideoInfo[fid].fps;
								double currentTime = (GTFrameTimeStamp[cid] + fid) * ialpha*Tscale[0]; //from real to ref -->time
								fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", vmvP3d[id1].pt3D.x, vmvP3d[id1].pt3D.y, vmvP3d[id1].pt3D.z, currentTime, SelectedCams[cid], fid);
							}
							int cid = vmvP3d[id1].viewID[0], fid = vmvP3d[id1].frameID[0];
							double ialpha = 1.0 / VideoI[cid].VideoInfo[fid].fps;
							double currentTime = (GTFrameTimeStamp[cid] + fid) * ialpha*Tscale[0]; //from real to ref -->time
																								   //fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", vmvP3d[id1].pt3D.x, vmvP3d[id1].pt3D.y, vmvP3d[id1].pt3D.z, currentTime, SelectedCams[cid], fid);
						}
					}
					fclose(fp);
				}
			}
		}
	}

	if (CleanCorrespondencesByTriangulationTest == 1)
	{
		for (int cid = 0; cid < nCams; cid++)
		{
			int previousPid = 0, pid, fid, nf;
			Point2d uv; float s, a;
			AffinePara wp;
			vector<int> vfid;
			vector<Point2d> vuv;
			vector<float> vs, va;
			vector<AffinePara> vwp;

			char Fname1[512], Fname2[512];
			if (refFrame > -1)
				sprintf(Fname1, "%s/Track2D/Ultimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
			else
				sprintf(Fname1, "%s/Track2D/Ultimate_%.4d.txt", Path, SelectedCams[cid]);
			FILE *fp = fopen(Fname1, "r");
			if (fp == NULL)
				continue;
			fscanf(fp, "%d", &npts);

			if (refFrame > -1)
				sprintf(Fname2, "%s/Track2D/CUltimate_%d_%.4d.txt", Path, SelectedCams[cid], refFrame);
			else
				sprintf(Fname2, "%s/Track2D/CUltimate_%.4d.txt", Path, SelectedCams[cid]);
			FILE *fp2 = fopen(Fname2, "w+"); fprintf(fp2, "%d\n", npts);
			while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
			{
				if (CleanedFrameSyncedPoints[cid*npts + pid].size() < minLength)
					for (int kk = 0; kk < nf; kk++)
						fscanf(fp, "%d %lf %lf %f %f %lf %lf %lf %lf ", &fid, &uv.x, &uv.y, &s, &a, &wp.warp[0], &wp.warp[1], &wp.warp[2], &wp.warp[3]);
				else
				{
					vfid.clear(), vuv.clear(), vs.clear(), va.clear(), vwp.clear();
					for (int kk = 0; kk < nf; kk++)
					{
						fscanf(fp, "%d %lf %lf %f %f %lf %lf %lf %lf ", &fid, &uv.x, &uv.y, &s, &a, &wp.warp[0], &wp.warp[1], &wp.warp[2], &wp.warp[3]);
						vfid.push_back(fid), vuv.push_back(uv), vs.push_back(s), va.push_back(a), vwp.push_back(wp);
					}

					fprintf(fp2, "%d %d ", pid, min(nf, (int)CleanedFrameSyncedPoints[cid*npts + pid].size()));
					for (int fid = 0; fid < (int)CleanedFrameSyncedPoints[cid*npts + pid].size(); fid++)
					{
						int realfid = CleanFrameSynID[cid*npts + pid][fid];

						int sid = -1;
						for (int ii = 0; ii < (int)vfid.size() && sid == -1; ii++)
							if (vfid[ii] == realfid)
								sid = ii;

						if (sid != -1)
							fprintf(fp2, "%d %.4f %.4f %.2f %.4f %.8f %.8f %.8f %.8f ", vfid[sid], vuv[sid].x, vuv[sid].y, vs[sid], va[sid], vwp[sid].warp[0], vwp[sid].warp[1], vwp[sid].warp[2], vwp[sid].warp[3]);
					}
					fprintf(fp2, "\n");
				}
			}
			fclose(fp), fclose(fp2);

			MyCopyFile(Fname2, Fname1);
			remove(Fname2);
		}
	}

	if (createdMem)
		delete[]GTFrameTimeStamp;
	delete[]VideoI;
	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	delete[]RealframeID, delete[]FrameSyncedPoints, delete[]Pmatrix;
	delete[]CleanFrameSynID, delete[]CleanedFrameSyncedPoints;

	return 0;
}
int TriangulationSyncRobustBruteForce2DStereoAllInstances(char *Path, int *SelectedCams, vector<int> &TrackingInst, int TrajRange, int startF, int stopF, int increImgFrames, int allNpts, int *frameTimeStamp, int LowBound, int UpBound, vector<ImgPtEle> *PerCam_UV, double TriangThresh, bool silent)
{
	//The goad is to accumulate all info from all instances for sync. This function only looks at points where there is a valley in the cost(offset) to sync and filter points
	char Fname[512]; FILE *fp = 0;
	const int nCams = 2;
	int minStamp = min(frameTimeStamp[0], frameTimeStamp[1]), maxStamp = max(frameTimeStamp[0], frameTimeStamp[1]);

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startF - maxStamp - TrajRange, stopF - minStamp + TrajRange) == 1)
		return 1;

	ImgPtEle ptEle;
	bool createdMem = false;
	if (PerCam_UV == NULL)
	{
		createdMem = true;
		PerCam_UV = new vector<ImgPtEle>[nCams*allNpts];
		for (int camID = 0; camID < nCams; camID++)
			for (int pid = 0; pid < allNpts; pid++)
				PerCam_UV[camID*allNpts + pid].reserve(TrajRange + 1);
	}
	else
	{
		for (int camID = 0; camID < nCams; camID++)
			for (int trackID = 0; trackID < allNpts; trackID++)
				PerCam_UV[camID*allNpts + trackID].clear();
	}

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		float u, v, s, a, w0, w1, w2, w3;
		int pid, fid, nf, nptsSeed, nptsCum = 0, nseeds = (int)TrackingInst.size();
		for (int seedID = 0; seedID < nseeds; seedID++)
		{
			sprintf(Fname, "%s/Track2D/CC_%d_%.4d.txt", Path, SelectedCams[camID], TrackingInst[seedID]);
			if (IsFileExist(Fname) == 0)
			{
				printLOG("Cannot load %s\n", Fname);
				abort();
			}
			FILE *fp = fopen(Fname, "r");
			fscanf(fp, "%d ", &nptsSeed);
			while (fscanf(fp, "%d %d", &pid, &nf) != EOF)
			{
				for (int ii = 0; ii < nf; ii++)
				{
					fscanf(fp, "%d %f %f %f %f %f %f %f %f ", &fid, &u, &v, &s, &a, &w0, &w1, &w2, &w3);
					if (!VideoInfo[camID].VideoInfo[fid].valid)
						continue; //camera not localized

					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.scale = s, ptEle.frameID = fid;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[fid].K, VideoInfo[camID].VideoInfo[fid].distortion);
					PerCam_UV[camID*allNpts + pid + nptsCum].push_back(ptEle);
				}
			}
			fclose(fp);

			nptsCum += nptsSeed; //nptsCum == allNpts in the end
		}
	}

	//Filter outliers again
	int ngoodPoint = 0;
	int *aOffset = new int[UpBound - LowBound + 1], *badPoints = new int[allNpts];
	double *aError = new double[UpBound - LowBound + 1], *saError = new double[UpBound - LowBound + 1];
	vector<double> vaError; vaError.resize(UpBound - LowBound + 1);
	double A[12], B[4], P[24]; Point2d pts[2], ppts[2]; Point3d P3d;
	for (int pid = 0; pid < allNpts; pid++)
	{
		int count = 0;
		double maxError = 0, minError = 9e9;
		for (int off = LowBound * increImgFrames; off <= UpBound * increImgFrames; off += increImgFrames)
		{
			double cumError = 0.0, usedPointsCount = 0;
			for (int fid1 = 0; fid1 < PerCam_UV[pid].size(); fid1++)
			{
				double error = 0.0;
				int ref1 = PerCam_UV[pid][fid1].frameID; //the point has been tracked at the offset frame already
				for (int fid2 = 0; fid2 < PerCam_UV[allNpts + pid].size(); fid2++)
				{
					int ref2 = PerCam_UV[allNpts + pid][fid2].frameID; //the point has been tracked at the offset frame already
					if (ref1 + frameTimeStamp[0] == ref2 + frameTimeStamp[1] + off) //see if the corresponding frame in the other camera has point. Use addition to fake the refframe: 
					{
						if (VideoInfo[0].VideoInfo[ref1].valid == 0 || VideoInfo[1].VideoInfo[ref2].valid == 0)
							continue;

						pts[0] = PerCam_UV[pid][fid1].pt2D, pts[1] = PerCam_UV[allNpts + pid][fid2].pt2D;

						Point2d pt1 = pts[0], pt2 = pts[1];
						LensDistortionPoint(&pt1, VideoInfo[0].VideoInfo[ref1].K, VideoInfo[0].VideoInfo[ref1].distortion);
						LensDistortionPoint(&pt2, VideoInfo[1].VideoInfo[ref2].K, VideoInfo[0].VideoInfo[ref2].distortion);

						if (VideoInfo[0].VideoInfo[ref1].ShutterModel == 0)
							AssembleP(VideoInfo[0].VideoInfo[ref1].K, VideoInfo[0].VideoInfo[ref1].R, VideoInfo[0].VideoInfo[ref1].T, P);
						else
							AssembleP_RS(pts[0], VideoInfo[0].VideoInfo[ref1], P);

						if (VideoInfo[1].VideoInfo[ref2].ShutterModel == 0)
							AssembleP(VideoInfo[1].VideoInfo[ref2].K, VideoInfo[1].VideoInfo[ref2].R, VideoInfo[1].VideoInfo[ref2].T, P);
						else
							AssembleP_RS(pts[1], VideoInfo[1].VideoInfo[ref2], P + 12);

						NviewTriangulation(pts, P, &P3d, 2, 1, NULL, A, B);
						ProjectandDistort(P3d, ppts, P, NULL, NULL, 2);

						error = 0.0;
						for (int ll = 0; ll < 2; ll++)
							error += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
						error = sqrt(error / 2);

						usedPointsCount++;
						break;
					}
				}
				cumError += error;
			}
			aError[count] = cumError / (0.0000001 + usedPointsCount);
			vaError[count] = cumError / (0.0000001 + usedPointsCount);
			if (usedPointsCount > 0)
			{
				maxError = max(maxError, aError[count]);
				minError = min(minError, aError[count]);
			}
			count++;
		}

		/*bool OK = false;
		if (OK)
		{
		FILE *fp = fopen("C:/temp/cost.txt", "w+");
		for (int ii = 0; ii<241; ii++)
		fprintf(fp, "%.4f\n", vaError[ii]);
		fclose(fp);
		}*/
		if (minError / maxError > 0.25 || minError == 0 || minError > TriangThresh) //there is a valley in the cost function -->almost always corredponding trajectory
			badPoints[pid] = 1;
		else
		{
			badPoints[pid] = 0;
			ngoodPoint++;
			if (!silent)
				printLOG("%d ...", pid);
		}
	}
	printLOG("\nFound %d good points\n", ngoodPoint);

	//Start sliding
	int count = 0, BestOffset = 9e9;
	double minError = 9e9;
	for (int off = LowBound * increImgFrames; off <= UpBound * increImgFrames; off += increImgFrames)
	{
		double cumError = 0.0, usedPointsCount = 0;
		for (int pid = 0; pid < allNpts; pid++)
		{
			if (badPoints[pid] == 1)
				continue;
			for (int fid1 = 0; fid1 < PerCam_UV[pid].size(); fid1++)
			{
				double error = 0.0;
				int ref1 = PerCam_UV[pid][fid1].frameID; //the point has been tracked at the offset frame already
				for (int fid2 = 0; fid2 < PerCam_UV[allNpts + pid].size(); fid2++)
				{
					int ref2 = PerCam_UV[allNpts + pid][fid2].frameID; //the point has been tracked at the offset frame already
					if (ref1 + frameTimeStamp[0] == ref2 + frameTimeStamp[1] + off) //see if the corresponding frame in the other camera has point. Use addition to fake the refframe: 
					{
						if (VideoInfo[0].VideoInfo[ref1].valid == 0 || VideoInfo[1].VideoInfo[ref2].valid == 0)
							continue;

						pts[0] = PerCam_UV[pid][fid1].pt2D, pts[1] = PerCam_UV[allNpts + pid][fid2].pt2D;
						if (VideoInfo[0].VideoInfo[ref1].ShutterModel == 0)
							AssembleP(VideoInfo[0].VideoInfo[ref1].K, VideoInfo[0].VideoInfo[ref1].R, VideoInfo[0].VideoInfo[ref1].T, P);
						else
							AssembleP_RS(pts[0], VideoInfo[0].VideoInfo[ref1], P);

						if (VideoInfo[1].VideoInfo[ref2].ShutterModel == 0)
							AssembleP(VideoInfo[1].VideoInfo[ref2].K, VideoInfo[1].VideoInfo[ref2].R, VideoInfo[1].VideoInfo[ref2].T, P);
						else
							AssembleP_RS(pts[1], VideoInfo[1].VideoInfo[ref2], P + 12);

						NviewTriangulation(pts, P, &P3d, 2, 1, NULL, A, B);
						ProjectandDistort(P3d, ppts, P, NULL, NULL, 2);

						error = 0.0;
						for (int ll = 0; ll < 2; ll++)
							error += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2);
						error = sqrt(error / 2);
						usedPointsCount++;

						break;
					}
				}
				cumError += error;
			}
		}

		if (usedPointsCount == 0)
			cumError = 9e9;
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		aError[count] = cumError;
		aOffset[count] = off;
		printLOG("@off %d (id: %d): %.5e -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	Quick_Sort_Double(aError, aOffset, 0, count - 1);
	printLOG("Pair (%d, %d): %d: %.3e  ... %d: %.3e \n", SelectedCams[0], SelectedCams[1], aOffset[0], aError[0], aOffset[1], aError[1]);

	frameTimeStamp[1] = frameTimeStamp[1] + BestOffset;

	for (int cid = 0; cid < nCams; cid++)
	{
		sprintf(Fname, "%s/Track2D/UltimateID_%.4d.txt", Path, SelectedCams[cid]);	FILE *fp = fopen(Fname, "a+");
		for (int pid = 0; pid < allNpts; pid++)
		{
			if (badPoints[pid] != 0)
				continue;
			fprintf(fp, "%d ", pid);
		}
		fprintf(fp, "\n");
		fclose(fp);
	}

	if (createdMem)
		delete[]PerCam_UV;
	delete[]aOffset, delete[]aError, delete[]saError, delete[]badPoints;

	return 0;
}

//Find depth &scale wrst to camera
void Get3DPtfromDist(double *Kinv, double *Rinv, double *T, Point2d& pt, double depth, Point3d &pt3D)
{
	Mat ptMat = Mat::ones(3, 1, CV_64F);
	Mat mKinv(3, 3, CV_64F, Kinv);
	Mat mRinv(3, 3, CV_64F, Rinv);
	Mat mT(3, 1, CV_64F, T);

	ptMat.at<double>(0, 0) = pt.x;
	ptMat.at<double>(1, 0) = pt.y;


	ptMat = mKinv * ptMat;
	ptMat = ptMat / ptMat.at<double>(2, 0);
	ptMat = ptMat * depth;
	ptMat = mRinv * (ptMat - mT);//from cam coord to world coord

	pt3D.x = ptMat.at<double>(0, 0);
	pt3D.y = ptMat.at<double>(1, 0);
	pt3D.z = ptMat.at<double>(2, 0);

	return;
}
bool SelectRefCam_InitPatchFixedScale(Point3d *expansionVec, double &scale3D, Point3d p3D, vector<KeyPoint> pts, vector<CameraData> AllViewsInfo, double PATCH_3D_ARROW_SIZE_WORLD_UNIT)
{
	//reference frame
	double bestScale = -1;
	int bestVisibleIdx = -1;

	//Find the one which has the largest SIFT scale. 
	for (unsigned int i = 0; i < pts.size(); ++i)
	{
		double scale = pts[i].size;		//This is the diameter!!! 
		double patchHalfSize = scale / 2.0;

		double xMax = pts[i].pt.x + scale;
		double xMin = pts[i].pt.x - scale;
		double yMax = pts[i].pt.y + scale;
		double yMin = pts[i].pt.y - scale;

		if (xMin < 10 || yMin < 10 || xMax >= AllViewsInfo[i].width - 10 || yMax >= AllViewsInfo[i].height - 10)
			continue;

		if (scale > bestScale)
		{
			bestScale = scale;
			bestVisibleIdx = i;
		}
	}
	if (bestVisibleIdx < 0)
		return false;

	//X = R*WC+T --> last element of X is dept wrst to that visible camera
	double depth = AllViewsInfo[bestVisibleIdx].R[6] * p3D.x + AllViewsInfo[bestVisibleIdx].R[7] * p3D.y + AllViewsInfo[bestVisibleIdx].R[8] * p3D.z + AllViewsInfo[bestVisibleIdx].T[2];
	Point2d keyPt = pts[bestVisibleIdx].pt;  ///pt should be also located on the ray

											 //feature arrow calculation
	double length = pts[bestVisibleIdx].size / 2.0;
	double theta = pts[bestVisibleIdx].angle;//in radian
	Point2d arrowHead1(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);
	theta -= Pi / 2.0;//in radian
	Point2d arrowHead2(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);

	//initialize with patch wich is parallel to reference image
	Point3d PatchCenter;
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, keyPt, depth, PatchCenter);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead1, depth, expansionVec[0]);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead2, depth, expansionVec[1]);

	//Change to the fixed 3D Patch Scale
	Point3d arrow1Direct = expansionVec[0] - PatchCenter;
	normalize(arrow1Direct);
	expansionVec[0] = PatchCenter + arrow1Direct * PATCH_3D_ARROW_SIZE_WORLD_UNIT;
	Point3d arrow2Direct = expansionVec[1] - PatchCenter;
	normalize(arrow2Direct);
	expansionVec[1] = PatchCenter + arrow2Direct * PATCH_3D_ARROW_SIZE_WORLD_UNIT;

	scale3D = Distance3D(PatchCenter, expansionVec[0]);

	return true;
}

bool InsideFrustrum(Frustrum &frus, Vector3d & pt)
{
	Vector3d wrstNearPlane = pt - frus.tln;
	double dp0 = frus.normNearPlane.dot(wrstNearPlane);
	if (dp0 > 0)
		return false;

	Vector3d wrstRightPlane = pt - frus.trn;
	double dp1 = frus.normRightPlane.dot(wrstRightPlane);
	if (dp1 > 0)
		return false;

	Vector3d wrstFarPlane = pt - frus.tlf;
	double dp2 = frus.normFarPlane.dot(wrstFarPlane);
	if (dp2 > 0)
		return false;

	Vector3d wrstLeftPlane = wrstNearPlane;
	double dp3 = frus.normLeftPlane.dot(wrstLeftPlane);
	if (dp3 > 0)
		return false;

	Vector3d wrstTopPlane = wrstNearPlane;
	double dp4 = frus.normTopPlane.dot(wrstTopPlane);
	if (dp4 > 0)
		return false;

	Vector3d wrstBottomPlane = pt - frus.bln;
	double dp5 = frus.normBottomPlane.dot(wrstBottomPlane);
	if (dp5 > 0)
		return false;

	return true;
}
double computeOverlappingMetric(CameraData &CamI, CameraData &CamJ, double angleDegThresh, double baselineThresh, double nearPlane, double farPlane, int nLayers, int nSamplesPerLayer)
{
	double baseline = Distance3D(CamI.camCenter, CamJ.camCenter);
	if (baseline > baselineThresh)
		return 0.0;

	double imgPoint[3], Ray[3];

	imgPoint[0] = CamI.width / 2, imgPoint[1] = CamI.height / 2, imgPoint[2] = 1;
	double camIRay[3];  getRayDir(camIRay, CamI.invK, CamI.R, imgPoint);

	imgPoint[0] = CamJ.width / 2, imgPoint[1] = CamJ.height / 2, imgPoint[2] = 1;
	double camJRay[3];	getRayDir(camJRay, CamJ.invK, CamJ.R, imgPoint);

	double  angleThres = std::cos(angleDegThresh / 180 * Pi);
	double angle = dotProduct(camIRay, camJRay);
	if (angle < angleThres)//larger than 135 deg
		return  0.0;


	Vector3d camICenter, camJCenter;
	camICenter << CamI.camCenter[0], CamI.camCenter[1], CamI.camCenter[2];
	camJCenter << CamJ.camCenter[0], CamJ.camCenter[1], CamJ.camCenter[2];

	//makre frustum 
	Vector3d tln[2], tlf[2], trn[2], trf[2], brn[2], brf[2], bln[2], blf[2];
	for (int ii = 0; ii < 2; ii++)
	{
		int width = ii == 0 ? CamI.width : CamI.width;
		int height = ii == 0 ? CamI.height : CamI.height;
		double *invK = ii == 0 ? CamI.invK : CamJ.invK;
		double *R = ii == 0 ? CamI.R : CamJ.R;
		Vector3d cc = ii == 0 ? camICenter : camJCenter;

		imgPoint[0] = 0, imgPoint[1] = 0, imgPoint[2] = 1;
		getRayDir(Ray, invK, R, imgPoint);
		tln[ii] << Ray[0], Ray[1], Ray[2]; tln[ii] = tln[ii] * nearPlane + cc;
		tlf[ii] << Ray[0], Ray[1], Ray[2]; tlf[ii] = tlf[ii] * farPlane + cc;

		imgPoint[0] = width, imgPoint[1] = 0, imgPoint[2] = 1;
		getRayDir(Ray, invK, R, imgPoint);
		trn[ii] << Ray[0], Ray[1], Ray[2]; trn[ii] = trn[ii] * nearPlane + cc;
		trf[ii] << Ray[0], Ray[1], Ray[2]; trf[ii] = trf[ii] * farPlane + cc;

		imgPoint[0] = width, imgPoint[1] = height, imgPoint[2] = 1;
		getRayDir(Ray, invK, R, imgPoint);
		brn[ii] << Ray[0], Ray[1], Ray[2]; brn[ii] = brn[ii] * nearPlane + cc;
		brf[ii] << Ray[0], Ray[1], Ray[2]; brf[ii] = brf[ii] * farPlane + cc;

		imgPoint[0] = 0, imgPoint[1] = height, imgPoint[2] = 1;
		getRayDir(Ray, invK, R, imgPoint);
		bln[ii] << Ray[0], Ray[1], Ray[2]; bln[ii] = bln[ii] * nearPlane + cc;
		blf[ii] << Ray[0], Ray[1], Ray[2]; blf[ii] = blf[ii] * farPlane + cc;
	}

	//evenly make points inside volume_I and check if inside volume_J
	int sqrtSample = (int)(sqrt(nSamplesPerLayer));
	int sampleIncreX = CamI.width / sqrtSample, sampleIncreY = CamI.height / sqrtSample;
	double depthIncre = (farPlane - nearPlane) / nLayers;

	Frustrum frus(tln[1], tlf[1], trn[1], trf[1], brn[1], brf[1], bln[1], blf[1]);


	int nthreads = omp_get_max_threads();
	vector<int> vInside(nthreads, 0);

	omp_set_num_threads(nthreads);
#pragma omp parallel for schedule(dynamic,1)
	for (int id = 0; id < sqrtSample* sqrtSample; id++)
	{
		int ii = id % sqrtSample, jj = id / sqrtSample, threadId = omp_get_thread_num();
		double imgPoint[3], Ray[3];
		for (int kk = 0; kk < nLayers; kk++)
		{
			imgPoint[0] = ii * sampleIncreX, imgPoint[1] = jj * sampleIncreY, imgPoint[2] = 1;
			getRayDir(Ray, CamI.invK, CamI.R, imgPoint);

			Vector3d pt; pt << Ray[0], Ray[1], Ray[2];
			pt = pt * (kk*depthIncre + nearPlane) + camICenter;
			if (InsideFrustrum(frus, pt))
				vInside[threadId]++;
		}
	}
	int inside = 0;
	for (int ii = 0; ii < nthreads; ii++)
		inside += vInside[ii];

	double score = 1.0*inside / (sqrtSample * sqrtSample*nLayers);
	return score;
}